group C;



concat(a,b) ::= <<
<a><b>
>>



type( field ) ::= <<
< if(     field.isBoolean )>bool  <
  elseif( field.isByte    )>byte  <
  elseif( field.isShort   )>short <
  elseif( field.isUshort  )>ushort<
  elseif( field.isInt     )>int   <
  elseif( field.isUint    )>uint  <
  elseif( field.isLong    )>long  <
  elseif( field.isUlong   )>ulong <
  elseif( field.isFloat   )>float <
  elseif( field.isDouble  )>double<
  elseif( field.isString  )>char  <
  elseif( field.isEnum    )><field.userType.name; format="cname"><
  elseif( field.isStruct  )><field.userType.name; format="cname"><
  else>
#error Field n'est d'aucun type connu : <field>!<
  endif>
>>



signature( prefix, fields ) ::= <<
<fields:{field|
, < if( field.isBoolean )>bool<
elseif( field.isString  )>const char *<
elseif( field.isEnum    )><prefix>_<field.userType.name; format="cname"><
elseif( field.isStruct  )>const <prefix>_<field.userType.name; format="cname"> *<
else                     ><type(field)><
endif                    > <field.name; format="cname">}>
>>



args( fields ) ::= <<
<fields:{field|, <
   if( field.isStruct  )>&<
   endif                ><field.name; format="cname">}>
>>



byteBufferPut( this, fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_put_bool( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_put_short( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_put_ushort( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_put_int( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_put_uint( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_put_long( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_put_ulong( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_put_float( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_put_double( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_put_string( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isStruct  )>UTIL_ERROR_CHECK( <typesPrefix>_<field.userType.name; format="cname">_put( <this><field.name; format="cname">, &This->out ));
< endif>
}>
>>



enumHeader( prefix, enum ) ::= <<
#pragma once

typedef enum <prefix>_<enum.name; format="cname">_e {
   <prefix; format="upper">_<enum.name; format="ID">_FIRST,

< first(enum.literal):{literal|
   <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID"> = <
    prefix; format="upper">_<enum.name; format="ID">_FIRST,}>
< rest(enum.literal) :{literal|
   <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID">,
}>
   <prefix; format="upper">_<enum.name; format="ID">_LAST

} <prefix>_<enum.name; format="cname">;

const char * <prefix>_<enum.name; format="cname">_to_string( <prefix>_<enum.name; format="cname"> value ); 

>>



enumBody( prefix, enum ) ::= <<
#include \<<prefix>/<enum.name; format="cname">.h>

const char * <prefix>_<enum.name; format="cname">_to_string( <prefix>_<enum.name; format="cname"> value ) {
   switch( value ) {
   <enum.literal:{literal|
   case <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID,width">: return "<literal.name; format="ID">";
}>   default: return "Etat inconnu !";
   }
}

>>



structHeader( prefix, struct ) ::= <<
#pragma once

#include \<io/byte_buffer.h>

<struct.field:{field|<
if( field.isStruct || field.isEnum )>
#include \<<prefix>/<type(field)>.h><
endif>}>

typedef struct <prefix>_<struct.name; format="cname">_s {
<struct.field:{field|<
if( field.isString )>
   char <field.name; format="cname">[ <field.length> + 1 ];<
elseif( field.isStruct || field.isEnum )>
   <prefix>_<type(field)> <field.name; format="cname">;<
else>
   <type(field)> <field.name; format="cname">;<
endif>}>
} <prefix>_<struct.name; format="cname">;

util_error <prefix>_<struct.name; format="cname">_put( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * target );
util_error <prefix>_<struct.name; format="cname">_get( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * source );

>>



structBody( prefix, struct, maxLength, maxStrLength ) ::= <<
#include \<<prefix>/<struct.name; format="cname">.h>
#include \<stdio.h>

util_error <prefix>_<struct.name; format="cname">_put( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * target ) {
<struct.field:{field|
   < if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_put_bool  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_put_short ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_put_ushort( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_put_int   ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_put_uint  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_put_long  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_put_ulong ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_put_float ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_put_double( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_put_string( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte  ( target, (byte)This-><field.name; format="cname,width"> ));
   < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_put( &This-><field.name; format="cname">, target ));
   < endif>
}>   return UTIL_NO_ERROR;
}

util_error <prefix>_<struct.name; format="cname">_get( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * source ) {
<struct.field:{field|
   < if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_get_bool  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_get_short ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_get_ushort( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_get_int   ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_get_uint  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_get_long  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_get_ulong ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_get_float ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_get_double( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_get_string( source, This-><
         field.name; format="cname,strWidth">, sizeof( This-><field.name; format="cname,strWidth"> )));
   < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( source, (byte *)&This-><field.name; format="cname,width"> ));
   < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_get( &This-><field.name; format="cname">, source ));
   < endif>
}>   return UTIL_NO_ERROR;
}

>>



requiredInterface( typesPrefix, prefix, usedTypes, ifaceName, rawSize, iface ) ::= <<
#pragma once
//requiredInterface
#include \<io/datagram_socket.h>

<usedTypes:{type|#include \<<typesPrefix>/<type; format="cname">.h>
}>
<iface.eventOrRequestOrData:{facet|<
if( facet.arguments )>
#include \<<typesPrefix>/<ifaceName; format="cname">_<facet.name; format="cname">_response.h>
< endif>
}>
typedef struct <prefix>_<ifaceName; format="cname">_s {
   SOCKET             socket;
   struct sockaddr_in target;
   byte               raw[<rawSize>];
   io_byte_buffer     out;
} <prefix>_<ifaceName; format="cname">;

util_error <prefix>_<ifaceName; format="cname">_init( <prefix>_<ifaceName; format="cname"
> * This, SOCKET socket, const struct sockaddr_in * target );
<iface.eventOrRequestOrData:{facet|< if( facet.type )>< else>
util_error <prefix>_<ifaceName; format="cname">_<facet.name; format="cname">( <prefix>_<ifaceName; format="cname"> * This<
if( facet.arguments )><
    signature( typesPrefix, facet.arguments.field )><
else><
    signature( typesPrefix, facet.field )><
endif> );
< endif>}>

>>



requiredImplementation( typesPrefix, prefix, usedTypes, ifaceName, rawSize, iface, ifaceID ) ::= <<
//requiredImplementation
#include \<<prefix>/<iface.name; format="cname">.h>
#include \<stdio.h>
#include \<util/log.h>

enum <prefix>_event_id {
< first(iface.eventOrRequestOrData):{facet|
   <prefix; format="upper">_<facet.name; format="ID"> = 1,}>
< rest(iface.eventOrRequestOrData) :{facet|
   <prefix; format="upper">_<facet.name; format="ID">,
}>};

static const byte <iface.name; format="ID">_ID = <ifaceID>;

util_error <prefix>_<iface.name; format="cname">_init( <prefix>_<iface.name; format="cname"
> * This, SOCKET socket, const struct sockaddr_in * target ) {
   UTIL_LOG_HERE();
   This->socket = socket;
   This->target = *target;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap( &This->out, <rawSize>, This->raw ));
   return UTIL_NO_ERROR;
}
<iface.eventOrRequestOrData:{facet|< if( facet.type )>< else>

util_error <prefix>_<iface.name; format="cname">_<facet.name; format="cname">( <prefix>_<iface.name; format="cname"
   > * This<
if( facet.arguments )><
    signature( typesPrefix, facet.arguments.field )><
else><
    signature( typesPrefix, facet.field )><
endif> ) {
   UTIL_LOG_HERE();
   UTIL_ERROR_CHECK( io_byte_buffer_clear   ( &This->out ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <iface.name; format="ID">_ID ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <prefix; format="ID">_<facet.name; format="ID"> ));
   < if( facet.arguments )><
        byteBufferPut( "", facet.arguments.field )><
     elseif( facet.type )><
        byteBufferPut( "&This->", facet )><
     elseif( facet.field )><
        byteBufferPut( "", facet.field )><
     endif>
   UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->out ));
   UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &This->out, &This->target ));
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
\}
< endif>
}>

>>



dispatcherInterface( prefix, component, rawSize, hasResponse, respRawSize ) ::= <<
#pragma once
//dispatcherInterface
#include \<io/byte_buffer.h>
#include \<io/datagram_socket.h>

struct <prefix>_<component.name; format="cname">_s;
typedef struct <prefix>_<component.name; format="cname">_s <prefix>_<component.name; format="cname">;

typedef struct <prefix>_<component.name; format="cname">_dispatcher_s {
   SOCKET         socket;
   byte           in_raw [<rawSize>];
   io_byte_buffer in;
< if( hasResponse )>
   byte           out_raw[<respRawSize>];
   io_byte_buffer out;
< endif>
   <prefix>_<component.name; format="cname"> * listener;
} <prefix>_<component.name; format="cname">_dispatcher;

util_error <prefix>_<component.name; format="cname">_dispatcher_init(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   SOCKET socket,
   <prefix>_<component.name; format="cname"> * listener );

util_error <prefix>_<component.name; format="cname">_dispatcher_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   bool * has_dispatched );
< if( component.timeout )>

typedef enum <prefix>_<component.name; format="cname">_dispatcher_loopback_event_e {
   <component.timeout:{to|<prefix; format="ID">_<component.name; format="ID">_LOOPBACK_<to.name; format="ID"> = <i>,
}>
} <prefix>_<component.name; format="cname">_dispatcher_loopback_event;

typedef struct <prefix>_<component.name; format="cname">_dispatcher_timeout_arg_s {
   <prefix>_<component.name; format="cname">_dispatcher *              dispatcher;
   <prefix>_<component.name; format="cname">_dispatcher_loopback_event event;
} <prefix>_<component.name; format="cname">_dispatcher_timeout_arg;

util_error <prefix>_<component.name; format="cname">_dispatcher_loopback(
   <prefix>_<component.name; format="cname">_dispatcher_timeout_arg * arg );
< endif>

>>



byteBufferGet( fields ) ::= <<
<fields:{field|
<     if( field.isBoolean )>bool <field.name; format="cname">;
< elseif( field.isByte    )>byte <field.name; format="cname">;
< elseif( field.isShort   )>short <field.name; format="cname">;
< elseif( field.isUshort  )>ushort <field.name; format="cname">;
< elseif( field.isInt     )>int <field.name; format="cname">;
< elseif( field.isUint    )>uint <field.name; format="cname">;
< elseif( field.isLong    )>long <field.name; format="cname">;
< elseif( field.isUlong   )>ulong <field.name; format="cname">;
< elseif( field.isFloat   )>float <field.name; format="cname">;
< elseif( field.isDouble  )>double <field.name; format="cname">;
< elseif( field.isString  )>char <field.name; format="cname">[ <field.length> + 1 ];
< elseif( field.isEnum    )><typesPrefix>_<field.userType.name; format="cname"> <field.name; format="cname">;
< elseif( field.isStruct  )><typesPrefix>_<field.userType.name; format="cname"> <field.name; format="cname">;
< endif>
<     if( field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_get_bool  ( &This->in, &<field.name; format="cname"> ));
< elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( &This->in, &<field.name; format="cname"> ));
< elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_get_short ( &This->in, &<field.name; format="cname"> ));
< elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_get_ushort( &This->in, &<field.name; format="cname"> ));
< elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_get_int   ( &This->in, &<field.name; format="cname"> ));
< elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_get_uint  ( &This->in, &<field.name; format="cname"> ));
< elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_get_long  ( &This->in, &<field.name; format="cname"> ));
< elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_get_ulong ( &This->in, &<field.name; format="cname"> ));
< elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_get_float ( &This->in, &<field.name; format="cname"> ));
< elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_get_double( &This->in, &<field.name; format="cname"> ));
< elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_get_string( &This->in, <field.name; format="cname">, sizeof( <field.name; format="cname"> )));
< elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( &This->in, &<field.name; format="cname"> ));
< elseif( field.isStruct  )>UTIL_ERROR_CHECK( <typesPrefix>_<field.userType.name; format="cname">_get( &<field.name; format="cname">, &This->in ));
< endif>
}>
>>



dispatcherImplOneInterface( typesPrefix, prefix, component, ifaceName ) ::= <<
// dispatcherImplOneInterface -- begin
typedef enum <prefix>_<ifaceName; format="cname">_event_e {
<events.(ifaceName):{facet|
   <ifaceName; format="ID">_<facet.name; format="ID"> = <i>,
}>\}
<prefix>_<ifaceName; format="cname">_event;

<events.(ifaceName):{facet|< if( facet.response )>
static const byte EVENT_<ifaceName; format="ID">_RESPONSES_<facet.name; format="ID"> = <eventIDs.(ifaceName).(facet.name)>;
< endif>}>
static util_error <prefix>_<ifaceName; format="cname">_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   < if( offRequests.(ifaceName))>struct sockaddr_in * from,< endif>
   <prefix>_<ifaceName; format="cname">_event event,
   bool * has_dispatched )
{
   *has_dispatched = false;
   switch( event ) {
<events.(ifaceName):{facet|< if( facet.type )>< else>
   case <ifaceName; format="ID">_<facet.name; format="ID">:{
      < if( facet.arguments )><facet.arguments.field:{field|<
         byteBufferGet( field )>}>< 
      elseif( facet.field )><facet.field:{field|<
         byteBufferGet( field )>}><
      endif><
      if( facet.response )
>      <typesPrefix>_<ifaceName; format="cname">_<facet.name; format="cname">_response response;
      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<
         facet.name; format="cname">( This->listener<args( facet.arguments.field )>, &response ));
      UTIL_ERROR_CHECK( io_byte_buffer_clear   ( &This->out ));
      UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <ifaceName; format="ID">_RESPONSES ));
      UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, EVENT_<ifaceName; format="ID">_RESPONSES_<facet.name; format="ID"> ));
      UTIL_ERROR_CHECK( <typesPrefix>_<ifaceName; format="cname">_<facet.name; format="cname">_response_put( &response, &This->out ));
      UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->out ));
      UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &This->out, from ));
      UTIL_LOG_ARGS( "response sent to %s", inet_ntoa( from->sin_addr ));
      < else
>      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<
          facet.name; format="cname">( This->listener<args( facet.field )> ));
      < endif>
      *has_dispatched = true;
      break;
   \}
< endif>}>   default:
      UTIL_LOG_ARGS( "Ignored message: interface = <ifaceName>, event = %d", event );
      break;
   \}
   return UTIL_NO_ERROR;
}
// dispatcherImplOneInterface -- end
>>



dispatcherImplResponse() ::= <<
// dispatcherImplResponse -- begin
typedef enum <prefix>_<ifaceName; format="cname">_response_e {
   <reqRequests.(ifaceName):{req|<req.name; format="ID"> = <i>,
}>} <prefix>_<ifaceName; format="cname">_response;

static util_error <prefix>_<ifaceName; format="cname">_responses_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   <prefix>_<ifaceName; format="cname">_response event,
   bool * has_dispatched )
{
   *has_dispatched = false;
   switch( event ) {
<reqRequests.(ifaceName):{req|
   case <req.name; format="ID">:{
      <req.response.field:{field|<byteBufferGet( field )>}
>      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<
          ifaceName; format="cname">_response_<
          req.name; format="cname">( This->listener<args( req.response.field )> ));
      *has_dispatched = true;\}
      break;
}>   default:
      UTIL_LOG_ARGS( "Unexpected event: %d", event );
      break;
   }
   return UTIL_NO_ERROR;
}
// dispatcherImplResponse -- end
>>



dispatcherImplData() ::= <<
// dispatcherImplData -- begin
typedef enum <prefix>_<iface.name; format="cname">_data_e {
   <data.(iface):{dataType|<dataType.name; format="ID"> = <eventIDs.(iface.name).(dataType.name)>,
}>} <prefix>_<iface.name; format="cname">_data;

static util_error <prefix>_<iface.name; format="cname">_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   <prefix>_<iface.name; format="cname">_data event,
   bool * has_dispatched )
{
   *has_dispatched = false;
   switch( event ) {
<data.(iface):{dataType|
   case <dataType.name; format="ID">:{
      <typesPrefix>_<dataType.name; format="cname">_get( &This->listener-><dataType.name; format="cname">, &This->in );
      <prefix>_<component.name; format="cname">_<dataType.name; format="cname">_published( This->listener );
      *has_dispatched = true;\}
      break;
}>   default:
      UTIL_LOG_ARGS( "Unexpected event: %d", event );
      break;
   }
   return UTIL_NO_ERROR;
}
// dispatcherImplData -- end
>>



dispatcherImplementation(
   typesPrefix, prefix, component, ifaces, ifacesIDs, requires, events, eventIDs,
   usedTypes, hasResponse, offRequests, reqRequests, data
) ::= <<
//dispatcherImplementation
#include \<<prefix>/<component.name; format="cname">.h>
#include \<<prefix>/<component.name; format="cname">_dispatcher.h>

#include \<stdio.h>
#include \<util/log.h>

typedef enum <prefix>_<component.name; format="cname">_dispatcher_interface_e {
< if( component.timeout )>
   LOOPBACK = 0,
< endif>
<ifaces.keys:{ifaceName|
   <ifaceName; format="ID,width"> = <ifaces.(ifaceName)>,
< if( offRequests.(ifaceName))>
   <ifaceName; format="ID">_RESPONSES = <ifacesIDs.( concat( ifaceName, "Responses" ))>,
< endif>
}><reqRequests:{ifaceName|
   <ifaceName; format="ID">_RESPONSES = <ifacesIDs.( concat( ifaceName, "Responses" ))>,
}><data:{iface|
   <iface.name; format="ID,width"> = <requires.(iface.name)>,
}>} <prefix>_<component.name; format="cname">_dispatcher_interface;

<ifaces.keys:{ifaceName|
<dispatcherImplOneInterface( typesPrefix, prefix, component, ifaceName )>
}>
<data:{iface|
<dispatcherImplData()>
}>
<reqRequests:{ifaceName|
<dispatcherImplResponse()>
}>
util_error <prefix>_<component.name; format="cname">_dispatcher_init(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   SOCKET socket,
   <prefix>_<component.name; format="cname"> * listener )
{
   UTIL_LOG_HERE();
   UTIL_CHECK_NON_NULL( listener );
   UTIL_ASSERT( socket > 0 );
   This->socket   = socket;
   This->listener = listener;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap( &This->in , sizeof( This->in_raw ), This->in_raw ));
< if( hasResponse )>
   UTIL_ERROR_CHECK( io_byte_buffer_wrap( &This->out, sizeof( This->out_raw ), This->out_raw ));
< endif>
   return UTIL_NO_ERROR;
}

< if( component.timeout )>

static util_error loopback_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   <prefix>_<component.name; format="cname">_dispatcher_loopback_event event,
   bool * has_dispatched )
{
   UTIL_LOG_HERE();
   switch( event ) {
<component.timeout:{to|
   case <prefix; format="ID">_<component.name; format="ID">_LOOPBACK_<to.name; format="ID">:
      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<to.name; format="cname">_elapsed( This->listener ));
      *has_dispatched = true;
      break;
}>   default:
      UTIL_LOG_ARGS( "unknown event = %d\n", event );
      return UTIL_NOT_APPLICABLE;
   }
   return UTIL_NO_ERROR;
}
< endif>

util_error <prefix>_<component.name; format="cname">_dispatcher_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   bool * has_dispatched )
{
   UTIL_LOG_HERE();
   struct sockaddr_in from;
   byte interface, event;

   *has_dispatched = false;
   UTIL_ERROR_CHECK( io_byte_buffer_clear( &This->in ));
   UTIL_ERROR_CHECK( io_datagram_socket_receive( This->socket, &This->in, &from ));
   UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->in ));
   UTIL_ERROR_CHECK( io_byte_buffer_get_byte( &This->in, &interface ));
   UTIL_ERROR_CHECK( io_byte_buffer_get_byte( &This->in, &event ));
   UTIL_LOG_ARGS( "interface = %d, event = %d", interface, event );
   switch( interface ) {
< if( component.timeout )>
   case LOOPBACK: UTIL_ERROR_CHECK( loopback_dispatch( This, event, has_dispatched )); break;
< endif>
<ifaces.keys:{ifaceName|
   case <ifaceName; format="ID">: < if( offRequests.(ifaceName))
   >UTIL_ERROR_CHECK( <prefix>_<ifaceName; format="cname">_dispatch( This, &from, event, has_dispatched )); break;< else
   >UTIL_ERROR_CHECK( <prefix>_<ifaceName; format="cname">_dispatch( This, event, has_dispatched )); break;
< endif>
}><reqRequests:{ifaceName|
   case <ifaceName; format="ID">_RESPONSES: UTIL_ERROR_CHECK( <prefix>_<ifaceName; format="cname">_responses_dispatch( This, event, has_dispatched )); break;
}><data:{iface|
   case <iface.name; format="ID">: UTIL_ERROR_CHECK( <prefix>_<iface.name; format="cname">_dispatch( This, event, has_dispatched )); break;
}>   default:
      UTIL_LOG_ARGS( "unknown interface %d\n", interface );
      return UTIL_NOT_APPLICABLE;
   }
   UTIL_LOG_ARGS( "has_dispatched = %s", has_dispatched ? "true" : "false" );
   return UTIL_NO_ERROR;
}
< if( component.timeout )>

util_error <prefix>_<component.name; format="cname">_dispatcher_loopback( <
   prefix>_<component.name; format="cname">_dispatcher_timeout_arg * arg ) {
   UTIL_LOG_HERE();
   UTIL_CHECK_NON_NULL( arg );
   <prefix>_<component.name; format="cname">_dispatcher *              This  = arg->dispatcher;
   <prefix>_<component.name; format="cname">_dispatcher_loopback_event event = arg->event;
   byte raw[2];
   io_byte_buffer out;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap    ( &out, sizeof( raw ), raw ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &out, (byte)LOOPBACK ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &out, (byte)event ));
   UTIL_ERROR_CHECK( io_byte_buffer_flip    ( &out ));
   UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &out, &This->listener->localAddress ));
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
}
< endif>

>>



componentInterface(
    typesPrefix, prefix, component, responses, requires, instancesByName,
    instances, usedTypes, eventsOrRequests, reqRequests, actions, data, reqData
) ::= <<
#pragma once
//componentInterface
<component.requires:{required|#include \<<prefix>/<required.interface.name; format="cname">.h>
}>
<responses.(component.name):{r|#include \<<prefix>/<r.interface.name; format="cname">.h>
}>
<reqData:{iface|<reqData.(iface):{data|
#include \<<typesPrefix>/<data.name; format="cname">.h>
}>}>< if( component.automaton )
>#include \<util/automaton.h>
< endif>
< if( component.timeout )
>#include \<util/timeout.h>
< endif>
<data:{iface|
#include \<<prefix>/<iface.name; format="cname">_data.h>
}><usedTypes:{used|
#include \<<typesPrefix>/<used; format="cname">.h>
}>
#include \<<prefix>/<component.name; format="cname">_dispatcher.h>

typedef struct <prefix>_<component.name; format="cname">_s {
   SOCKET             socket;
   struct sockaddr_in localAddress;
   bool               running;
<reqData:{iface|<reqData.(iface):{data|
   <typesPrefix>_<data.name; format="cname"> <data.name; format="cname">;
}>}>< if( component.automaton )>   util_automaton     automaton;
< endif><component.timeout:{to|
   util_timeout       <to.name; format="cname">;
}>   <prefix>_<component.name; format="cname">_dispatcher dispatcher;
<data:{iface|
   <prefix>_<iface.name; format="cname">_data <iface.name; format="cname">;
}>< first(requires):{req|<requires.(req):{rt|
   <prefix>_<rt.interface.name; format="cname"> <rt.interface.name; format="cname">;
}>}>   void * user_context;
} <prefix>_<component.name; format="cname">;

util_error <prefix>_<component.name; format="cname">_init( <
   prefix>_<component.name; format="cname"> * This, const char * name, void * user_context );
util_error <prefix>_<component.name; format="cname">_run( <prefix>_<component.name; format="cname"> * This );
<reqData:{iface|<reqData.(iface):{data|
util_error <prefix>_<component.name; format="cname">_<data.name; format="cname">_published( <
   prefix>_<component.name; format="cname"> * This );
}>}><eventsOrRequests:{ifaceName|<eventsOrRequests.(ifaceName):{facet|
util_error <prefix>_<component.name; format="cname">_<facet.name; format="cname">( <
   prefix>_<component.name; format="cname"> * This<
if( facet.arguments )><
   signature( typesPrefix, facet.arguments.field )>, <
      typesPrefix>_<ifaceName; format="cname">_<facet.name; format="cname">_response * response<
else><
   signature( typesPrefix, facet.field )><
endif> );
}>}><reqRequests:{ifaceName|<reqRequests.(ifaceName):{req|
util_error <prefix>_<component.name; format="cname">_<
    ifaceName; format="cname">_response_<
    req.name; format="cname">( <
   prefix>_<component.name; format="cname"> * This<signature( typesPrefix, req.response.field )> );
}>}>< if( component.afterDispatchNeeded )>util_error <prefix>_<component.name; format="cname">_after_dispatch( <
   prefix>_<component.name; format="cname"> * This );
< endif><actions:{action|
util_error <prefix>_<component.name; format="cname">_<action; format="cname">( <
   prefix>_<component.name; format="cname"> * This );
}><component.timeout:{to|
util_error <prefix>_<component.name; format="cname">_<to.name; format="cname">_elapsed( <
   prefix>_<component.name; format="cname"> * This );
}>

>>



componentImplementation(
   typesPrefix, prefix, component, requires, dataWriter, instancesByName,
   instances, processes, data
) ::= <<
// componentImplementation
#include \<<prefix>/<component.name; format="cname">.h>
< if( component.automaton )>#include \<<prefix>/automaton.h>
#include \<<typesPrefix>/<component.automaton.eventEnum.name; format="cname">.h>
< endif>
#include \<stdio.h>
#include \<stdlib.h>
#include \<string.h>
#include \<util/log.h>

util_error <prefix>_<component.name; format="cname">_init( <
   prefix>_<component.name; format="cname"> * This, const char * name, void * user_context ) {
   UTIL_LOG_HERE();
   memset( This, 0, sizeof( <prefix>_<component.name; format="cname"> ));
   This->socket = socket( AF_INET, SOCK_DGRAM, 0 );
   if( This->socket == INVALID_SOCKET ) {
      return UTIL_OS_ERROR;
   }
   This->running      = false;
   This->user_context = user_context;
< if( component.automaton )>   <prefix>_automaton_init( &This->automaton, This );< endif>
< if( requires )>
   struct sockaddr_in < first(requires):{req|<
      first( requires.(req) ):{rt|<rt.interface.name; format="cname">}><
      rest ( requires.(req) ):{rt|, <rt.interface.name; format="cname">}>}><
      data:{iface|, <iface.name; format="cname">}>;
< endif>
< first(instances):{instance|
   if( 0 ==  strcmp( name, "<instance.name>" )) {
      UTIL_ERROR_CHECK( io_datagram_socket_bind( This->socket, "<
         processes.(instance).address>", <
         processes.(instance).port>, &This->localAddress ));
      <requires.(instance.name):{req|UTIL_ERROR_CHECK( io_datagram_socket_init( "<
         processes.(instancesByName.(req.toInstance.name)).address>", <
         processes.(instancesByName.(req.toInstance.name)).port>, &<
         req.interface.name; format="cname"> ));
}>      <data:{iface|UTIL_ERROR_CHECK( io_datagram_socket_init( "<
            processes.(dataWriter.([instance.name, "/", iface.name])).address>", <
            processes.(dataWriter.([instance.name, "/", iface.name])).port>, &<
            iface.name; format="cname"> ));
}>}>< rest(instances):{instance|\}
   else if( 0 ==  strcmp( name, "<instance.name>" )) {
      UTIL_ERROR_CHECK( io_datagram_socket_bind( This->socket, "<
         processes.(instance).address>", <
         processes.(instance).port>, &This->localAddress ));
      <requires.(instance.name):{req|UTIL_ERROR_CHECK( io_datagram_socket_init( "<
         processes.(instancesByName.(req.toInstance.name)).address>", <
         processes.(instancesByName.(req.toInstance.name)).port>, &<
         req.interface.name; format="cname"> ));
}>      <data:{iface|UTIL_ERROR_CHECK( io_datagram_socket_init( "<
            processes.(dataWriter.([instance.name, "/", iface.name])).address>", <
            processes.(dataWriter.([instance.name, "/", iface.name])).port>, &<
            iface.name; format="cname"> ));
}>}>}
   else {
      UTIL_LOG_ARGS( "unknown deployment name '%s'!", name );
      return UTIL_NOT_APPLICABLE;
   }
   < first(requires):{req|<requires.(req):{rt|UTIL_ERROR_CHECK( <
      prefix>_<rt.interface.name; format="cname">_init( &This-><rt.interface.name; format="cname">, This->socket, &<rt.interface.name; format="cname"> ));
}>}>   <data:{iface|UTIL_ERROR_CHECK( <
      prefix>_<iface.name; format="cname">_data_init( &This-><iface.name; format="cname">, This->socket, &<iface.name; format="cname"> ));
}>UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_dispatcher_init( &This->dispatcher, This->socket, This ));
<component.timeout:{to|
   static <prefix>_<component.name; format="cname">_dispatcher_timeout_arg timeout_arg_<to.name; format="cname">;
   timeout_arg_<to.name; format="cname">.dispatcher = &This->dispatcher;
   timeout_arg_<to.name; format="cname">.event      = <
      prefix; format="ID">_<component.name; format="ID">_LOOPBACK_<to.name; format="ID">;
   UTIL_ERROR_CHECK( util_timeout_init(
      &This-><to.name; format="cname">,
      <to.duration><to.unit.toCpp>,
      (util_timeout_action)<prefix>_<component.name; format="cname">_dispatcher_loopback,
      &timeout_arg_<to.name; format="cname"> ));
}>
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
}

util_error <prefix>_<component.name; format="cname">_run( <prefix>_<component.name; format="cname"> * This ) {
   UTIL_LOG_HERE();
   This->running = true;
   while( This->running ) {
      bool has_dispatched;
      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_dispatcher_dispatch( &This->dispatcher, &has_dispatched ));
      < if( component.afterDispatchNeeded )>if( has_dispatched ) {
         UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_after_dispatch( This ));
      }
< endif>
   }
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
}

>>



dataWriterHeader( typesPrefix, prefix, interface, ifaceID, data, rawSize  ) ::= <<
#pragma once

// dataWriter

#include \<io/datagram_socket.h>

<data:{dataType|
#include \<<typesPrefix>/<dataType.name; format="cname">.h>
}>
typedef struct <prefix>_<interface.name; format="cname">_data_s {
   SOCKET             socket;
   struct sockaddr_in target;
   byte               raw[<rawSize>];
   io_byte_buffer     out;

<data:{dataType|
   <typesPrefix>_<dataType.name; format="cname"> <dataType.name; format="cname">;
}>
} <prefix>_<interface.name; format="cname">_data;

util_error <prefix>_<interface.name; format="cname">_data_init( <prefix>_<
   interface.name; format="cname">_data * This, SOCKET socket, const struct sockaddr_in * target );
<data:{dataType|
util_error <prefix>_<interface.name; format="cname">_data_publish_<dataType.name; format="cname">( <
   prefix>_<interface.name; format="cname">_data * This );
}>

>>



dataWriterBody( typesPrefix, prefix, interface, ifaceID, data, dataID, rawSize  ) ::= <<
#include \<<prefix>/<interface.name; format="cname">_data.h>

#include \<util/log.h>

#include \<stdio.h>

static const byte <interface.name; format="ID"> = <ifaceID>;

<data:{dataType|static const byte <dataType.name; format="ID"> = <dataID.(dataType.name)>;
}>

util_error <prefix>_<interface.name; format="cname">_data_init( <
   prefix>_<interface.name; format="cname">_data * This, SOCKET socket, const struct sockaddr_in * target ) {
   This->socket = socket;
   This->target = *target;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap( &This->out, <rawSize>, This->raw ));
   return UTIL_NO_ERROR;
}
<data:{dataType|


util_error <prefix>_<interface.name; format="cname">_data_publish_<dataType.name; format="cname">( <
   prefix>_<interface.name; format="cname">_data * This ) {
   UTIL_ERROR_CHECK( io_byte_buffer_clear( &This->out ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <interface.name; format="ID"> ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <dataType.name; format="ID"> ));
   UTIL_ERROR_CHECK( <typesPrefix>_<dataType.name; format="cname">_put( &This->etat_du_dab, &This->out ));
   UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->out ));
   size_t size = 0;
   UTIL_ERROR_CHECK( io_byte_buffer_remaining( &This->out, &size ));
   UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &This->out, &This->target ));
   UTIL_LOG_ARGS( "%u byte(s) sent to %s", (unsigned)size, inet_ntoa( This->target.sin_addr ));
   return UTIL_NO_ERROR;
\}
}>

>>



automatonHeader( prefix, component ) ::= <<
#pragma once

#include \<<prefix>/<component.name; format="cname">.h>
#include \<util/automaton.h>

void <prefix>_automaton_init( util_automaton * automaton, <prefix>_<component.name; format="cname"> * actor );

>>



automatonBody( typesPrefix, prefix, component ) ::= <<
#include \<<prefix>/automaton.h>
#include \<<typesPrefix>/<component.automaton.stateEnum.name; format="cname">.h>
#include \<<typesPrefix>/<component.automaton.eventEnum.name; format="cname">.h>

static util_transition transitions[] = {
   <component.automaton.transition:{transition|{ <
      typesPrefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<transition.from ; format="ID">, <
      typesPrefix; format="ID">_<component.automaton.eventEnum.name; format="ID">_<transition.event; format="ID">, <
      typesPrefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<transition.futur; format="ID"> \},
}>};

static util_shortcut shortcuts[] = {
   <component.automaton.shortcut:{shortcut|{ <
      typesPrefix; format="ID">_<component.automaton.eventEnum.name; format="ID">_<shortcut.event; format="ID">, <
      typesPrefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<shortcut.futur; format="ID"> \},
}>};

static util_automaton_state_action on_entry[] = {
   <component.automaton.onEntryOrOnExit:{eoe|< if( eoe.isOnEntry )>{ <
      typesPrefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<
      eoe.value.state; format="ID">, (util_automaton_action)&<
      prefix>_<component.name; format="cname">_<eoe.value.action; format="cname"> \},
< endif>}>};

static util_automaton_state_action on_exit[] = {
   <component.automaton.onEntryOrOnExit:{eoe|< if( eoe.isOnExit )>{ <
      typesPrefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<
      eoe.value.state; format="ID">, (util_automaton_action)&<
      prefix>_<component.name; format="cname">_<eoe.value.action; format="cname"> \},
< endif>}>};

void <prefix>_automaton_init( util_automaton * automaton, <prefix>_<component.name; format="cname"> * actor ) {
   automaton->debug           = false;
   automaton->current         = <typesPrefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<component.automaton.initial; format="ID">;
   automaton->arcs            = transitions;
   automaton->arcs_count      = sizeof( transitions )/sizeof( transitions[0] );
   automaton->shortcuts       = shortcuts;
   automaton->shortcuts_count = sizeof( shortcuts   )/sizeof( shortcuts  [0] );
   automaton->actor           = actor;
   automaton->on_entry        = on_entry;
   automaton->on_entry_count  = sizeof( on_entry    )/sizeof( on_entry   [0] );
   automaton->on_exit         = on_exit;
   automaton->on_exit_count   = sizeof( on_exit     )/sizeof( on_exit    [0] );
}

>>
