group C;



type( field ) ::= <<
< if(     field.isBoolean )>bool  <
  elseif( field.isByte    )>byte  <
  elseif( field.isShort   )>short <
  elseif( field.isUshort  )>ushort<
  elseif( field.isInt     )>int   <
  elseif( field.isUint    )>uint  <
  elseif( field.isLong    )>long  <
  elseif( field.isUlong   )>ulong <
  elseif( field.isFloat   )>float <
  elseif( field.isDouble  )>double<
  elseif( field.isString  )>char  <
  elseif( field.isEnum    )><field.userType.name; format="cname"><
  elseif( field.isStruct  )><field.userType.name; format="cname"><
  endif>
>>



signature( prefix, fields ) ::= <<
<fields:{field|
, < if( field.isBoolean )>bool<
elseif( field.isString  )>const char *<
elseif( field.isEnum    )><prefix>_<field.userType.name; format="cname"><
elseif( field.isStruct  )>const <prefix>_<field.userType.name; format="cname"> *<
else                     ><type(field)><
endif                    > <field.name; format="cname">}>
>>



args( fields ) ::= <<
<fields:{field|, <
   if( field.isStruct  )>&<
   endif                ><field.name; format="cname">}>
>>



byteBufferPut( fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_put_bool( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_put_short( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_put_ushort( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_put_int( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_put_uint( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_put_long( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_put_ulong( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_put_float( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_put_double( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_put_string( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <field.name; format="cname"> ), __FILE__, __LINE__ );
< elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_put( <field.name; format="cname">, &This->out ), __FILE__, __LINE__ );
< endif>
}>
>>



enumHeader( prefix, enum ) ::= <<
#pragma once

typedef enum <prefix>_<enum.name; format="cname">_e {
   <prefix; format="upper">_<enum.name; format="ID">_FIRST,

< first(enum.literal):{literal|
   <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID"> = <
    prefix; format="upper">_<enum.name; format="ID">_FIRST,}>
< rest(enum.literal) :{literal|
   <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID">,
}>
   <prefix; format="upper">_<enum.name; format="ID">_LAST

} <prefix>_<enum.name; format="cname">;

const char * <prefix>_<enum.name; format="cname">_to_string( <prefix>_<enum.name; format="cname"> value ); 
>>



enumBody( prefix, enum ) ::= <<
#include \<<prefix>/<enum.name; format="cname">.h>

const char * <prefix>_<enum.name; format="cname">_to_string( <prefix>_<enum.name; format="cname"> value ) {
   switch( value ) {
   <enum.literal:{literal|
   case <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID">: return "<literal.name; format="ID">";
}>   default: return "Etat inconnu !";
   }
}
>>



structHeader( prefix, struct ) ::= <<
#pragma once

#include \<io/byte_buffer.h>

<struct.field:{field|<
if( field.isStruct )>
#include \<<prefix>/<type(field)>.h><
endif>}>

typedef struct <prefix>_<struct.name; format="cname">_s {
<struct.field:{field|<
if( field.isString )>
   char <field.name; format="cname">[ <field.length> + 1 ];<
elseif( field.isStruct )>
   <prefix>_<type(field)> <field.name; format="cname">;<
else>
   <type(field)> <field.name; format="cname">;<
endif>}>
} <prefix>_<struct.name; format="cname">;

util_error <prefix>_<struct.name; format="cname">_put( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * target );
util_error <prefix>_<struct.name; format="cname">_get( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * source );
>>



structBody( prefix, struct, maxLength, maxStrLength ) ::= <<
#include \<<prefix>/<struct.name; format="cname">.h>
#include \<stdio.h>

util_error <prefix>_<struct.name; format="cname">_put( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * target ) {
<struct.field:{field|
   < if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_put_bool  ( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte  ( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_put_short ( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_put_ushort( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_put_int   ( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_put_uint  ( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_put_long  ( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_put_ulong ( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_put_float ( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_put_double( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_put_string( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte  ( target, This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_put( &This-><field.name; format="cname">, target ), __FILE__, __LINE__ );
   < endif>
}>   return UTIL_NO_ERROR;
}

util_error <prefix>_<struct.name; format="cname">_get( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * source ) {
<struct.field:{field|
   < if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_get_bool  ( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_get_short ( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_get_ushort( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_get_int   ( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_get_uint  ( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_get_long  ( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_get_ulong ( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_get_float ( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_get_double( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_get_string( source, This-><
         field.name; format="cname,strWidth">, sizeof( This-><field.name; format="cname,strWidth"> )), __FILE__, __LINE__ );
   < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( source, &This-><field.name; format="cname,width"> ), __FILE__, __LINE__ );
   < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_get( &This-><field.name; format="cname">, source ), __FILE__, __LINE__ );
   < endif>
}>   return UTIL_NO_ERROR;
}
>>



requiredInterface( prefix, usedTypes, ifaceName, rawSize, iface ) ::= <<
#pragma once
//requiredInterface
#include \<io/datagram_socket.h>

<usedTypes:{type|#include \<<prefix>/<type; format="cname">.h>
}>
<iface.eventOrRequest:{eor|<if( eor.arguments )>
#include \<<prefix>/<ifaceName; format="cname">_<eor.name; format="cname">_response.h>
<endif>
}>
typedef struct <prefix>_<ifaceName; format="cname">_s {
   SOCKET             socket;
   struct sockaddr_in target;
   byte               raw[<rawSize>];
   io_byte_buffer     out;
} <prefix>_<ifaceName; format="cname">;

util_error <prefix>_<ifaceName; format="cname">_init( <prefix>_<ifaceName; format="cname"
> * This, SOCKET socket, struct sockaddr_in * target );
<iface.eventOrRequest:{eor|
util_error <prefix>_<ifaceName; format="cname">_<eor.name; format="cname">( <prefix>_<ifaceName; format="cname"
    > * This<
if( eor.arguments )><
    signature( prefix, eor.arguments.field )><
else><
    signature( prefix, eor.field )><
endif> );
}>
>>



requiredImplementation( prefix, usedTypes, ifaceName, rawSize, iface, ifaceID ) ::= <<
//requiredImplementation
#include \<<prefix>/<iface.name; format="cname">.h>
#include \<stdio.h>

enum <prefix>_event_id {
< first(iface.eventOrRequest):{eor|
   <prefix; format="upper">_<eor.name; format="ID"> = 1,}>
< rest(iface.eventOrRequest) :{eor|
   <prefix; format="upper">_<eor.name; format="ID">,
}>};

static const byte <iface.name; format="ID">_ID = <ifaceID>;

util_error <prefix>_<iface.name; format="cname">_init( <prefix>_<iface.name; format="cname"
> * This, SOCKET socket, struct sockaddr_in * target ) {
   This->socket = socket;
   This->target = *target;
   return io_byte_buffer_wrap( &This->out, <rawSize>, This->raw );
}
<iface.eventOrRequest:{eor|


util_error <prefix>_<iface.name; format="cname">_<eor.name; format="cname">( <prefix>_<iface.name; format="cname"
   > * This<
if( eor.arguments )><
    signature( prefix, eor.arguments.field )><
else><
    signature( prefix, eor.field )><
endif> ) {
   UTIL_ERROR_CHECK( io_byte_buffer_clear   ( &This->out ), __FILE__, __LINE__ );
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <iface.name; format="ID">_ID ), __FILE__, __LINE__ );
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <prefix; format="ID">_<eor.name; format="ID"> ), __FILE__, __LINE__ );
   < if( eor.arguments )><
        byteBufferPut( eor.arguments.field )><
     else><
        byteBufferPut( eor.field )><
     endif>
   UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->out ), __FILE__, __LINE__ );
   UTIL_ERROR_CHECK( io_datagram_socket_sendTo( This->socket, &This->out, &This->target ), __FILE__, __LINE__ );
   return UTIL_NO_ERROR;
\}
}>
>>



dispatcherInterface( prefix, name, rawSize ) ::= <<
#pragma once
//dispatcherInterface
#include \<io/byte_buffer.h>
#include \<io/datagram_socket.h>

struct <prefix>_<name; format="cname">_s;
typedef struct <prefix>_<name; format="cname">_s <prefix>_<name; format="cname">;

typedef struct <prefix>_<name; format="cname">_dispatcher_s {
   SOCKET         socket;
   byte           raw[<rawSize>];
   io_byte_buffer in;
   <prefix>_<name; format="cname"> * listener;
} <prefix>_<name; format="cname">_dispatcher;

util_error <prefix>_<name; format="cname">_dispatcher_init( <
   prefix>_<name; format="cname">_dispatcher * This, SOCKET socket, <
   prefix>_<name; format="cname"> * listener );
util_error <prefix>_<name; format="cname">_dispatcher_dispatch( <
   prefix>_<name; format="cname">_dispatcher * This, bool * has_dispatched );
>>



dispatcherImplOneInterface( prefix, name, ifaceName ) ::= <<
//dispatcherImplOneInterface
typedef enum <prefix>_<ifaceName; format="cname">_event_e {
<events.(ifaceName):{event|
   <ifaceName; format="ID">_<event.name; format="ID"> = <i>,
}>\} <prefix>_<ifaceName; format="cname">_event;

static util_error <prefix>_<ifaceName; format="cname">_dispatch( <
prefix>_<name; format="cname">_dispatcher * This, <prefix>_<ifaceName; format="cname">_event event, bool * has_dispatched ) {
   *has_dispatched = false;
   switch( event ) {
<events.(ifaceName):{event|
   case <ifaceName; format="ID">_<event.name; format="ID">:{
<event.field:{field|
      <     if( field.isBoolean )>bool <field.name; format="cname">;
      < elseif( field.isByte    )>byte <field.name; format="cname">;
      < elseif( field.isShort   )>short <field.name; format="cname">;
      < elseif( field.isUshort  )>ushort <field.name; format="cname">;
      < elseif( field.isInt     )>int <field.name; format="cname">;
      < elseif( field.isUint    )>uint <field.name; format="cname">;
      < elseif( field.isLong    )>long <field.name; format="cname">;
      < elseif( field.isUlong   )>ulong <field.name; format="cname">;
      < elseif( field.isFloat   )>float <field.name; format="cname">;
      < elseif( field.isDouble  )>double <field.name; format="cname">;
      < elseif( field.isString  )>char <field.name; format="cname">[ <field.length> + 1 ];
      < elseif( field.isEnum    )><prefix>_<field.userType.name; format="cname"> <field.name; format="cname">;
      < elseif( field.isStruct  )><prefix>_<field.userType.name; format="cname"> <field.name; format="cname">;
      < endif>
      <     if( field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_get_bool  ( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_get_short ( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_get_ushort( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_get_int   ( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_get_uint  ( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_get_long  ( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_get_ulong ( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_get_float ( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_get_double( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_get_string( &This->in, <field.name; format="cname">, sizeof( <field.name; format="cname"> )), __FILE__, __LINE__ );                            
      < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( &This->in, &<field.name; format="cname"> ), __FILE__, __LINE__ );
      < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_get( &<field.name; format="cname">, &This->in ), __FILE__, __LINE__ );
      < endif>
}>      UTIL_ERROR_CHECK( <prefix>_<name; format="cname">_<event.name; format="cname">( This->listener<args( event.field )> ), __FILE__, __LINE__ );
      *has_dispatched = true;
      break;
   \}
}>   default:
      fprintf( stderr, "<prefix>_<name; format="cname">_dispatcher|Message reçu ignoré\n" );
      fprintf( stderr, "\tinterface = <ifaceName>\n" );
      fprintf( stderr, "\tevent     = %d\n", event );
      break;
   \}
   return UTIL_NO_ERROR;
}

>>

dispatcherImplementation( prefix, compName, ifaces, events, usedTypes, rawSize ) ::= <<
//dispatcherImplementation
#include \<<prefix>/<compName; format="cname">_dispatcher.h>
#include \<<prefix>/<compName; format="cname">.h>

#include \<stdio.h>

typedef enum <prefix>_<compName; format="cname">_dispatcher_interface_e {
<ifaces.keys:{ifaceName|
   <ifaceName; format="ID,width"> = <ifaces.(ifaceName)>,
}>} <prefix>_<compName; format="cname">_dispatcher_interface;

<ifaces.keys:{ifaceName|
<dispatcherImplOneInterface( prefix, compName, ifaceName )>
}>util_error <prefix>_<compName; format="cname">_dispatcher_init(
   <prefix>_<compName; format="cname">_dispatcher * This,
   SOCKET socket,
   <prefix>_<compName; format="cname"> *            listener )
{
   if( socket \<= 0 || NULL == listener ) {
      return UTIL_NULL_ARG;
   }
   This->socket   = socket;
   This->listener = listener;
   return io_byte_buffer_wrap( &This->in, <rawSize>, This->raw );
}

util_error <prefix>_<compName; format="cname">_dispatcher_dispatch( <prefix>_<compName; format="cname">_dispatcher * This, bool * has_dispatched ) {
   struct sockaddr_in from;
   byte interface, event;

   *has_dispatched = false;
   UTIL_ERROR_CHECK( io_byte_buffer_clear( &This->in ), __FILE__, __LINE__ );
   UTIL_ERROR_CHECK( io_datagram_socket_receive( This->socket, &This->in, &from ), __FILE__, __LINE__ );
   UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->in ), __FILE__, __LINE__ );
   UTIL_ERROR_CHECK( io_byte_buffer_get_byte( &This->in, &interface ), __FILE__, __LINE__ );
   UTIL_ERROR_CHECK( io_byte_buffer_get_byte( &This->in, &event ), __FILE__, __LINE__ );
   switch( interface ) {
<ifaces.keys:{ifaceName|
   case <ifaceName; format="ID,width">: UTIL_ERROR_CHECK( <prefix>_<ifaceName; format="cname">_dispatch( This, event, has_dispatched ), __FILE__, __LINE__ ); break;
}>
   }
   return UTIL_NO_ERROR;
}
>>



componentInterface( prefix, component, responses, requires, instancesByName, instances, usedTypes, eventsOrRequests, actions ) ::= <<
#pragma once
//componentInterface
<component.requires:{required|#include \<<prefix>/<required.interface.name; format="cname">.h>
}>
<responses.(component.name):{r|#include \<<prefix>/<r.interface.name; format="cname">.h>
}>
< if( component.automaton )
>#include \<util/automaton.h>
<endif>
<usedTypes:{used|
#include \<<prefix>/<used; format="cname">.h>
}>
#include \<<prefix>/<component.name; format="cname">_dispatcher.h>

typedef struct <prefix>_<component.name; format="cname">_s {
   SOCKET         socket;
   bool           running;
< if( component.automaton )>   util_automaton automaton;
< endif>   <prefix>_<component.name; format="cname">_dispatcher dispatcher;
< first(requires):{req|<requires.(req):{rt|
   <prefix>_<rt.interface.name; format="cname"> <rt.interface.name; format="cname">;
}>}>   void * user_context;
} <prefix>_<component.name; format="cname">;

util_error <prefix>_<component.name; format="cname">_init     ( <prefix>_<component.name; format="cname"> * This, const char * name, void * user_context );
util_error <prefix>_<component.name; format="cname">_run      ( <prefix>_<component.name; format="cname"> * This );
util_error <prefix>_<component.name; format="cname">_terminate( <prefix>_<component.name; format="cname"> * This );
<eventsOrRequests:{eor|
util_error <prefix>_<component.name; format="cname">_<eor.name; format="cname">( <prefix>_<component.name; format="cname"> * This<
if( eor.arguments )><
    signature( prefix, eor.arguments.field )>, <ifaceName; format="cname">_<eor.name; format="cname">_response * response<
else><
    signature( prefix, eor.field )><
endif> );
}>util_error <prefix>_<component.name; format="cname">_after_dispatch( <prefix>_<component.name; format="cname"> * This );
<actions:{action|
util_error <prefix>_<component.name; format="cname">_<action; format="cname">( <prefix>_<component.name; format="cname"> * This );
}>
>>



componentImplementation( prefix, component, responses, requires, instancesByName, instances, automaton ) ::= <<
// componentImplementation
#include \<<prefix>/<component.name; format="cname">.h>
< if( component.automaton )>#include \<dab/automaton.h>
#include \<<prefix>/<component.automaton.eventEnum.name; format="cname">.h>
< endif>
#include \<stdio.h>
#include \<stdlib.h>
#include \<string.h>

util_error <prefix>_<component.name; format="cname">_init( <
   prefix>_<component.name; format="cname"> * This, const char * name, void * user_context ) {
   memset( This, 0, sizeof( <prefix>_<component.name; format="cname"> ));
   This->socket = socket( AF_INET, SOCK_DGRAM, 0 );
   if( This->socket == INVALID_SOCKET ) {
      return UTIL_OS_ERROR;
   }
   This->running      = false;
   This->user_context = user_context;
   UTIL_ERROR_CHECK( <prefix>_automaton_init( &This->automaton, This ), __FILE__, __LINE__ );
< if( requires )>
   struct sockaddr_in < first(requires):{req|<
      first( requires.(req) ):{rt|<rt.interface.name; format="cname">}><
      rest ( requires.(req) ):{rt|, <rt.interface.name; format="cname">}>}>;
< endif>
< first(instances):{instance|
   if( 0 ==  strcmp( name, "<instance.name>" )) {
      UTIL_ERROR_CHECK( io_datagram_socket_bind( This->socket, "<instance.address>", <instance.port> ), __FILE__, __LINE__ );
      <requires.(instance.name):{req|UTIL_ERROR_CHECK( io_datagram_socket_init( "<
         instancesByName.(req.toInstance.name).address>", <
         instancesByName.(req.toInstance.name).port>, &<
         req.interface.name; format="cname"> ), __FILE__, __LINE__ );
}>}>< rest(instances):{instance|
  \}
  else if( 0 ==  strcmp( name, "<instance.name>" )) {
      UTIL_ERROR_CHECK( io_datagram_socket_bind( This->socket, "<instance.address>", <instance.port> ), __FILE__, __LINE__ );
      <requires.(instance.name):{req|UTIL_ERROR_CHECK( io_datagram_socket_init( "<
         instancesByName.(req.toInstance.name).address>", <
         instancesByName.(req.toInstance.name).port>, &<
         req.interface.name; format="cname"> ), __FILE__, __LINE__ );
}>}>   }
   else {
      return UTIL_NOT_APPLICABLE;
   }
   < first(requires):{req|<requires.(req):{rt|UTIL_ERROR_CHECK( <
      prefix>_<rt.interface.name; format="cname">_init( &This-><rt.interface.name; format="cname">, This->socket, &<rt.interface.name; format="cname"> ), __FILE__, __LINE__ );
}>}>   UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_dispatcher_init( &This->dispatcher, This->socket, This ), __FILE__, __LINE__ );
   return UTIL_NO_ERROR;
}

util_error <prefix>_<component.name; format="cname">_run( <prefix>_<component.name; format="cname"> * This ) {
   This->running = true;
   while( This->running ) {
      bool has_dispatched;
      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_dispatcher_dispatch( &This->dispatcher, &has_dispatched ), __FILE__, __LINE__ );
      if( has_dispatched ) {
         UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_after_dispatch( This ), __FILE__, __LINE__ );
      }
   }
   return UTIL_NO_ERROR;
}
>>



automatonHeader( prefix, component ) ::= <<
#pragma once

#include \<util/automaton.h>
#include \<<prefix>/<component.name; format="cname">.h>

util_error <prefix>_automaton_init( util_automaton * automaton, <prefix>_<component.name; format="cname"> * actor );
>>



automatonBody( prefix, component ) ::= <<
#include \<<prefix>/automaton.h>
#include \<<prefix>/<component.automaton.stateEnum.name; format="cname">.h>
#include \<<prefix>/<component.automaton.eventEnum.name; format="cname">.h>

static util_transition transitions[] = {
   <component.automaton.transition:{transition|{ <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<transition.from ; format="ID">, <
      prefix; format="ID">_<component.automaton.eventEnum.name; format="ID">_<transition.event; format="ID">, <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<transition.futur; format="ID"> \},
}>
};

static util_shortcut shortcuts[] = {
   <component.automaton.shortcut:{shortcut|{ <
      prefix; format="ID">_<component.automaton.eventEnum.name; format="ID">_<shortcut.event; format="ID">, <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<shortcut.futur; format="ID"> \},
}>
};

static util_automaton_actions actions[] = {
   <component.automaton.onEntryOrOnExit:{eoe|{ <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<
      eoe.value.state; format="ID">, (util_automaton_action)&<
      prefix>_<component.name; format="cname">_<eoe.value.action; format="cname"> \},
}>
};

util_error <prefix>_automaton_init( util_automaton * automaton, <prefix>_<component.name; format="cname"> * actor ) {
   return util_automaton_init(
      automaton, <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<component.automaton.initial; format="ID">,
      transitions, sizeof( transitions )/sizeof( transitions[0] ),
      shortcuts  , sizeof( shortcuts   )/sizeof( shortcuts  [0] ),
      actor      ,
      actions    , sizeof( actions     )/sizeof( actions    [0] ) );
}
>>
