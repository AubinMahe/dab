group C;



type( field ) ::= <<
< if(     field.isBoolean )>bool  <
  elseif( field.isByte    )>byte  <
  elseif( field.isShort   )>short <
  elseif( field.isUshort  )>ushort<
  elseif( field.isInt     )>int   <
  elseif( field.isUint    )>uint  <
  elseif( field.isLong    )>long  <
  elseif( field.isUlong   )>ulong <
  elseif( field.isFloat   )>float <
  elseif( field.isDouble  )>double<
  elseif( field.isString  )>char  <
  elseif( field.isEnum    )><field.userType.name; format="cname"><
  elseif( field.isStruct  )><field.userType.name; format="cname"><
  endif>
>>



signature( prefix, fields ) ::= <<
<fields:{field|
, < if( field.isBoolean )>bool<
elseif( field.isString  )>const char *<
elseif( field.isEnum    )><prefix>_<field.userType.name; format="cname"><
elseif( field.isStruct  )>const <prefix>_<field.userType.name; format="cname"> *<
else                     ><type(field)><
endif                    > <field.name; format="cname">}>
>>



args( fields ) ::= <<
<fields:{field|, <
   if( field.isStruct  )>&<
   endif                ><field.name; format="cname">}>
>>



byteBufferPut( this, fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_put_bool( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_put_short( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_put_ushort( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_put_int( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_put_uint( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_put_long( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_put_ulong( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_put_float( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_put_double( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_put_string( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_put( <this><field.name; format="cname">, &This->out ));
< endif>
}>
>>



enumHeader( prefix, enum ) ::= <<
#pragma once

typedef enum <prefix>_<enum.name; format="cname">_e {
   <prefix; format="upper">_<enum.name; format="ID">_FIRST,

< first(enum.literal):{literal|
   <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID"> = <
    prefix; format="upper">_<enum.name; format="ID">_FIRST,}>
< rest(enum.literal) :{literal|
   <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID">,
}>
   <prefix; format="upper">_<enum.name; format="ID">_LAST

} <prefix>_<enum.name; format="cname">;

const char * <prefix>_<enum.name; format="cname">_to_string( <prefix>_<enum.name; format="cname"> value ); 
>>



enumBody( prefix, enum ) ::= <<
#include \<<prefix>/<enum.name; format="cname">.h>

const char * <prefix>_<enum.name; format="cname">_to_string( <prefix>_<enum.name; format="cname"> value ) {
   switch( value ) {
   <enum.literal:{literal|
   case <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID,width">: return "<literal.name; format="ID">";
}>   default: return "Etat inconnu !";
   }
}
>>



structHeader( prefix, struct ) ::= <<
#pragma once

#include \<io/byte_buffer.h>

<struct.field:{field|<
if( field.isStruct || field.isEnum )>
#include \<<prefix>/<type(field)>.h><
endif>}>

typedef struct <prefix>_<struct.name; format="cname">_s {
<struct.field:{field|<
if( field.isString )>
   char <field.name; format="cname">[ <field.length> + 1 ];<
elseif( field.isStruct || field.isEnum )>
   <prefix>_<type(field)> <field.name; format="cname">;<
else>
   <type(field)> <field.name; format="cname">;<
endif>}>
} <prefix>_<struct.name; format="cname">;

util_error <prefix>_<struct.name; format="cname">_put( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * target );
util_error <prefix>_<struct.name; format="cname">_get( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * source );
>>



structBody( prefix, struct, maxLength, maxStrLength ) ::= <<
#include \<<prefix>/<struct.name; format="cname">.h>
#include \<stdio.h>

util_error <prefix>_<struct.name; format="cname">_put( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * target ) {
<struct.field:{field|
   < if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_put_bool  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_put_short ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_put_ushort( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_put_int   ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_put_uint  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_put_long  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_put_ulong ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_put_float ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_put_double( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_put_string( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_put( &This-><field.name; format="cname">, target ));
   < endif>
}>   return UTIL_NO_ERROR;
}

util_error <prefix>_<struct.name; format="cname">_get( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * source ) {
<struct.field:{field|
   < if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_get_bool  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_get_short ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_get_ushort( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_get_int   ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_get_uint  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_get_long  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_get_ulong ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_get_float ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_get_double( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_get_string( source, This-><
         field.name; format="cname,strWidth">, sizeof( This-><field.name; format="cname,strWidth"> )));
   < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( source, (byte *)&This-><field.name; format="cname,width"> ));
   < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_get( &This-><field.name; format="cname">, source ));
   < endif>
}>   return UTIL_NO_ERROR;
}
>>



requiredInterface( prefix, usedTypes, ifaceName, rawSize, iface ) ::= <<
#pragma once
//requiredInterface
#include \<io/datagram_socket.h>

<usedTypes:{type|#include \<<prefix>/<type; format="cname">.h>
}>
<iface.eventOrRequestOrData:{facet|<
if( facet.arguments )>
#include \<<prefix>/<ifaceName; format="cname">_<facet.name; format="cname">_response.h>
< endif>
}>
typedef struct <prefix>_<ifaceName; format="cname">_s {
   SOCKET             socket;
   struct sockaddr_in target;
   byte               raw[<rawSize>];
   io_byte_buffer     out;<
iface.eventOrRequestOrData:{facet|<
if( facet.type )>

   <prefix>_<type(facet)> <facet.name; format="cname">;<
endif>}>
} <prefix>_<ifaceName; format="cname">;

util_error <prefix>_<ifaceName; format="cname">_init( <prefix>_<ifaceName; format="cname"
> * This, SOCKET socket, struct sockaddr_in * target );
<iface.eventOrRequestOrData:{facet|
util_error <prefix>_<ifaceName; format="cname">_<facet.name; format="cname">< if( facet.type )>_publish< endif>( <prefix>_<ifaceName; format="cname"
    > * This<
if( facet.arguments )><
    signature( prefix, facet.arguments.field )><
else><
    signature( prefix, facet.field )><
endif> );
}>
>>



requiredImplementation( prefix, usedTypes, ifaceName, rawSize, iface, ifaceID ) ::= <<
//requiredImplementation
#include \<<prefix>/<iface.name; format="cname">.h>
#include \<stdio.h>

enum <prefix>_event_id {
< first(iface.eventOrRequestOrData):{facet|
   <prefix; format="upper">_<facet.name; format="ID"> = 1,}>
< rest(iface.eventOrRequestOrData) :{facet|
   <prefix; format="upper">_<facet.name; format="ID">,
}>};

static const byte <iface.name; format="ID">_ID = <ifaceID>;

util_error <prefix>_<iface.name; format="cname">_init( <prefix>_<iface.name; format="cname"
> * This, SOCKET socket, struct sockaddr_in * target ) {
   This->socket = socket;
   This->target = *target;
   return io_byte_buffer_wrap( &This->out, <rawSize>, This->raw );
}
<iface.eventOrRequestOrData:{facet|


util_error <prefix>_<iface.name; format="cname">_<facet.name; format="cname">< if( facet.type )>_publish< endif>( <prefix>_<iface.name; format="cname"
   > * This<
if( facet.arguments )><
    signature( prefix, facet.arguments.field )><
else><
    signature( prefix, facet.field )><
endif> ) {
   UTIL_ERROR_CHECK( io_byte_buffer_clear   ( &This->out ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <iface.name; format="ID">_ID ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <prefix; format="ID">_<facet.name; format="ID"> ));
   < if( facet.arguments )><
        byteBufferPut( "", facet.arguments.field )><
     elseif( facet.type )><
        byteBufferPut( "&This->", facet )><
     elseif( facet.field )><
        byteBufferPut( "", facet.field )><
     endif>
   UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->out ));
   UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &This->out, &This->target ));
   return UTIL_NO_ERROR;
\}
}>
>>



dispatcherInterface( prefix, component, rawSize ) ::= <<
#pragma once
//dispatcherInterface
#include \<io/byte_buffer.h>
#include \<io/datagram_socket.h>

struct <prefix>_<component.name; format="cname">_s;
typedef struct <prefix>_<component.name; format="cname">_s <prefix>_<component.name; format="cname">;

typedef struct <prefix>_<component.name; format="cname">_dispatcher_s {
   SOCKET         socket;
   byte           raw[<rawSize>];
   io_byte_buffer in;
   <prefix>_<component.name; format="cname"> * listener;
} <prefix>_<component.name; format="cname">_dispatcher;

util_error <prefix>_<component.name; format="cname">_dispatcher_init(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   SOCKET socket,
   <prefix>_<component.name; format="cname"> * listener );

util_error <prefix>_<component.name; format="cname">_dispatcher_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   bool * has_dispatched );
< if( component.timeout )>

typedef enum <prefix>_<component.name; format="cname">_dispatcher_loopback_event_e {
   <component.timeout:{to|<prefix; format="ID">_<component.name; format="ID">_LOOPBACK_<to.name; format="ID"> = <i>,
}>
} <prefix>_<component.name; format="cname">_dispatcher_loopback_event;

typedef struct <prefix>_<component.name; format="cname">_dispatcher_timeout_arg_s {
   <prefix>_<component.name; format="cname">_dispatcher *              dispatcher;
   <prefix>_<component.name; format="cname">_dispatcher_loopback_event event;
} <prefix>_<component.name; format="cname">_dispatcher_timeout_arg;

util_error <prefix>_<component.name; format="cname">_dispatcher_loopback(
   <prefix>_<component.name; format="cname">_dispatcher_timeout_arg * arg );
< endif>
>>



dispatcherImplOneInterface( prefix, component, ifaceName ) ::= <<
//dispatcherImplOneInterface
typedef enum <prefix>_<ifaceName; format="cname">_event_e {
<events.(ifaceName):{event|
   <ifaceName; format="ID">_<event.name; format="ID"> = <i>,
}>\} <prefix>_<ifaceName; format="cname">_event;

static util_error <prefix>_<ifaceName; format="cname">_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   <prefix>_<ifaceName; format="cname">_event event,
   bool * has_dispatched )
{
   *has_dispatched = false;
   switch( event ) {
<events.(ifaceName):{event|
   case <ifaceName; format="ID">_<event.name; format="ID">:{
<event.field:{field|
      <     if( field.isBoolean )>bool <field.name; format="cname">;
      < elseif( field.isByte    )>byte <field.name; format="cname">;
      < elseif( field.isShort   )>short <field.name; format="cname">;
      < elseif( field.isUshort  )>ushort <field.name; format="cname">;
      < elseif( field.isInt     )>int <field.name; format="cname">;
      < elseif( field.isUint    )>uint <field.name; format="cname">;
      < elseif( field.isLong    )>long <field.name; format="cname">;
      < elseif( field.isUlong   )>ulong <field.name; format="cname">;
      < elseif( field.isFloat   )>float <field.name; format="cname">;
      < elseif( field.isDouble  )>double <field.name; format="cname">;
      < elseif( field.isString  )>char <field.name; format="cname">[ <field.length> + 1 ];
      < elseif( field.isEnum    )><prefix>_<field.userType.name; format="cname"> <field.name; format="cname">;
      < elseif( field.isStruct  )><prefix>_<field.userType.name; format="cname"> <field.name; format="cname">;
      < endif>
      <     if( field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_get_bool  ( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_get_short ( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_get_ushort( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_get_int   ( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_get_uint  ( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_get_long  ( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_get_ulong ( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_get_float ( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_get_double( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_get_string( &This->in, <field.name; format="cname">, sizeof( <field.name; format="cname"> )));
      < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( &This->in, &<field.name; format="cname"> ));
      < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <prefix>_<field.userType.name; format="cname">_get( &<field.name; format="cname">, &This->in ));
      < endif>
}>      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<event.name; format="cname">( This->listener<args( event.field )> ));
      *has_dispatched = true;
      break;
   \}
}>   default:
      fprintf( stderr, "<prefix>_<component.name; format="cname">_dispatcher|Ignored message:\n" );
      fprintf( stderr, "\tinterface = <ifaceName>\n" );
      fprintf( stderr, "\tevent     = %d\n", event );
      break;
   \}
   return UTIL_NO_ERROR;
}

>>

dispatcherImplementation( prefix, component, ifaces, events, usedTypes, rawSize ) ::= <<
//dispatcherImplementation
#include \<<prefix>/<component.name; format="cname">.h>
#include \<<prefix>/<component.name; format="cname">_dispatcher.h>

#include \<stdio.h>

typedef enum <prefix>_<component.name; format="cname">_dispatcher_interface_e {
< if( component.timeout )>
   LOOPBACK = 0,
< endif>
<ifaces.keys:{ifaceName|
   <ifaceName; format="ID,width"> = <ifaces.(ifaceName)>,
}>} <prefix>_<component.name; format="cname">_dispatcher_interface;

<ifaces.keys:{ifaceName|
<dispatcherImplOneInterface( prefix, component, ifaceName )>
}>util_error <prefix>_<component.name; format="cname">_dispatcher_init(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   SOCKET socket,
   <prefix>_<component.name; format="cname"> * listener )
{
   UTIL_CHECK_NON_NULL( listener );
   UTIL_ASSERT( socket > 0 );
   This->socket   = socket;
   This->listener = listener;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap( &This->in, <rawSize>, This->raw ));
   return UTIL_NO_ERROR;
}< if( component.timeout )>

static util_error loopback_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   <prefix>_<component.name; format="cname">_dispatcher_loopback_event event,
   bool * has_dispatched )
{
   switch( event ) {
<component.timeout:{to|
   case <prefix; format="ID">_<component.name; format="ID">_LOOPBACK_<to.name; format="ID">:
      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<to.name; format="cname">_elapsed( This->listener ));
      *has_dispatched = true;
      break;
}>   default:
      fprintf( stderr, "loopback_dispatch|unknown event = %d\n", event );
      return UTIL_NOT_APPLICABLE;
   }
   return UTIL_NO_ERROR;
}

< endif>
util_error <prefix>_<component.name; format="cname">_dispatcher_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   bool * has_dispatched )
{
   struct sockaddr_in from;
   byte interface, event;

   *has_dispatched = false;
   UTIL_ERROR_CHECK( io_byte_buffer_clear( &This->in ));
   UTIL_ERROR_CHECK( io_datagram_socket_receive( This->socket, &This->in, &from ));
   UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->in ));
   UTIL_ERROR_CHECK( io_byte_buffer_get_byte( &This->in, &interface ));
   UTIL_ERROR_CHECK( io_byte_buffer_get_byte( &This->in, &event ));
   fprintf( stderr, "<prefix>_<component.name; format="cname">_dispatcher_dispatch|interface = %d, event = %d\n", interface, event );
   switch( interface ) {
< if( component.timeout )>
   case LOOPBACK: UTIL_ERROR_CHECK( loopback_dispatch( This, event, has_dispatched )); break;
< endif>
<ifaces.keys:{ifaceName|
   case <ifaceName; format="ID,width">: UTIL_ERROR_CHECK( <prefix>_<ifaceName; format="cname">_dispatch( This, event, has_dispatched )); break;
}>   default:
      fprintf( stderr, "<prefix>_<component.name; format="cname">_dispatcher_dispatch|unknown interface %d\n", interface );
      return UTIL_NOT_APPLICABLE;
   }
   return UTIL_NO_ERROR;
}
< if( component.timeout )>

util_error <prefix>_<component.name; format="cname">_dispatcher_loopback( <
   prefix>_<component.name; format="cname">_dispatcher_timeout_arg * arg ) {
   UTIL_CHECK_NON_NULL( arg );
   <prefix>_<component.name; format="cname">_dispatcher *              This  = arg->dispatcher;
   <prefix>_<component.name; format="cname">_dispatcher_loopback_event event = arg->event;
   byte raw[2];
   io_byte_buffer out;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap    ( &out, sizeof( raw ), raw ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &out, (byte)LOOPBACK ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &out, (byte)event ));
   UTIL_ERROR_CHECK( io_byte_buffer_flip    ( &out ));
   UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &out, &This->listener->localAddress ));
   return UTIL_NO_ERROR;
}
< endif>
>>



componentInterface( prefix, component, responses, requires, instancesByName, instances, usedTypes, eventsOrRequests, actions ) ::= <<
#pragma once
//componentInterface
<component.requires:{required|#include \<<prefix>/<required.interface.name; format="cname">.h>
}>
<responses.(component.name):{r|#include \<<prefix>/<r.interface.name; format="cname">.h>
}>
< if( component.automaton )
>#include \<util/automaton.h>
< endif>
< if( component.timeout )
>#include \<util/timeout.h>
< endif>
<usedTypes:{used|
#include \<<prefix>/<used; format="cname">.h>
}>
#include \<<prefix>/<component.name; format="cname">_dispatcher.h>

typedef struct <prefix>_<component.name; format="cname">_s {
   SOCKET             socket;
   struct sockaddr_in localAddress;
   bool               running;
< if( component.automaton )>   util_automaton     automaton;
< endif><component.timeout:{to|
   util_timeout       <to.name; format="cname">;
}>   <prefix>_<component.name; format="cname">_dispatcher dispatcher;
< first(requires):{req|<requires.(req):{rt|
   <prefix>_<rt.interface.name; format="cname"> <rt.interface.name; format="cname">;
}>}>   void * user_context;
} <prefix>_<component.name; format="cname">;

util_error <prefix>_<component.name; format="cname">_init     ( <prefix>_<component.name; format="cname"> * This, const char * name, void * user_context );
util_error <prefix>_<component.name; format="cname">_run      ( <prefix>_<component.name; format="cname"> * This );
util_error <prefix>_<component.name; format="cname">_terminate( <prefix>_<component.name; format="cname"> * This );
<eventsOrRequests:{facet|
util_error <prefix>_<component.name; format="cname">_<facet.name; format="cname">( <prefix>_<component.name; format="cname"> * This<
if( facet.arguments )><
    signature( prefix, facet.arguments.field )>, <ifaceName; format="cname">_<facet.name; format="cname">_response * response<
else><
    signature( prefix, facet.field )><
endif> );
}>< if( component.afterDispatchNeeded )>util_error <prefix>_<component.name; format="cname">_after_dispatch( <prefix>_<component.name; format="cname"> * This );
< endif><actions:{action|
util_error <prefix>_<component.name; format="cname">_<action; format="cname">( <prefix>_<component.name; format="cname"> * This );
}><component.timeout:{to|
util_error <prefix>_<component.name; format="cname">_<to.name; format="cname">_elapsed( <prefix>_<component.name; format="cname"> * This );
}>
>>



componentImplementation( prefix, component, requires, instancesByName, instances ) ::= <<
// componentImplementation
#include \<<prefix>/<component.name; format="cname">.h>
< if( component.automaton )>#include \<dab/automaton.h>
#include \<<prefix>/<component.automaton.eventEnum.name; format="cname">.h>
< endif>
#include \<stdio.h>
#include \<stdlib.h>
#include \<string.h>

util_error <prefix>_<component.name; format="cname">_init( <
   prefix>_<component.name; format="cname"> * This, const char * name, void * user_context ) {
   memset( This, 0, sizeof( <prefix>_<component.name; format="cname"> ));
   This->socket = socket( AF_INET, SOCK_DGRAM, 0 );
   if( This->socket == INVALID_SOCKET ) {
      return UTIL_OS_ERROR;
   }
   This->running      = false;
   This->user_context = user_context;
< if( component.automaton )>   <prefix>_automaton_init( &This->automaton, This );< endif>
< if( requires )>
   struct sockaddr_in < first(requires):{req|<
      first( requires.(req) ):{rt|<rt.interface.name; format="cname">}><
      rest ( requires.(req) ):{rt|, <rt.interface.name; format="cname">}>}>;
< endif>
< first(instances):{instance|
   if( 0 ==  strcmp( name, "<instance.name>" )) {
      UTIL_ERROR_CHECK( io_datagram_socket_bind( This->socket, "<instance.address>", <instance.port>, &This->localAddress ));
      <requires.(instance.name):{req|UTIL_ERROR_CHECK( io_datagram_socket_init( "<
         instancesByName.(req.toInstance.name).address>", <
         instancesByName.(req.toInstance.name).port>, &<
         req.interface.name; format="cname"> ));
}>}>< rest(instances):{instance|
  \}
  else if( 0 ==  strcmp( name, "<instance.name>" )) {
      UTIL_ERROR_CHECK( io_datagram_socket_bind( This->socket, "<instance.address>", <instance.port>, &This->localAddress ));
      <requires.(instance.name):{req|UTIL_ERROR_CHECK( io_datagram_socket_init( "<
         instancesByName.(req.toInstance.name).address>", <
         instancesByName.(req.toInstance.name).port>, &<
         req.interface.name; format="cname"> ));
}>}>   }
   else {
      fprintf( stderr, "unknown deployment name '%s'!\n", name );
      return UTIL_NOT_APPLICABLE;
   }
   < first(requires):{req|<requires.(req):{rt|UTIL_ERROR_CHECK( <
      prefix>_<rt.interface.name; format="cname">_init( &This-><rt.interface.name; format="cname">, This->socket, &<rt.interface.name; format="cname"> ));
}>}>   UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_dispatcher_init( &This->dispatcher, This->socket, This ));
<component.timeout:{to|
   static <prefix>_<component.name; format="cname">_dispatcher_timeout_arg timeout_arg_<to.name; format="cname">;
   timeout_arg_<to.name; format="cname">.dispatcher = &This->dispatcher;
   timeout_arg_<to.name; format="cname">.event      = <
      prefix; format="ID">_<component.name; format="ID">_LOOPBACK_<to.name; format="ID">;
   UTIL_ERROR_CHECK( util_timeout_init(
      &This-><to.name; format="cname">,
      <to.duration><to.unit.toCpp>,
      (util_timeout_action)<prefix>_<component.name; format="cname">_dispatcher_loopback,
      &timeout_arg_<to.name; format="cname"> ));
}>
   return UTIL_NO_ERROR;
}

util_error <prefix>_<component.name; format="cname">_run( <prefix>_<component.name; format="cname"> * This ) {
   This->running = true;
   while( This->running ) {
      bool has_dispatched;
      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_dispatcher_dispatch( &This->dispatcher, &has_dispatched ));
      < if( component.afterDispatchNeeded )>if( has_dispatched ) {
         UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_after_dispatch( This ));
      }
< endif>
   }
   return UTIL_NO_ERROR;
}
>>



automatonHeader( prefix, component ) ::= <<
#pragma once

#include \<<prefix>/<component.name; format="cname">.h>
#include \<util/automaton.h>

void <prefix>_automaton_init( util_automaton * automaton, <prefix>_<component.name; format="cname"> * actor );
>>



automatonBody( prefix, component ) ::= <<
#include \<<prefix>/automaton.h>
#include \<<prefix>/<component.automaton.stateEnum.name; format="cname">.h>
#include \<<prefix>/<component.automaton.eventEnum.name; format="cname">.h>

static util_transition transitions[] = {
   <component.automaton.transition:{transition|{ <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<transition.from ; format="ID">, <
      prefix; format="ID">_<component.automaton.eventEnum.name; format="ID">_<transition.event; format="ID">, <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<transition.futur; format="ID"> \},
}>};

static util_shortcut shortcuts[] = {
   <component.automaton.shortcut:{shortcut|{ <
      prefix; format="ID">_<component.automaton.eventEnum.name; format="ID">_<shortcut.event; format="ID">, <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<shortcut.futur; format="ID"> \},
}>};

static util_automaton_state_action on_entry[] = {
   <component.automaton.onEntryOrOnExit:{eoe|< if( eoe.isOnEntry )>{ <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<
      eoe.value.state; format="ID">, (util_automaton_action)&<
      prefix>_<component.name; format="cname">_<eoe.value.action; format="cname"> \},
< endif>}>};

static util_automaton_state_action on_exit[] = {
   <component.automaton.onEntryOrOnExit:{eoe|< if( eoe.isOnExit )>{ <
      prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<
      eoe.value.state; format="ID">, (util_automaton_action)&<
      prefix>_<component.name; format="cname">_<eoe.value.action; format="cname"> \},
< endif>}>};

void <prefix>_automaton_init( util_automaton * automaton, <prefix>_<component.name; format="cname"> * actor ) {
   automaton->debug           = false;
   automaton->current         = <prefix; format="ID">_<component.automaton.stateEnum.name; format="ID">_<component.automaton.initial; format="ID">;
   automaton->arcs            = transitions;
   automaton->arcs_count      = sizeof( transitions )/sizeof( transitions[0] );
   automaton->shortcuts       = shortcuts;
   automaton->shortcuts_count = sizeof( shortcuts   )/sizeof( shortcuts  [0] );
   automaton->actor           = actor;
   automaton->on_entry        = on_entry;
   automaton->on_entry_count  = sizeof( on_entry    )/sizeof( on_entry   [0] );
   automaton->on_exit         = on_exit;
   automaton->on_exit_count   = sizeof( on_exit     )/sizeof( on_exit    [0] );
}
>>
