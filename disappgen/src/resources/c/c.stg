group C;



concat(a,b) ::= <<
<a><b>
>>



type( field ) ::= <<
< if(     field.isBoolean )>bool  <
  elseif( field.isByte    )>byte  <
  elseif( field.isShort   )>short <
  elseif( field.isUshort  )>ushort<
  elseif( field.isInt     )>int   <
  elseif( field.isUint    )>uint  <
  elseif( field.isLong    )>long  <
  elseif( field.isUlong   )>ulong <
  elseif( field.isFloat   )>float <
  elseif( field.isDouble  )>double<
  elseif( field.isString  )>char  <
  elseif( field.isEnum    )><types.(field.userType)><
  elseif( field.isStruct  )><types.(field.userType)><
  else>
#error Field n'est d'aucun type connu : <field>!<
  endif>
>>



signature( fields, types ) ::= <<
<fields:{field|
, < if( field.isBoolean )>bool<
elseif( field.isString  )>const char *<
elseif( field.isEnum    )><types.(field.userType); format="cname"><
elseif( field.isStruct  )>const <types.(field.userType); format="cname"> *<
else                     ><type(field)><
endif                    > <field.name; format="cname">}>
>>



args( fields ) ::= <<
<fields:{field|, <
   if( field.isStruct  )>&<
   endif                ><field.name; format="cname">}>
>>



byteBufferPut( this, fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_put_bool( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_put_short( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_put_ushort( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_put_int( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_put_uint( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_put_long( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_put_ulong( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_put_float( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_put_double( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_put_string( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <this><field.name; format="cname"> ));
< elseif( field.isStruct  )>UTIL_ERROR_CHECK( <typesPrefix>_<field.userType.name; format="cname">_put( <this><field.name; format="cname">, &This->out ));
< endif>
}>
>>



enumHeader( prefix, enum ) ::= <<
#pragma once

typedef enum <prefix>_<enum.name; format="cname">_e {
   <prefix; format="upper">_<enum.name; format="ID">_FIRST,

< first(enum.literal):{literal|
   <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID"> = <
    prefix; format="upper">_<enum.name; format="ID">_FIRST,}>
< rest(enum.literal) :{literal|
   <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID">,
}>
   <prefix; format="upper">_<enum.name; format="ID">_LAST

} <prefix>_<enum.name; format="cname">;

const char * <prefix>_<enum.name; format="cname">_to_string( <prefix>_<enum.name; format="cname"> value ); 

>>



enumBody( prefix, enum ) ::= <<
#include \<<prefix>/<enum.name; format="cname">.h>

const char * <prefix>_<enum.name; format="cname">_to_string( <prefix>_<enum.name; format="cname"> value ) {
   switch( value ) {
   <enum.literal:{literal|
   case <prefix; format="upper">_<enum.name; format="ID">_<literal.name; format="ID,width">: return "<literal.name; format="ID">";
}>   default: return "Etat inconnu !";
   }
}

>>



structHeader( prefix, struct, types ) ::= <<
#pragma once

#include \<io/byte_buffer.h>

<struct.field:{field|<
if( field.isStruct || field.isEnum )>
#include \<<types.(field.userType); format="typeToPath">.h><
endif>}>

typedef struct <prefix>_<struct.name; format="cname">_s {
<struct.field:{field|<
if( field.isString )>
   char <field.name; format="cname">[ <field.length> + 1 ];<
else>
   <type(field)> <field.name; format="cname">;<
endif>}>
} <prefix>_<struct.name; format="cname">;

util_error <prefix>_<struct.name; format="cname">_put( const <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * target );
util_error <prefix>_<struct.name; format="cname">_get( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * source );

>>



structBody( prefix, struct, modelName, maxLength, maxStrLength, types ) ::= <<
#include \<<prefix>/<struct.name; format="cname">.h>
#include \<stdio.h>

util_error <prefix>_<struct.name; format="cname">_put( const <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * target ) {
<struct.field:{field|
   < if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_put_bool  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_put_short ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_put_ushort( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_put_int   ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_put_uint  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_put_long  ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_put_ulong ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_put_float ( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_put_double( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_put_string( target, This-><field.name; format="cname,width"> ));
   < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_put_byte  ( target, (byte)This-><field.name; format="cname,width"> ));
   < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <types.(field.userType)>_put( &This-><field.name; format="cname">, target ));
   < endif>
}>   return UTIL_NO_ERROR;
}

util_error <prefix>_<struct.name; format="cname">_get( <prefix>_<struct.name; format="cname"> * This, io_byte_buffer * source ) {
<struct.field:{field|
   < if(     field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_get_bool  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_get_short ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_get_ushort( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_get_int   ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_get_uint  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_get_long  ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_get_ulong ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_get_float ( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_get_double( source, &This-><field.name; format="cname,width"> ));
   < elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_get_string( source, This-><
         field.name; format="cname,strWidth">, sizeof( This-><field.name; format="cname,strWidth"> )));
   < elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( source, (byte *)&This-><field.name; format="cname,width"> ));
   < elseif( field.isStruct  )>UTIL_ERROR_CHECK( <types.(field.userType)>_get( &This-><field.name; format="cname">, source ));
   < endif>
}>   return UTIL_NO_ERROR;
}

>>



responsesHeader( prefix, ifaceName, requests, types ) ::= <<
#pragma once
// responsesHeader
<requests:{request|
#include \<<types.(request.type); format="typeToPath">.h\>
}>

<requests:{request|
void <prefix>_<request.name>_response( const <types.(request.type)> * <request.name> );
}>
>>



requiredInterface( prefix, usedTypes, ifaceName, rawSize, iface, types ) ::= <<
#pragma once
// requiredInterface

#include \<io/datagram_socket.h>
#include \<da/targets.h>

<usedTypes:{type|#include \<<types.(type); format="typeToPath">.h>
}>

typedef struct <prefix>_<ifaceName; format="cname">_s {
   SOCKET         socket;
   byte           from;
   io_byte_buffer out;
   unsigned       targets_count;
   da_targets *   targets;
   byte           raw[<rawSize>];
} <prefix>_<ifaceName; format="cname">;

util_error <prefix>_<ifaceName; format="cname">_init( <prefix>_<ifaceName; format="cname"
> * This, SOCKET socket, byte from, unsigned targets_count, da_targets * targets );

<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>
util_error <prefix>_<ifaceName; format="cname">_<facet.name; format="cname">( <prefix>_<ifaceName; format="cname"> * This<
if( facet.isRequest )><
    signature( facet.arguments.field, types )><
else><
    signature( facet.field, types )><
endif> );
< endif>}>
>>



requiredImplementation( prefix, usedTypes, ifaceName, rawSize, iface, ifaceID, types ) ::= <<
// requiredImplementation

#include \<<prefix>/<iface.name; format="cname">.h>
#include \<stdio.h>
#include \<util/log.h>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-const-variable"
<iface.eventOrRequestOrData:{facet|static const byte <prefix; format="ID">_<facet.name; format="ID"> = <i>;
}>
static const byte <prefix; format="ID">_<iface.name; format="ID">_ID = <ifaceID>;
#pragma GCC diagnostic pop

util_error <prefix>_<iface.name; format="cname">_init( <prefix>_<iface.name; format="cname"
> * This, SOCKET socket, byte from, unsigned targets_count, da_targets * targets ) {
   UTIL_LOG_HERE();
   This->socket        = socket;
   This->from          = from;
   This->targets_count = targets_count;
   This->targets       = targets;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap( &This->out, <rawSize>, This->raw ));
   return UTIL_NO_ERROR;
}
<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>

util_error <prefix>_<iface.name; format="cname">_<facet.name; format="cname">( <prefix>_<iface.name; format="cname"
   > * This<
if( facet.isRequest )><
    signature( facet.arguments.field, types )><
else><
    signature( facet.field, types )><
endif> ) {
   UTIL_LOG_HERE();
   for( unsigned i = 0; i \< This->targets_count; ++i ) {
      da_targets * targets = This->targets + i;
      for( unsigned j = 0; j \< targets->instances_count; ++j ) {
         byte to = targets->instances[j];
         UTIL_ERROR_CHECK( io_byte_buffer_clear   ( &This->out ));
         UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <prefix; format="ID">_<iface.name; format="ID">_ID ));
         UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <prefix; format="ID">_<facet.name; format="ID"> ));
         UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, to ));
         <
if( facet.isRequest )
        >UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, This->from ));
<        byteBufferPut( "", facet.arguments.field )><
else><   byteBufferPut( "", facet.field )><
endif>
         UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->out ));
         size_t size = 0;
         UTIL_ERROR_CHECK( io_byte_buffer_remaining( &This->out, &size ));
         UTIL_LOG_ARGS( "%u byte(s) sent from instance %d to instance %d @ %s",
            (unsigned)size, This->from, to, inet_ntoa( targets->process.sin_addr ));
         UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &This->out, &targets->process ));
      \}
   \}
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
\}
< endif>
}>
>>



dispatcherInterface( prefix, component, rawSize, hasResponse, respRawSize ) ::= <<
#pragma once
//dispatcherInterface
#include \<io/byte_buffer.h>
#include \<io/datagram_socket.h>

struct <prefix>_<component.name; format="cname">_s;
typedef struct <prefix>_<component.name; format="cname">_s <prefix>_<component.name; format="cname">;

typedef struct <prefix>_<component.name; format="cname">_dispatcher_s {
   bool *             running;
   SOCKET             socket;
   byte               instance;
   struct sockaddr_in local_addr;
< if( hasResponse )>
   byte               out_raw[<respRawSize>];
   io_byte_buffer     out;
< endif>
   <prefix>_<component.name; format="cname"> * listener;
} <prefix>_<component.name; format="cname">_dispatcher;

util_error <prefix>_<component.name; format="cname">_dispatcher_init(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   bool * running,
   SOCKET socket,
   byte   instance,
   struct sockaddr_in * local_addr,
   <prefix>_<component.name; format="cname"> * listener );

util_error <prefix>_<component.name; format="cname">_dispatcher_terminate(
   <prefix>_<component.name; format="cname">_dispatcher * This );

util_error <prefix>_<component.name; format="cname">_dispatcher_before_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This );

util_error <prefix>_<component.name; format="cname">_dispatcher_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   byte                 intrfc,
   byte                 event,
   byte                 instance,
   struct sockaddr_in * from,
   io_byte_buffer *     in,
   bool *               has_dispatched );

util_error <prefix>_<component.name; format="cname">_dispatcher_after_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   bool has_dispatched );
< if( component.timeout )>

typedef enum <prefix>_<component.name; format="cname">_dispatcher_loopback_event_e {
   <component.timeout:{to|<prefix; format="ID">_<component.name; format="ID">_LOOPBACK_<to.name; format="ID"> = <i>,
}>
} <prefix>_<component.name; format="cname">_dispatcher_loopback_event;

typedef struct <prefix>_<component.name; format="cname">_dispatcher_timeout_arg_s {
   <prefix>_<component.name; format="cname">_dispatcher *              dispatcher;
   <prefix>_<component.name; format="cname">_dispatcher_loopback_event event;
} <prefix>_<component.name; format="cname">_dispatcher_timeout_arg;

util_error <prefix>_<component.name; format="cname">_dispatcher_loopback(
   <prefix>_<component.name; format="cname">_dispatcher_timeout_arg * arg );
< endif>

>>



byteBufferGet( fields ) ::= <<
<fields:{field|
<     if( field.isBoolean )>bool <field.name; format="cname">;
< elseif( field.isByte    )>byte <field.name; format="cname">;
< elseif( field.isShort   )>short <field.name; format="cname">;
< elseif( field.isUshort  )>ushort <field.name; format="cname">;
< elseif( field.isInt     )>int <field.name; format="cname">;
< elseif( field.isUint    )>uint <field.name; format="cname">;
< elseif( field.isLong    )>long <field.name; format="cname">;
< elseif( field.isUlong   )>ulong <field.name; format="cname">;
< elseif( field.isFloat   )>float <field.name; format="cname">;
< elseif( field.isDouble  )>double <field.name; format="cname">;
< elseif( field.isString  )>char <field.name; format="cname">[ <field.length> + 1 ];
< elseif( field.isEnum    )><typesPrefix>_<field.userType.name; format="cname"> <field.name; format="cname">;
< elseif( field.isStruct  )><typesPrefix>_<field.userType.name; format="cname"> <field.name; format="cname">;
< endif>
<     if( field.isBoolean )>UTIL_ERROR_CHECK( io_byte_buffer_get_bool  ( in, &<field.name; format="cname"> ));
< elseif( field.isByte    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( in, &<field.name; format="cname"> ));
< elseif( field.isShort   )>UTIL_ERROR_CHECK( io_byte_buffer_get_short ( in, &<field.name; format="cname"> ));
< elseif( field.isUshort  )>UTIL_ERROR_CHECK( io_byte_buffer_get_ushort( in, &<field.name; format="cname"> ));
< elseif( field.isInt     )>UTIL_ERROR_CHECK( io_byte_buffer_get_int   ( in, &<field.name; format="cname"> ));
< elseif( field.isUint    )>UTIL_ERROR_CHECK( io_byte_buffer_get_uint  ( in, &<field.name; format="cname"> ));
< elseif( field.isLong    )>UTIL_ERROR_CHECK( io_byte_buffer_get_long  ( in, &<field.name; format="cname"> ));
< elseif( field.isUlong   )>UTIL_ERROR_CHECK( io_byte_buffer_get_ulong ( in, &<field.name; format="cname"> ));
< elseif( field.isFloat   )>UTIL_ERROR_CHECK( io_byte_buffer_get_float ( in, &<field.name; format="cname"> ));
< elseif( field.isDouble  )>UTIL_ERROR_CHECK( io_byte_buffer_get_double( in, &<field.name; format="cname"> ));
< elseif( field.isString  )>UTIL_ERROR_CHECK( io_byte_buffer_get_string( in, <field.name; format="cname">, sizeof( <field.name; format="cname"> )));
< elseif( field.isEnum    )>UTIL_ERROR_CHECK( io_byte_buffer_get_byte  ( in, &<field.name; format="cname"> ));
< elseif( field.isStruct  )>UTIL_ERROR_CHECK( <typesPrefix>_<field.userType.name; format="cname">_get( &<field.name; format="cname">, in ));
< endif>
}>
>>



dispatcherImplOneInterface( prefix, component, ifaceName, types ) ::= <<
// dispatcherImplOneInterface -- begin
typedef enum <prefix>_<ifaceName; format="cname">_event_e {
<events.(ifaceName):{facet|
   <ifaceName; format="ID">_<facet.name; format="ID"> = <i>,
}>\}
<prefix>_<ifaceName; format="cname">_event;

<events.(ifaceName):{facet|< if( facet.isRequest )>
static const byte EVENT_<ifaceName; format="ID">_RESPONSES_<facet.name; format="ID"> = <eventIDs.(ifaceName).(facet.name)>;
< endif>}>
static util_error <prefix>_<ifaceName; format="cname">_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   io_byte_buffer * in,
< if( offRequests.(ifaceName))>
   struct sockaddr_in * from,
< endif>
   <prefix>_<ifaceName; format="cname">_event event,
   bool *           has_dispatched )
{
   switch( event ) {
<events.(ifaceName):{facet|< if( facet.isData )>< else>
   case <ifaceName; format="ID">_<facet.name; format="ID">:{<
if( facet.isRequest )>
      byte fromInstance;
      UTIL_ERROR_CHECK( io_byte_buffer_get_byte( in, &fromInstance ));
      <facet.arguments.field:{field|<
         byteBufferGet( field )>}>< 
elseif( facet.field )><facet.field:{field|<
         byteBufferGet( field )>}><
endif><
if( facet.isRequest )
>      <types.(facet.type)> <facet.name>;
      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<
         facet.name; format="cname">( This->listener<args( facet.arguments.field )>, &<facet.name> ));
      UTIL_ERROR_CHECK( io_byte_buffer_clear   ( &This->out ));
      UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <ifaceName; format="ID">_RESPONSES ));
      UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, EVENT_<ifaceName; format="ID">_RESPONSES_<facet.name; format="ID"> ));
      UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, fromInstance ));
      UTIL_ERROR_CHECK( <types.(facet.type)>_put( &<facet.name>, &This->out ));
      UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->out ));
      UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &This->out, from ));
      UTIL_LOG_ARGS( "response sent to %s", inet_ntoa( from->sin_addr ));<
else>      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<
          facet.name; format="cname">( This->listener<args( facet.field )> ));
< endif>
      *has_dispatched = true;
      break;
      \}
< endif>}>
   default:
      UTIL_LOG_ARGS( "Ignored message: interface = <ifaceName>, event = %d", event );
      break;
   \}
   return UTIL_NO_ERROR;
}
// dispatcherImplOneInterface -- end
>>



dispatcherImplResponse() ::= <<
// dispatcherImplResponse -- begin
typedef enum <prefix>_<ifaceName; format="cname">_response_e {
   <reqRequests.(ifaceName):{req|<req.name; format="ID"> = <i>,
}>} <prefix>_<ifaceName; format="cname">_response;

static util_error <prefix>_<ifaceName; format="cname">_responses_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   io_byte_buffer * in,
   <prefix>_<ifaceName; format="cname">_response event,
   bool *           has_dispatched )
{
   switch( event ) {
<reqRequests.(ifaceName):{req|
   case <req.name; format="ID">:{
      <types.(req.type)> <req.name>;
      <types.(req.type)>_get( &<req.name>, in );
      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<
         ifaceName; format="cname">_response_<
         req.name; format="cname">( This->listener, &<req.name> ));
      *has_dispatched = true;\}
      break;
}>   default:
      UTIL_LOG_ARGS( "Unexpected <ifaceName>'s event: %d", event );
      break;
   }
   return UTIL_NO_ERROR;
}
// dispatcherImplResponse -- end
>>



dispatcherImplData() ::= <<
// dispatcherImplData -- begin
typedef enum <prefix>_<iface.name; format="cname">_data_e {
   <data.(iface):{dataType|<dataType.name; format="ID"> = <eventIDs.(iface.name).(dataType.name)>,
}>} <prefix>_<iface.name; format="cname">_data;

static util_error <prefix>_<iface.name; format="cname">_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   io_byte_buffer * in,
   <prefix>_<iface.name; format="cname">_data event,
   bool *           has_dispatched )
{
   switch( event ) {
<data.(iface):{dataType|
   case <dataType.name; format="ID">:{
      <types.(dataType.type)>_get( &This->listener-><dataType.name; format="cname">, in );
      <prefix>_<component.name; format="cname">_<dataType.name; format="cname">_published( This->listener );
      *has_dispatched = true;\}
      break;
}>   default:
      UTIL_LOG_ARGS( "Unexpected event: %d", event );
      break;
   }
   return UTIL_NO_ERROR;
}
// dispatcherImplData -- end
>>



dispatcherImplementation(
   prefix, component, ifaces, ifacesIDs, requires, events, eventIDs,
   usedTypes, hasResponse, offRequests, reqRequests, data, types
) ::= <<
//dispatcherImplementation
#include \<<prefix>/<component.name; format="cname">.h>
#include \<<prefix>/<component.name; format="cname">_dispatcher.h>

#include \<os/errors.h>
#include \<util/log.h>

#include \<stdio.h>
#include \<string.h>

typedef enum <prefix>_<component.name; format="cname">_dispatcher_interface_e {
< if( component.timeout )>
   LOOPBACK = 0,
< endif>
<ifaces.keys:{ifaceName|
   <ifaceName; format="ID,width"> = <ifaces.(ifaceName)>,
< if( offRequests.(ifaceName))>
   <ifaceName; format="ID">_RESPONSES = <ifacesIDs.( concat( ifaceName, "Response" ))>,
< endif>
}><reqRequests:{ifaceName|
   <ifaceName; format="ID">_RESPONSES = <ifacesIDs.( concat( ifaceName, "Response" ))>,
}><data:{iface|
   <iface.name; format="ID,width"> = <requires.(iface.name)>,
}>} <prefix>_<component.name; format="cname">_dispatcher_interface;

<ifaces.keys:{ifaceName|
<dispatcherImplOneInterface( prefix, component, ifaceName, types )>
}>
<data:{iface|
<dispatcherImplData()>
}>
<reqRequests:{ifaceName|
<dispatcherImplResponse()>
}>
util_error <prefix>_<component.name; format="cname">_dispatcher_init(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   bool *               running,
   SOCKET               socket,
   byte                 instance,
   struct sockaddr_in * local_addr,
   <prefix>_<component.name; format="cname"> *            listener )
{
   UTIL_LOG_HERE();
   UTIL_CHECK_NON_NULL( This );
   UTIL_CHECK_NON_NULL( running );
   UTIL_ASSERT( socket > 0 );
   UTIL_CHECK_NON_NULL( local_addr );
   UTIL_CHECK_NON_NULL( listener );
   memset( This, 0, sizeof( <prefix>_<component.name; format="cname">_dispatcher ));
   This->running    = running;
   This->socket     = socket;
   This->instance   = instance;
   This->local_addr = *local_addr;
   This->listener   = listener;
   listener->dispatcher = This;
< if( hasResponse )>
   UTIL_ERROR_CHECK( io_byte_buffer_wrap( &This->out, sizeof( This->out_raw ), This->out_raw ));
< endif>
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
}

< if( component.timeout )>

static util_error loopback_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   <prefix>_<component.name; format="cname">_dispatcher_loopback_event event,
   bool * has_dispatched )
{
   UTIL_LOG_HERE();
   switch( event ) {
<component.timeout:{to|
   case <prefix; format="ID">_<component.name; format="ID">_LOOPBACK_<to.name; format="ID">:
      UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_<to.name; format="cname">_elapsed( This->listener ));
      *has_dispatched = true;
      break;
}>
   default: UTIL_LOG_ARGS( "unknown event = %d\n", event ); break;
   }
   return UTIL_NO_ERROR;
}
< endif>

util_error <prefix>_<component.name; format="cname">_dispatcher_terminate(
   <prefix>_<component.name; format="cname">_dispatcher * This )
{
   This->running = false;
   OS_ASSERT( "shutdown", shutdown( This->socket, SHUT_RDWR ), 0 );
   OS_ASSERT( "close"   , closesocket( This->socket )        , 0 );
   return UTIL_NO_ERROR;
}

util_error <prefix>_<component.name; format="cname">_dispatcher_before_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This )
{
   UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_before_dispatch( This->listener ));
   return UTIL_NO_ERROR;
}

util_error <prefix>_<component.name; format="cname">_dispatcher_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   byte                 intrfc,
   byte                 event,
   byte                 instance,
   struct sockaddr_in * from,
   io_byte_buffer *     in,
   bool *               has_dispatched )
{
   UTIL_LOG_HERE();
   if( instance == This->instance ) {
      switch( intrfc ) {
< if( component.timeout )>
      case LOOPBACK: UTIL_ERROR_CHECK( loopback_dispatch( This, event, has_dispatched )); break;
< endif>
<ifaces.keys:{ifaceName|
      case <ifaceName; format="ID">: < if( offRequests.(ifaceName))
   >UTIL_ERROR_CHECK( <prefix>_<ifaceName; format="cname">_dispatch( This, in, from, event, has_dispatched )); break;< else
   >UTIL_ERROR_CHECK( <prefix>_<ifaceName; format="cname">_dispatch( This, in, event, has_dispatched )); break;
< endif>
}><reqRequests:{ifaceName|
      case <ifaceName; format="ID">_RESPONSES: UTIL_ERROR_CHECK( <prefix>_<ifaceName; format="cname">_responses_dispatch( This, in, event, has_dispatched )); break;
}><data:{iface|
      case <iface.name; format="ID">: UTIL_ERROR_CHECK( <prefix>_<iface.name; format="cname">_dispatch( This, in, event, has_dispatched )); break;
}>      default: UTIL_LOG_ARGS( "unknown interface %d", intrfc ); break;
      }
   }
   else {
      UTIL_LOG_ARGS( "unknown instance %d", instance );
   }
   UTIL_LOG_ARGS( "has_dispatched = %s", has_dispatched ? "true" : "false" );
   return UTIL_NO_ERROR;
   (void)from;
}

util_error <prefix>_<component.name; format="cname">_dispatcher_after_dispatch(
   <prefix>_<component.name; format="cname">_dispatcher * This,
   bool hasDispatched )
{
   UTIL_ERROR_CHECK( <prefix>_<component.name; format="cname">_after_dispatch( This->listener, hasDispatched ));
   return UTIL_NO_ERROR;
}
< if( component.timeout )>

util_error <prefix>_<component.name; format="cname">_dispatcher_loopback( <
   prefix>_<component.name; format="cname">_dispatcher_timeout_arg * arg ) {
   UTIL_LOG_HERE();
   UTIL_CHECK_NON_NULL( arg );
   <prefix>_<component.name; format="cname">_dispatcher *              This  = arg->dispatcher;
   <prefix>_<component.name; format="cname">_dispatcher_loopback_event event = arg->event;
   byte raw[3];
   io_byte_buffer out;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap    ( &out, sizeof( raw ), raw ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &out, (byte)LOOPBACK ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &out, (byte)event ));
   UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &out, This->instance ));
   UTIL_ERROR_CHECK( io_byte_buffer_flip    ( &out ));
   UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &out, &This->local_addr ));
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
}
< endif>

>>



componentInterface(
    prefix, component, responses, requires, instances,
    usedTypes, eventsOrRequests, reqRequests, actions, data, reqData, types
) ::= <<
#pragma once
// componentInterface

<component.requires:{required|#include \<<prefix>/<required.interface.name; format="cname">.h>
}>
< if( responses )>
<responses.(component.name):{r|#include \<<prefix>/<r.interface.name; format="cname">.h>
}><
endif>
< if( data )>
<reqData:{iface|<reqData.(iface):{data|
#include \<<types.(data.name); format="typeToPath">.h>
}>}><
endif><
if( component.automaton )
>#include \<util/automaton.h>
< endif>
< if( component.timeout )
>#include \<util/timeout.h><
endif>
<data:{iface|


#include \<<prefix>/<iface.name; format="cname">_data.h>
}><usedTypes:{used|
#include \<<types.(used); format="typeToPath">.h>
}>
#include \<<prefix>/<component.name; format="cname">_dispatcher.h>

typedef struct <prefix>_<component.name; format="cname">_s {
   <prefix>_<component.name; format="cname">_dispatcher * dispatcher;
<requires:{req|
   <prefix>_<req.name; format="cname"> * <req.name; format="cname">;
}><reqData:{iface|<reqData.(iface):{data|
   <types.(data.type)> <data.name; format="cname">; // required data
}>}><data :{iface|<data   .(iface):{data|
   <types.(data.type)> <data.name; format="cname">; // offered data}>
   <prefix>_<iface.name; format="cname">_data * <iface.name; format="cname">_data; // data publisher
}>< if( component.automaton )
>   util_automaton automaton;
< endif><component.timeout:{to|
   util_timeout   <to.name; format="cname">;
}
>   void *         user_context;
} <prefix>_<component.name; format="cname">;

util_error <prefix>_<component.name; format="cname">_init( <
   prefix>_<component.name; format="cname"> * This );
util_error <prefix>_<component.name; format="cname">_before_dispatch( <
   prefix>_<component.name; format="cname"> * This );
util_error <prefix>_<component.name; format="cname">_after_dispatch( <
   prefix>_<component.name; format="cname"> * This, bool hasDispatched );
<reqData:{iface|<reqData.(iface):{data|
util_error <prefix>_<component.name; format="cname">_<data.name; format="cname">_published( <
   prefix>_<component.name; format="cname"> * This );
}>}><eventsOrRequests:{ifaceName|<eventsOrRequests.(ifaceName):{facet|
util_error <prefix>_<component.name; format="cname">_<facet.name; format="cname">( <
   prefix>_<component.name; format="cname"> * This<
if( facet.isRequest )><
   signature( facet.arguments.field, types )>, <types.(facet.type)> * <facet.name><
elseif( facet.isData)><
else><
   signature( facet.field, types )><
endif> );
}>}><reqRequests:{ifaceName|<reqRequests.(ifaceName):{req|
util_error <prefix>_<component.name; format="cname">_<
    ifaceName; format="cname">_response_<
    req.name; format="cname">( <
   prefix>_<component.name; format="cname"> * This, <types.(req.type)> * <req.name> );
}>}><actions:{action|
util_error <prefix>_<component.name; format="cname">_<action; format="cname">( <
   prefix>_<component.name; format="cname"> * This );
}><component.timeout:{to|
util_error <prefix>_<component.name; format="cname">_<to.name; format="cname">_elapsed( <
   prefix>_<component.name; format="cname"> * This );
}>
>>



dataWriterHeader( prefix, interface, ifaceID, data, rawSize, types  ) ::= <<
#pragma once
// dataWriterHeader

#include \<da/targets.h>
#include \<io/datagram_socket.h>

<data:{dataType|
#include \<<types.(dataType.type); format="typeToPath">.h>
}>
typedef struct <prefix>_<interface.name; format="cname">_data_s {
   SOCKET         socket;
   byte           from;
   io_byte_buffer out;
   unsigned       targets_count;
   da_targets *   targets;
   byte           raw[<rawSize>];
} <prefix>_<interface.name; format="cname">_data;

util_error <prefix>_<interface.name; format="cname">_data_init(
   <prefix>_<interface.name; format="cname">_data * This,
   SOCKET       socket,
   byte         from,
   unsigned     targets_count,
   da_targets * targets       );

<data:{dataType|
util_error <prefix>_<interface.name; format="cname">_data_publish_<dataType.name; format="cname">(
   <prefix>_<interface.name; format="cname">_data * This,
   const <types.(dataType.type)> * <dataType.name; format="cname"> );
}>

>>



dataWriterBody( prefix, interface, ifaceID, data, dataID, rawSize, types ) ::= <<
// dataWriterBody
#include \<<prefix>/<interface.name; format="cname">_data.h>

#include \<util/log.h>

#include \<stdio.h>

static const byte <interface.name; format="ID"> = <ifaceID>;

<data:{dataType|static const byte <dataType.name; format="ID"> = <dataID.(dataType.name)>;
}>
util_error <prefix>_<interface.name; format="cname">_data_init(
   <prefix>_<interface.name; format="cname">_data * This,
   SOCKET       socket,
   byte         from,
   unsigned     targets_count,
   da_targets * targets       )
{
   UTIL_LOG_HERE();
   This->socket        = socket;
   This->from          = from;
   This->targets_count = targets_count;
   This->targets       = targets;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap( &This->out, <rawSize>, This->raw ));
   return UTIL_NO_ERROR;
}
<data:{dataType|


util_error <prefix>_<interface.name; format="cname">_data_publish_<dataType.name; format="cname">(
   <prefix>_<interface.name; format="cname">_data * This,
   const <types.(dataType.type)> * <dataType.name; format="cname"> )
{
   UTIL_LOG_HERE();
   for( unsigned i = 0; i \< This->targets_count; ++i ) {
      da_targets * targets = This->targets + i;
      for( unsigned j = 0; j \< targets->instances_count; ++j ) {
         byte to = targets->instances[j];
         UTIL_ERROR_CHECK( io_byte_buffer_clear( &This->out ));
         UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <interface.name; format="ID"> ));
         UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, <dataType.name; format="ID"> ));
         UTIL_ERROR_CHECK( io_byte_buffer_put_byte( &This->out, to ));
         UTIL_ERROR_CHECK( <types.(dataType.type)>_put( <dataType.name; format="cname">, &This->out ));
         UTIL_ERROR_CHECK( io_byte_buffer_flip( &This->out ));
         size_t size = 0;
         UTIL_ERROR_CHECK( io_byte_buffer_remaining( &This->out, &size ));
         UTIL_LOG_ARGS( "%u byte(s) sent from instance %d to instance %d @ %s",
            (unsigned)size, This->from, to, inet_ntoa( targets->process.sin_addr ));
         UTIL_ERROR_CHECK( io_datagram_socket_send_to( This->socket, &This->out, &targets->process ));
      \}
   \}
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
\}
}>
>>



automatonHeader( prefix, component ) ::= <<
#pragma once

#include \<<prefix>/<component.name; format="cname">.h>
#include \<util/automaton.h>

void <prefix>_<component.name; format="cname">_automaton_init( util_automaton * automaton, <prefix>_<component.name; format="cname"> * actor );

>>



automatonBody( prefix, component, types ) ::= <<
#include \<<prefix>/<component.name; format="cname">_automaton.h>
#include \<<types.(component.automaton.stateEnum.name); format="typeToPath">.h>
#include \<<types.(component.automaton.eventEnum.name); format="typeToPath">.h>

static util_transition transitions[] = {
   <component.automaton.transition:{transition|{ <
      types.(component.automaton.stateEnum.name); format="ID">_<transition.from ; format="ID">, <
      types.(component.automaton.eventEnum.name); format="ID">_<transition.event; format="ID">, <
      types.(component.automaton.stateEnum.name); format="ID">_<transition.futur; format="ID"> \},
}>};

static util_shortcut shortcuts[] = {
   <component.automaton.shortcut:{shortcut|{ <
      types.(component.automaton.eventEnum.name); format="ID">_<shortcut.event; format="ID">, <
      types.(component.automaton.stateEnum.name); format="ID">_<shortcut.futur; format="ID"> \},
}>};

static util_automaton_state_action on_entry[] = {
   <component.automaton.onEntryOrOnExit:{eoe|< if( eoe.isOnEntry )>{ <
      types.(component.automaton.stateEnum.name); format="ID">_<
      eoe.value.state; format="ID">, (util_automaton_action)&<
      prefix>_<component.name; format="cname">_<eoe.value.action; format="cname"> \},
< endif>}>};

static util_automaton_state_action on_exit[] = {
   <component.automaton.onEntryOrOnExit:{eoe|< if( eoe.isOnExit )>{ <
      types.(component.automaton.stateEnum.name); format="ID">_<
      eoe.value.state; format="ID">, (util_automaton_action)&<
      prefix>_<component.name; format="cname">_<eoe.value.action; format="cname"> \},
< endif>}>};

void <prefix>_<component.name; format="cname">_automaton_init( util_automaton * automaton, <
   prefix>_<component.name; format="cname"> * actor ) {
   UTIL_LOG_HERE();
   automaton->debug           = false;
   automaton->current         = <types.(component.automaton.stateEnum.name); format="ID">_<component.automaton.initial; format="ID">;
   automaton->arcs            = transitions;
   automaton->arcs_count      = sizeof( transitions )/sizeof( transitions[0] );
   automaton->shortcuts       = shortcuts;
   automaton->shortcuts_count = sizeof( shortcuts   )/sizeof( shortcuts  [0] );
   automaton->actor           = actor;
   automaton->on_entry        = on_entry;
   automaton->on_entry_count  = sizeof( on_entry    )/sizeof( on_entry   [0] );
   automaton->on_exit         = on_exit;
   automaton->on_exit_count   = sizeof( on_exit     )/sizeof( on_exit    [0] );
}

>>



componentFactoryHeader( prefix, process, proxies, consumedData, modules, types ) ::= <<
#pragma once
// ComponentFactoryHeader

#include \<io/datagram_socket.h>
#include \<os/thread.h>
<process.instance:{instance|
#include \<<modules.(instance.component)>/<instance.component.name; format="cname">.h\>
}>
typedef struct <prefix>_factory_s {

   SOCKET             socket;
   bool               running;
   os_thread          thread;
   struct sockaddr_in local_addr;

   //-- instances --
<process.instance:{instance|
   <modules.(instance.component)>_<instance.component.name; format="cname"> <instance.name; format="cname">;
}>
   //-- dispatchers --
<process.instance:{instance|
   <modules.(instance.component)>_<instance.component.name; format="cname">_dispatcher <
      instance.name; format="cname">_dispatcher;
}>
   //-- requires --
<proxies:{proxy|
   <proxy.module>_<proxy.interface; format="cname"> <proxy.interface; format="cname">_for_<proxy.from; format="cname">;
}>
} <prefix>_factory;

util_error <prefix>_factory_create ( <prefix>_factory * This );
util_error <prefix>_factory_join   ( <prefix>_factory * This );
util_error <prefix>_factory_destroy( <prefix>_factory * This );

>>



componentFactoryBodyInstancesInit() ::= <<
//-- instances init --
<process.instance:{instance|
UTIL_ERROR_CHECK( <modules.(instance.component)>_<instance.component.name; format="cname">_init( &This-><
      instance.name; format="cname"> ));
}>
>>



factoryInitProxy( ndx, to ) ::= <<
<to:{t|targets[<ndx>].instances[<i0>]    = <prefix; format="ID">_<t; format="ID">;
}>
>>



componentFactoryBodyProxiesInit() ::= <<
//-- proxies init --
<processesImpl:{process|
struct sockaddr_in <process.name; format="cname">;
UTIL_ERROR_CHECK( io_datagram_socket_init( "<process.address>", <process.port>, &<process.name> ));
}><proxies:{proxy|
{
   <proxy.to:{process|
static byte       to<i0>[< length( proxy.to.(process))>];
}>   static da_targets targets[< length( proxy.to )>];
<proxy.to:{process|
   targets[<i0>].process         = <process>;
   targets[<i0>].instances_count = < length(proxy.to.(process))>;
   targets[<i0>].instances       = to<i0>;
}>   <proxy.to:{process|<factoryInitProxy( i0, proxy.to.(process) )
>}>   UTIL_ERROR_CHECK( <proxy.module>_<proxy.interface; format="cname">_init( &This-><
      proxy.interface; format="cname">_for_<proxy.from; format="cname">, This->socket, <prefix; format="ID">_<
      proxy.from; format="ID">, < length(proxy.to)>, targets ));
\}
}>
>>



componentFactoryBodyAutomaton() ::= <<
//-- automaton --
<process.instance:{instance|
< if( instance.component.automaton )>
<modules.(instance.component)>_<instance.component.name; format="cname">_automaton_init( &This-><
   instance.name; format="cname">.automaton, &This-><instance.name; format="cname"> );
< endif>
}>
>>



componentFactoryBodyTimeouts() ::= <<
//-- timeouts --
<process.instance:{instance|
<instance.component.timeout:{to|
static <modules.(instance.component)>_<instance.component.name; format="cname">_dispatcher_timeout_arg timeout_arg_<
to.name; format="cname">_<instance.name; format="cname">;
timeout_arg_<to.name; format="cname">_<instance.name; format="cname">.dispatcher = &This-><instance.name; format="cname">_dispatcher;
timeout_arg_<to.name; format="cname">_<instance.name; format="cname">.event      = <
   modules.(instance.component); format="ID">_<instance.component.name; format="ID">_LOOPBACK_<to.name; format="ID">;
UTIL_ERROR_CHECK( util_timeout_init(
   &This-><instance.name; format="cname">.<to.name; format="cname">,
   <to.duration><to.unit.toCpp>,
   (util_timeout_action)<modules.(instance.component)>_<instance.component.name; format="cname">_dispatcher_loopback,
   &timeout_arg_<to.name; format="cname">_<instance.name; format="cname"> ));
}>}>
>>



componentFactoryBodyDataPublishers() ::= <<
//-- data publishers --
<dataPublishers:{proxy|This-><proxy.from; format="cname">.<proxy.interface; format="cname"> = &This-><
    proxy.interface; format="cname">_for_<proxy.from; format="cname">;}; separator="\n">

>>



componentFactoryBodyInstancesConnect() ::= <<
//-- instances connect --
<process.instance:{instance|
<instance.requires:{pair|
This-><instance.name; format="cname">.<pair.interface.name; format="cname"> = &This-><
    pair.interface.name; format="cname">_for_<instance.name; format="cname">;
}>}>
>>



componentFactoryBodyDispatchers() ::= <<
//-- dispatchers --
<process.instance:{instance|
UTIL_ERROR_CHECK( <modules.(instance.component)>_<instance.component.name; format="cname">_dispatcher_init(
   &This-><instance.name; format="cname">_dispatcher, &This->running, This->socket, <
      prefix; format="ID">_<instance.name; format="ID">, &This->local_addr, &This-><
      instance.name; format="cname"> ));
}>
>>



componentFactoryBody(
    prefix, deployment, deploymentImpl, process, processImpl, processes, processesImpl,
    proxies, dataPublishers, consumedData, types, modules, ids
) ::= <<
// ComponentFactoryBody

#include "factory.h"
#include \<da/targets.h>
<process.instance:{instance|
< if( instance.component.automaton )>
#include \<<modules.(instance.component)>/<instance.component.name; format="cname">_automaton.h><
endif>}>

#include \<io/sockets.h>
#include \<os/sleep.h>
#include \<util/log.h>

#include \<stdio.h>
#include \<string.h>

static util_error <prefix>_factory_run( <prefix>_factory * This ) {
   UTIL_LOG_HERE();
   byte raw[64*1024];
   io_byte_buffer in;
   UTIL_ERROR_CHECK( io_byte_buffer_wrap( &in, sizeof( raw ), raw ));
   This->running = true;
   while( This->running ) {
      UTIL_ERROR_CHECK( io_byte_buffer_clear( &in ) );
      struct sockaddr_in from;
      UTIL_ERROR_CHECK( io_datagram_socket_receive( This->socket, &in, &from ));
      UTIL_ERROR_CHECK( io_byte_buffer_flip( &in ));
      size_t remaining = 0;
      UTIL_ERROR_CHECK( io_byte_buffer_remaining( &in, &remaining ));
      if( remaining >= 3 ) {
         byte intrfc;
         UTIL_ERROR_CHECK( io_byte_buffer_get_byte( &in, &intrfc ));
         byte event;
         UTIL_ERROR_CHECK( io_byte_buffer_get_byte( &in, &event ));
         byte instance;
         UTIL_ERROR_CHECK( io_byte_buffer_get_byte( &in, &instance ));
<process.instance:{instance|
         UTIL_ERROR_CHECK( <modules.(instance.component)>_<
            instance.component.name; format="cname">_dispatcher_before_dispatch( &This-><
            instance.name; format="cname">_dispatcher ));
}>         bool has_dispatched = false;
         while( true ) {
<process.instance:{instance|
            UTIL_ERROR_CHECK( <modules.(instance.component)>_<
               instance.component.name; format="cname">_dispatcher_dispatch( &This-><
               instance.name; format="cname">_dispatcher, intrfc, event, instance, &from, &in, &has_dispatched ));
}>            if( has_dispatched ) {
               break;
            }
            break;
         }
<process.instance:{instance|
         UTIL_ERROR_CHECK( <modules.(instance.component)>_<
            instance.component.name; format="cname">_dispatcher_after_dispatch( &This-><
            instance.name; format="cname">_dispatcher, has_dispatched ));
}>      }
      else {
         UTIL_LOG_ARGS( "3 bytes expected, got only %u", (unsigned)remaining );
      }
   }
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
}

static void * run( void * arg ) {
   <prefix>_factory * This = (<prefix>_factory *)arg;
   <prefix>_factory_run( This );
   This->running = false;
   return NULL;
}

<ids:{instance|#define <prefix; format="ID">_<instance; format="ID"> ((byte)<ids.(instance)>)}; separator="\n">

util_error <prefix>_factory_create( <prefix>_factory * This ) {
   UTIL_LOG_HERE();
   memset( This, 0, sizeof( <prefix>_factory ));
   This->socket = socket( AF_INET, SOCK_DGRAM, 0 );
   UTIL_ASSERT( This->socket > 0 );
   UTIL_ERROR_CHECK( io_datagram_socket_bind( This->socket, "<processImpl.address>", <processImpl.port>, &This->local_addr ));

   <componentFactoryBodyInstancesInit()>
   <componentFactoryBodyProxiesInit()>
   <componentFactoryBodyAutomaton()>
   <componentFactoryBodyTimeouts()>
   <componentFactoryBodyDataPublishers()>
   <componentFactoryBodyInstancesConnect()>
   <componentFactoryBodyDispatchers()>
   UTIL_ERROR_CHECK( os_thread_create( &This->thread, run, This ));
   while( ! This->running ) {
      os_sleep( 100 );
   }
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
}

util_error <prefix>_factory_join( <prefix>_factory * This ) {
   UTIL_LOG_HERE();
   UTIL_ERROR_CHECK( os_thread_join( &This->thread, NULL ));
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
}

util_error <prefix>_factory_destroy( <prefix>_factory * This ) {
   UTIL_LOG_HERE();
   UTIL_ERROR_CHECK( os_thread_destroy( &This->thread ));
   UTIL_LOG_DONE();
   return UTIL_NO_ERROR;
}

>>
