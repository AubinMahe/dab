group CPP;



type( field ) ::= <<
< if(     field.isBoolean )>bool       <
  elseif( field.isByte    )>byte       <
  elseif( field.isShort   )>short      <
  elseif( field.isUshort  )>ushort     <
  elseif( field.isInt     )>int        <
  elseif( field.isUint    )>uint       <
  elseif( field.isLong    )>long       <
  elseif( field.isUlong   )>ulong      <
  elseif( field.isFloat   )>float      <
  elseif( field.isDouble  )>double     <
  elseif( field.isString  )>std::string<
  elseif( field.isEnum    )><field.userType.name><
  elseif( field.isStruct  )><field.userType.name><
  endif>
>>



enumtype( field ) ::= <<
<     if( field.isBoolean )>bool<
  elseif( field.isByte    )>unsigned char<
  elseif( field.isShort   )>short<
  elseif( field.isUshort  )>ushort<
  elseif( field.isInt     )>int<
  elseif( field.isUint    )>unsigned<
  elseif( field.isLong    )>long<
  elseif( field.isUlong   )>unsigned long<
  endif>
>>



pair( field ) ::= <<
<     if( field.isBoolean )>bool<
  elseif( field.isString  )>const std::string &<
  elseif( field.isEnum    )><field.userType.name><
  elseif( field.isDouble  )>const double &<
  elseif( field.isStruct  )>const <field.userType.name> &<
  else                     ><type(field)><
  endif> <field.name>
>>



signature( fields ) ::= <<
< if( ! fields )
     >void<
  else><
     first( fields ):{field|<pair(field)>}><
     rest ( fields ):{field|, <pair(field)>}><
  endif>
>>



args( fields ) ::= <<
< first( fields ):{field|<field.name>}><
  rest ( fields ):{field|, <field.name>}>
>>



byteBufferPut( prefix, fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>_out.putBool( <prefix><field.name> );
< elseif( field.isByte    )>_out.putByte( <prefix><field.name> );
< elseif( field.isShort   )>_out.putShort( <prefix><field.name> );
< elseif( field.isUshort  )>_out.putUShort( <prefix><field.name> );
< elseif( field.isInt     )>_out.putInt( <prefix><field.name> );
< elseif( field.isUint    )>_out.putUInt( <prefix><field.name> );
< elseif( field.isLong    )>_out.putLong( <prefix><field.name> );
< elseif( field.isUlong   )>_out.putULong( <prefix><field.name> );
< elseif( field.isFloat   )>_out.putFloat( <prefix><field.name> );
< elseif( field.isDouble  )>_out.putDouble( <prefix><field.name> );
< elseif( field.isString  )>_out.putString( <prefix><field.name> );
< elseif( field.isEnum    )>_out.putByte( static_cast\<byte>( <prefix><field.name> ));
< elseif( field.isStruct  )><prefix><field.name>.put( _out );
< endif>
}>
>>



structHeader( namespace, struct ) ::= <<
#pragma once

#include \<io/ByteBuffer.hpp>

<struct.field:{field|<
if( field.isStruct || field.isEnum )>
#include \<<namespace>/<type(field)>.hpp><
endif>}>

namespace <namespace> {

   struct <struct.name> {

<struct.field:{field|<
if( field.isString )>
      std::string <field.name>;<
else>
      <type(field)> <field.name>;<
endif>}>

      void put( io::ByteBuffer & target ) const;
      void get( io::ByteBuffer & source );
   };
}
>>



structBody( namespace, struct, maxLength, maxStrLength ) ::= <<
#include \<<namespace>/<struct.name>.hpp>

using namespace <namespace>;

void <struct.name>::put( io::ByteBuffer & target ) const {
<struct.field:{field|
   < if(     field.isBoolean )>target.putBool  ( <field.name> );
   < elseif( field.isByte    )>target.putByte  ( <field.name> );
   < elseif( field.isShort   )>target.putShort ( <field.name> );
   < elseif( field.isUshort  )>target.putUShort( <field.name> );
   < elseif( field.isInt     )>target.putInt   ( <field.name> );
   < elseif( field.isUint    )>target.putUInt  ( <field.name> );
   < elseif( field.isLong    )>target.putLong  ( <field.name> );
   < elseif( field.isUlong   )>target.putULong ( <field.name> );
   < elseif( field.isFloat   )>target.putFloat ( <field.name> );
   < elseif( field.isDouble  )>target.putDouble( <field.name> );
   < elseif( field.isString  )>target.putString( <field.name> );
   < elseif( field.isEnum    )>target.putByte  ((byte)<field.name> );
   < elseif( field.isStruct  )><field.name>.put( target );
   < endif>
}>}

void <struct.name>::get( io::ByteBuffer & source ) {
<struct.field:{field|
   < if(     field.isBoolean )><field.name; format="width"> = source.getBool  ();
   < elseif( field.isByte    )><field.name; format="width"> = source.getByte  ();
   < elseif( field.isShort   )><field.name; format="width"> = source.getShort ();
   < elseif( field.isUshort  )><field.name; format="width"> = source.getUShort();
   < elseif( field.isInt     )><field.name; format="width"> = source.getInt   ();
   < elseif( field.isUint    )><field.name; format="width"> = source.getUInt  ();
   < elseif( field.isLong    )><field.name; format="width"> = source.getLong  ();
   < elseif( field.isUlong   )><field.name; format="width"> = source.getULong ();
   < elseif( field.isFloat   )><field.name; format="width"> = source.getFloat ();
   < elseif( field.isDouble  )><field.name; format="width"> = source.getDouble();
   < elseif( field.isString  )><field.name; format="width"> = source.getString();
   < elseif( field.isEnum    )><field.name; format="width"> = (<field.userType.name>)source.getByte();
   < elseif( field.isStruct  )><field.name>.get( source );
   < endif>
}>}
>>



enumHeader( namespace, enum ) ::= <<
#pragma once

#include \<iostream>

namespace <namespace> {

   enum class <enum.name> : <enumtype( enum )> {
      FIRST,

< first(enum.literal):{literal|
      <literal.name; format="upper"> = FIRST,}>
< rest(enum.literal) :{literal|
      <literal.name; format="upper">,
}>
      LAST
   };
}

std::ostream & operator \<\< ( std::ostream & stream, const <namespace>::<enum.name> & <enum.name; format="lower"> );
>>



enumBody( namespace, enum ) ::= <<
#include \<<namespace>/<enum.name>.hpp>

using namespace <namespace>;

std::ostream & operator \<\< ( std::ostream & stream, const <enum.name> & <enum.name; format="lower"> ) {
   switch( <enum.name; format="lower"> ) {
<enum.literal:{literal|
   case <enum.name>::<literal.name; format="upper">: return stream \<\< "<literal.name; format="upper">"; break;
}>   case <enum.name>::LAST: return stream \<\< "LAST (inutilisé)"; break;
   }
   return stream \<\< "inconnu (" \<\< <enum.name; format="lower"> \<\< ")";
}
>>



requiredInterface( namespace, usedTypes, ifaceName, rawSize, iface ) ::= <<
#pragma once
//requiredInterface
#include \<io/DatagramSocket.hpp>

<usedTypes:{type|#include \<<namespace>/<type>.hpp>
}>
<iface.eventOrRequestOrData:{facet|<if( facet.arguments )>
#include \<<namespace>/<ifaceName><facet.name; format="cap">Response.hpp>
<endif>
}>
namespace <namespace> {

   class I<ifaceName> {
   public:

      I<ifaceName>( void ) = default;
      virtual ~ I<ifaceName>( void ) = default;

   public:

<iface.eventOrRequestOrData:{facet|
< if( facet.type )>
      virtual <type(facet)> & <facet.name>( void ) = 0;
< endif>
      virtual void < if( facet.type )>publish<facet.name; format="cap">< else><facet.name>< endif>( <
if( facet.arguments )><
         signature( facet.arguments.field )><
else><
         signature( facet.field )><
endif> ) = 0;
}>
   private:
      I<ifaceName>( const I<ifaceName> & ) = delete;
      I<ifaceName> & operator = ( const I<ifaceName> & ) = delete;
   };

   I<ifaceName> * new<ifaceName>( io::DatagramSocket & socket, sockaddr_in & target );
}
>>



requiredImplementation( namespace, usedTypes, ifaceName, rawSize, iface, ifaceID ) ::= <<
#include \<<namespace>/I<iface.name>.hpp>
//requiredImplementation
namespace <namespace> {

   class <iface.name> : public ::<namespace>::I<iface.name> {
   public:

      <iface.name>( io::DatagramSocket & socket, sockaddr_in & target ) :
         _socket( socket ),
         _target( target ),
         _out   ( <rawSize> )
      {}

   public:

<iface.eventOrRequestOrData:{facet|

< if( facet.type )>
      virtual <type(facet)> & <facet.name>( void ) {
         return _<facet.name>;
      \}

< endif>
      virtual void < if( facet.type )>publish<facet.name; format="cap">< else><facet.name>< endif>( <
if( facet.arguments )><
    signature( facet.arguments.field )><
else><
    signature( facet.field )><
endif> ) {
         _out.clear();
         _out.putByte( <iface.name; format="ID">_ID );
         _out.putByte( <facet.name; format="ID"> );
         <
if( facet.arguments )><
         byteBufferPut( "", facet.arguments.field )><
elseif( facet.type )><
         byteBufferPut( "_", facet )><
else><
         byteBufferPut( "", facet.field )><
endif>
         _out.flip();
         _socket.sendTo( _out, _target );
      \}

}>   private:

      enum EventID {
< first(iface.eventOrRequestOrData):{facet|
         <facet.name; format="ID"> = 1,}>
< rest(iface.eventOrRequestOrData) :{facet|
         <facet.name; format="ID">,
}>      };

      enum Interface {
         <iface.name; format="ID">_ID = <ifaceID>,
      };

   private:

      io::DatagramSocket & _socket;
      sockaddr_in          _target;
      io::ByteBuffer       _out;
<iface.eventOrRequestOrData:{facet|< if( facet.type )>
      <facet.userType.name> _<facet.name>;
< endif>}>   };
}

namespace <namespace> {

   I<iface.name> * new<iface.name>( io::DatagramSocket & socket, sockaddr_in & target ) {
      return new ::<namespace>::<iface.name>( socket, target );
   }
}
>>



offeredInterface( namespace, name, usedTypes, eventsOrRequests ) ::= <<
#pragma once
//offeredInterface
#include \<string>

#include \<types.hpp>

<usedTypes:{used|
#include \<<namespace>/<used>.hpp>
}>
namespace <namespace> {

   class I<name> {
   public:

      I<name>( void ) = default;
      virtual ~ I<name>( void ) = default;

   public:

<eventsOrRequests:{facet|
      virtual void <facet.name>( <
if( facet.arguments )><
    signature( facet.arguments.field )>, <ifaceName><facet.name; format="cap">Response & response<
else><
    signature( facet.field )><
endif> ) = 0;
}>
   public:

      virtual void run( void ) = 0;

   private:
      I<name>( const I<name> & ) = delete;
      I<name> & operator = ( const I<name> & ) = delete;
   };
}
>>



dispatcherInterface( namespace, name, rawSize ) ::= <<
#pragma once
//dispatcherInterface
#include \<<namespace>/<name>Component.hpp>

#include \<io/ByteBuffer.hpp>
#include \<io/DatagramSocket.hpp>

namespace <namespace> {

   class I<name>Dispatcher {
   public:

      I<name>Dispatcher( void ) = default;
      virtual ~ I<name>Dispatcher( void ) = default;

   public:

      virtual bool hasDispatched( void ) = 0;
   };

   I<name>Dispatcher * new<name>Dispatcher( io::DatagramSocket & socket, <name>Component & listener );
}
>>



dispatcherImplOneInterface( name, ifaceName ) ::= <<
//dispatcherImplOneInterface

enum class <ifaceName>Event : byte {
<  first( events.(ifaceName)):{event|   <event.name; format="ID"> = 1,
}>< rest( events.(ifaceName)):{event|   <event.name; format="ID">,
}>\};

bool dispatch( <ifaceName>Event event ) {
   switch( event ) {
<events.(ifaceName):{event|
   case <ifaceName>Event::<event.name; format="ID">:{
      <event.field:{field|
<     if( field.isBoolean )>bool <field.name> = _in.getBool();
< elseif( field.isByte    )>byte <field.name> = _in.getByte();
< elseif( field.isShort   )>short <field.name> = _in.getShort();
< elseif( field.isUshort  )>ushort <field.name> = _in.getUShort();
< elseif( field.isInt     )>int <field.name> = _in.getInt();
< elseif( field.isUint    )>uint <field.name> = _in.getUInt();
< elseif( field.isLong    )>long <field.name> = _in.getLong();
< elseif( field.isUlong   )>ulong <field.name> = _in.getULong();
< elseif( field.isFloat   )>float <field.name> = _in.getFloat();
< elseif( field.isDouble  )>double <field.name> = _in.getDouble();
< elseif( field.isString  )>std::string <field.name> = _in.getString();                            
< elseif( field.isEnum    )><field.userType.name> <field.name> = _in.getByte();
< elseif( field.isStruct  )><field.userType.name> <field.name>;
<field.name>.get( _in );
< endif>
}>      _listener.<event.name>( <args( event.field )> );
      break;
      \}
}>   default:
      std::cerr
         \<\< "<name>Dispatcher.dispatch|Message reçu ignoré"
         \<\< ", interface = <ifaceName>"
         \<\< ", event = " \<\< event
         \<\< std::endl;
      return false;
   \}
   return true;
}

friend std::ostream & operator \<\< ( std::ostream & stream, <ifaceName>Event e ) {
   switch( e ) {
<events.(ifaceName):{event|
   case <ifaceName>Event::<event.name; format="ID,width">: return stream \<\< "<event.name; format="ID">";
}>   }
   return stream \<\< "???";
}
>>

dispatcherImplementation( namespace, compName, ifaces, events, usedTypes, rawSize ) ::= <<
//dispatcherImplementation
#include \<<namespace>/I<compName>Dispatcher.hpp>
#include \<<namespace>/<compName>Component.hpp>

#include \<iostream>

namespace <namespace> {

   class <compName>Dispatcher : public ::<namespace>::I<compName>Dispatcher {
   private:

      enum class Interface : byte {
<ifaces.keys:{ifaceName|
         <ifaceName; format="ID,width"> = <ifaces.(ifaceName)>,
}>      };

      friend std::ostream & operator \<\< ( std::ostream & stream, Interface e ) {
         switch( e ) {
<ifaces.keys:{ifaceName|
         case Interface::<ifaceName; format="ID,width">: return stream \<\< "<ifaceName; format="ID,width">";
}>         }
         return stream \<\< "???";
      }
      <ifaces.keys:{ifaceName|<dispatcherImplOneInterface( compName, ifaceName )>}>

   public:

      <compName>Dispatcher( io::DatagramSocket & socket, <compName>Component & listener ) :
         _socket  ( socket ),
         _listener( listener ),
         _in      ( <rawSize> )
      {}

   public:

      bool hasDispatched( void ) {
         _in.clear();
         if( _socket.receive( _in )) {
            _in.flip();
            Interface interface = static_cast\<Interface>( _in.getByte());
            byte      event     = _in.getByte();
            std::cerr
               \<\< "<compName>Dispatcher.hasDispatched|"
               \<\< "interface = " \<\< interface
               \<\< " ("           \<\< (int)interface \<\< ')'
               \<\< ", event: "    \<\< (int)event
               \<\< std::endl;
            switch( interface ) {
<ifaces.keys:{ifaceName|
            case Interface::<ifaceName; format="ID,width">: return dispatch( static_cast\<<ifaceName>Event>( event ));
}>
            }
         }
         return false;
      }

   private:

      io::DatagramSocket & _socket;
      <compName>Component & _listener;
      io::ByteBuffer _in;
   };
}

namespace <namespace> {

   I<compName>Dispatcher * new<compName>Dispatcher( io::DatagramSocket & socket, <compName>Component & listener ) {
      return new ::<namespace>::<compName>Dispatcher( socket, listener );
   }
}
>>



componentInterface( namespace, component, responses, requires, instancesByName, instances, actions ) ::= <<
#pragma once
//componentInterface
<component.offers:{offered|#include \<<namespace>/I<offered.interface.name>.hpp>
}>
<component.requires:{required|#include \<<namespace>/I<required.interface.name>.hpp>
}>
<responses.(component.name):{r|#include \<<namespace>/<r.interface.name>.hpp>
}>
#include \<io/DatagramSocket.hpp>

< if( component.automaton )>#include \<<namespace>/Automaton.hpp>< endif>

namespace <namespace> {

   class I<component.name>Dispatcher;

   class <component.name>Component : <
first(component.offers):{ offered  |public I<offered.interface.name>}><
rest (component.offers):{ offered|, public I<offered.interface.name>}><
responses.(component.name):{r    |, public I<r.interface.name>}> {
   public:

      <component.name>Component( const std::string & name );

   protected:

      virtual void afterDispatch( void ) = 0;

   public:

<actions:{action|
      virtual void <action>( void ) = 0;
}>
   protected:

      void terminate();

   public:

      void run();

   private:

      io::DatagramSocket _socket;
      bool               _running;
      I<component.name>Dispatcher * _dispatcher;

   protected:
< if( component.automaton )>      Automaton _automaton;
< endif>< first(requires):{req|<requires.(req):{rt|
      I<rt.interface.name> * _<rt.interface.name; format="argument">;
}>}>   };
}
>>



componentImplementation( namespace, component, responses, requires, instancesByName, instances ) ::= <<
//componentImplementation
#include \<<namespace>/<component.name>Component.hpp>
#include \<<namespace>/I<component.name>Dispatcher.hpp>

#include  \<stdexcept>

using namespace <namespace>;

<component.name>Component::<component.name>Component( const std::string & name ) :
   _running   ( false ),
   _dispatcher( 0     ),
   _automaton ( *this )< first(requires):{req|<requires.(req):{rt|,
   _<rt.interface.name; format="argument">( 0 )}>}>
{< if( requires )>
   sockaddr_in < first(requires):{req|<
      first( requires.(req) ):{rt|<rt.interface.name; format="argument">}><
      rest ( requires.(req) ):{rt|, <rt.interface.name; format="argument">}>}>;
< endif>
< first(instances):{instance|
   if( name == "<instance.name>" ) {
      _socket.bind( "<instance.address>", <instance.port> );
      <requires.(instance.name):{req|io::DatagramSocket::init( "<
         instancesByName.(req.toInstance.name).address>", <
         instancesByName.(req.toInstance.name).port>, <
         req.interface.name; format="argument"> );
}>}>< rest(instances):{instance|
  \}
  else if( name == "<instance.name>" ) {
      _socket.bind( "<instance.address>", <instance.port> );
      <requires.(instance.name):{req|io::DatagramSocket::init( "<
         instancesByName.(req.toInstance.name).address>", <
         instancesByName.(req.toInstance.name).port>, <
         req.interface.name; format="argument"> );
}>}>   }
   else {
      throw std::invalid_argument( "'" + name + "' isn't a valid name defined in XML application file!" );
   }
   < first(requires):{req|<
      requires.(req):{rt|_<rt.interface.name; format="argument"
         > = new<rt.interface.name>( _socket, <rt.interface.name; format="argument"> );
}>}>   _dispatcher = new<component.name>Dispatcher( _socket, *this );
}

void <component.name>Component::terminate() {
   _running = false;
}

void <component.name>Component::run() {
   _running = true;
   while( _running ) {
      if( _dispatcher->hasDispatched()) {
         afterDispatch();
      }
   }
}
>>



automatonHeader( namespace, component ) ::= <<
#pragma once

#include \<util/Automaton.hpp>

#include \<<namespace>/<component.automaton.stateEnum.name>.hpp>
#include \<<namespace>/<component.automaton.eventEnum.name>.hpp>

namespace <namespace> {

   class <component.name>Component;
   class Automaton : public util::Automaton\<<
      component.name>Component, <
      component.automaton.stateEnum.name>, <
      component.automaton.eventEnum.name>\> {
   public:

      Automaton( <component.name>Component & component );

   private:
      Automaton( const Automaton & ) = delete;
      Automaton & operator = ( const Automaton & ) = delete;
   };
}
>>



automatonBody( namespace, component ) ::= <<
#include "Automaton.hpp"
#include \<<namespace>/<component.name>Component.hpp>

using namespace <namespace>;

Automaton :: Automaton( <component.name>Component & component ) :
   util::Automaton\<<
      component.name>Component, <
      component.automaton.stateEnum.name>, <
      component.automaton.eventEnum.name>\>( component, <
         component.automaton.stateEnum.name>::<component.automaton.initial> )
{
   <component.automaton.transition:{transition|add( <
      component.automaton.stateEnum.name>::<transition.from>, <
      component.automaton.eventEnum.name>::<transition.event>, <
      component.automaton.stateEnum.name>::<transition.futur> );
}>
   <component.automaton.shortcut:{shortcut|add( <
      component.automaton.eventEnum.name>::<shortcut.event>, <
      component.automaton.stateEnum.name>::<shortcut.futur> );
}>
   <component.automaton.onEntryOrOnExit:{elt|add<elt.name.localPart; format="UpperCamelCase">( <
      component.automaton.stateEnum.name>::<elt.value.state>, &<component.name>Component::<elt.value.action> );
}>}
>>
