group CPP;



type( field ) ::= <<
< if(     field.isBoolean )>bool<
  elseif( field.isByte    )>byte<
  elseif( field.isShort   )>short<
  elseif( field.isUshort  )>unsigned short<
  elseif( field.isInt     )>int<
  elseif( field.isUint    )>unsigned int<
  elseif( field.isLong    )>int64_t<
  elseif( field.isUlong   )>uint64_t<
  elseif( field.isFloat   )>float<
  elseif( field.isDouble  )>double<
  elseif( field.isString  )>char<
  elseif( field.isEnum    )><field.userType.name><
  elseif( field.isStruct  )><field.userType.name><
  endif>
>>



enumtype( field ) ::= <<
<     if( field.isBoolean )>bool<
  elseif( field.isByte    )>unsigned char<
  elseif( field.isShort   )>short<
  elseif( field.isUshort  )>unsigned short<
  elseif( field.isInt     )>int<
  elseif( field.isUint    )>unsigned<
  elseif( field.isLong    )>int64_t<
  elseif( field.isUlong   )>uint64_t<
  endif>
>>



pair( field ) ::= <<
<     if( field.isBoolean )>bool<
  elseif( field.isString  )>const char *<
  elseif( field.isEnum    )><field.userType.name><
  elseif( field.isDouble  )>const double &<
  elseif( field.isStruct  )>const <field.userType.name> &<
  else                     ><type(field)><
  endif> <field.name>
>>



signature( fields ) ::= <<
< if( ! fields )
     >void<
  else><
     first( fields ):{field|<pair(field)>}><
     rest ( fields ):{field|, <pair(field)>}><
  endif>
>>



args( fields ) ::= <<
< first( fields ):{field|<field.name>}><
  rest ( fields ):{field|, <field.name>}>
>>



byteBufferPut( prefix, fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>_out.putBool( <prefix><field.name> );
< elseif( field.isByte    )>_out.putByte( <prefix><field.name> );
< elseif( field.isShort   )>_out.putShort( <prefix><field.name> );
< elseif( field.isUshort  )>_out.putUShort( <prefix><field.name> );
< elseif( field.isInt     )>_out.putInt( <prefix><field.name> );
< elseif( field.isUint    )>_out.putUInt( <prefix><field.name> );
< elseif( field.isLong    )>_out.putLong( <prefix><field.name> );
< elseif( field.isUlong   )>_out.putULong( <prefix><field.name> );
< elseif( field.isFloat   )>_out.putFloat( <prefix><field.name> );
< elseif( field.isDouble  )>_out.putDouble( <prefix><field.name> );
< elseif( field.isString  )>_out.putString( <prefix><field.name> );
< elseif( field.isEnum    )>_out.putByte( static_cast\<byte>( <prefix><field.name> ));
< elseif( field.isStruct  )><prefix><field.name>.put( _out );
< endif>
}>
>>



structHeader( namespace, struct ) ::= <<
#pragma once

#include \<io/ByteBuffer.hpp>

<struct.field:{field|<
if( field.isStruct || field.isEnum )>
#include \<<namespace>/<type(field)>.hpp><
endif>}>

namespace <namespace> {

   struct <struct.name> {

<struct.field:{field|<
if( field.isString )>
      char <field.name>[<field.length> + 1];<
else>
      <type(field)> <field.name>;<
endif>}>

      void put( io::ByteBuffer & target ) const;
      void get( io::ByteBuffer & source );
   };
}
>>



structBody( namespace, struct, maxLength, maxStrLength ) ::= <<
#include \<<namespace>/<struct.name>.hpp>

using namespace <namespace>;

void <struct.name>::put( io::ByteBuffer & target ) const {
<struct.field:{field|
   < if(     field.isBoolean )>target.putBool  ( <field.name> );
   < elseif( field.isByte    )>target.putByte  ( <field.name> );
   < elseif( field.isShort   )>target.putShort ( <field.name> );
   < elseif( field.isUshort  )>target.putUShort( <field.name> );
   < elseif( field.isInt     )>target.putInt   ( <field.name> );
   < elseif( field.isUint    )>target.putUInt  ( <field.name> );
   < elseif( field.isLong    )>target.putLong  ( <field.name> );
   < elseif( field.isUlong   )>target.putULong ( <field.name> );
   < elseif( field.isFloat   )>target.putFloat ( <field.name> );
   < elseif( field.isDouble  )>target.putDouble( <field.name> );
   < elseif( field.isString  )>target.putString( <field.name> );
   < elseif( field.isEnum    )>target.putByte  ((byte)<field.name> );
   < elseif( field.isStruct  )><field.name>.put( target );
   < endif>
}>}

void <struct.name>::get( io::ByteBuffer & source ) {
<struct.field:{field|
   < if(     field.isBoolean )><field.name; format="width"> = source.getBool  ();
   < elseif( field.isByte    )><field.name; format="width"> = source.getByte  ();
   < elseif( field.isShort   )><field.name; format="width"> = source.getShort ();
   < elseif( field.isUshort  )><field.name; format="width"> = source.getUShort();
   < elseif( field.isInt     )><field.name; format="width"> = source.getInt   ();
   < elseif( field.isUint    )><field.name; format="width"> = source.getUInt  ();
   < elseif( field.isLong    )><field.name; format="width"> = source.getLong  ();
   < elseif( field.isUlong   )><field.name; format="width"> = source.getULong ();
   < elseif( field.isFloat   )><field.name; format="width"> = source.getFloat ();
   < elseif( field.isDouble  )><field.name; format="width"> = source.getDouble();
   < elseif( field.isString  )>source.getString( <
                                  field.name; format="strWidth">, sizeof( <field.name; format="strWidth"> ));
   < elseif( field.isEnum    )><field.name; format="width"> = (<field.userType.name>)source.getByte();
   < elseif( field.isStruct  )><field.name>.get( source );
   < endif>
}>}
>>



enumHeader( namespace, enum ) ::= <<
#pragma once

namespace <namespace> {

   enum class <enum.name> : <enumtype( enum )> {
      FIRST,

< first(enum.literal):{literal|
      <literal.name; format="upper"> = FIRST,}>
< rest(enum.literal) :{literal|
      <literal.name; format="upper">,
}>
      LAST
   };

   const char * toString( const <enum.name> & enm );
}
>>



enumBody( namespace, enum ) ::= <<
#include \<<namespace>/<enum.name; format="cname">.hpp>

namespace <namespace> {
   
   const char * toString( const <enum.name> & enm ) {
      switch( enm ) {
      <enum.literal:{literal|case <enum.name>::<literal.name; format="upper,width">: return "<literal.name; format="upper">";
}>      case <enum.name>::LAST: return "LAST";
      }
      return "???";
   }
}
>>



requiredInterface( namespace, usedTypes, ifaceName, rawSize, iface, ifaceID ) ::= <<
#pragma once
//requiredInterface
#include \<io/DatagramSocket.hpp>

<usedTypes:{type|#include \<<namespace>/<type>.hpp>
}>
<iface.eventOrRequestOrData:{facet|<if( facet.arguments )>
#include \<<namespace>/<ifaceName><facet.name; format="cap">Response.hpp>
<endif>
}>
namespace <namespace> {

   class <ifaceName> {
   public:

      <ifaceName>( io::DatagramSocket & socket, const sockaddr_in & target );

   public:

<iface.eventOrRequestOrData:{facet|
< if( facet.type )>
      <type(facet)> & <facet.name>( void ) {
         return _<facet.name>;
      \}

< endif>
      void < if( facet.type )>publish<facet.name; format="cap">< else><facet.name>< endif>( <
if( facet.arguments )><
         signature( facet.arguments.field )><
else><
         signature( facet.field )><
endif> );
}>
   private:

      enum EventID {
< first(iface.eventOrRequestOrData):{facet|
         <facet.name; format="ID"> = 1,}>
< rest(iface.eventOrRequestOrData) :{facet|
         <facet.name; format="ID">,
}>      };

      enum Interface {
         <iface.name; format="ID">_ID = <ifaceID>,
      };

   private:

      byte                 _raw[<rawSize>];
      io::DatagramSocket & _socket;
      sockaddr_in          _target;
      io::ByteBuffer       _out;
<iface.eventOrRequestOrData:{facet|< if( facet.type )>
      <facet.userType.name> _<facet.name>;< endif>}>

   private:
      <ifaceName>( const <ifaceName> & ) = delete;
      <ifaceName> & operator = ( const <ifaceName> & ) = delete;
   };
}
>>



requiredImplementation( namespace, usedTypes, ifaceName, rawSize, iface, ifaceID ) ::= <<
#include \<<namespace>/<iface.name>.hpp>
//requiredImplementation
using namespace <namespace>;

<iface.name>::<iface.name>( io::DatagramSocket & socket, const sockaddr_in & target ) :
   _socket( socket ),
   _target( target ),
   _out   ( _raw, <rawSize> )
{}
<iface.eventOrRequestOrData:{facet|


void <iface.name>::< if( facet.type )>publish<facet.name; format="cap">< else><facet.name>< endif>( <
if( facet.arguments )><
    signature( facet.arguments.field )><
else><
    signature( facet.field )><
endif> ) {
   _out.clear();
   _out.putByte( <iface.name; format="ID">_ID );
   _out.putByte( <facet.name; format="ID"> );
   <
if( facet.arguments )><
   byteBufferPut( "", facet.arguments.field )><
elseif( facet.type )><
   byteBufferPut( "_", facet )><
else><
   byteBufferPut( "", facet.field )><
endif>
   _out.flip();
   _socket.sendTo( _out, _target );
\}
}>
>>



offeredInterface( namespace, name, usedTypes, eventsOrRequests ) ::= <<
#pragma once
//offeredInterface
#include \<types.hpp>

<usedTypes:{used|
#include \<<namespace>/<used>.hpp>
}>
namespace <namespace> {

   class I<name> {
   public:

      I<name>( void ) = default;
      virtual ~ I<name>( void ) = default;

   public:

<eventsOrRequests:{facet|
      virtual void <facet.name>( <
if( facet.arguments )><
    signature( facet.arguments.field )>, <ifaceName><facet.name; format="cap">Response & response<
else><
    signature( facet.field )><
endif> ) = 0;
}>
   public:

      virtual void run( void ) = 0;

   private:
      I<name>( const I<name> & ) = delete;
      I<name> & operator = ( const I<name> & ) = delete;
   };
}
>>



dispatcherInterface( namespace, component, ifaces, events, rawSize ) ::= <<
#pragma once
//dispatcherInterface
#include \<io/DatagramSocket.hpp>
#include \<io/ByteBuffer.hpp>

namespace <namespace> {

   class <component.name>Component;
   class <component.name>Dispatcher {
   public:

      <component.name>Dispatcher( io::DatagramSocket & socket, <component.name>Component & listener );

   public:

      bool hasDispatched( void );
< if( component.timeout )>

      enum class LoopbackEvent : byte {
<  first( component.timeout):{to|         <to.name; format="ID"> = 1,
}>< rest( component.timeout):{to|         <to.name; format="ID">,
}>      \};

      void loopback( const LoopbackEvent & event );
< endif>

   private:

      enum class Interface : byte {
         < if( component.timeout )>LOOPBACK = 0,
< endif><ifaces.keys:{ifaceName|
         <ifaceName; format="ID,width"> = <ifaces.(ifaceName)>,
}>      };
<ifaces.keys:{ifaceName|


      enum class <ifaceName>Event : byte {
<  first( events.(ifaceName)):{event|         <event.name; format="ID"> = 1,
}>< rest( events.(ifaceName)):{event|         <event.name; format="ID">,
}>      \};

      bool dispatch( <ifaceName>Event event );
}>< if( component.timeout )>
      bool dispatch( LoopbackEvent event );

< endif>
   private:

      byte                 _raw[<rawSize>];
      io::DatagramSocket & _socket;
      io::ByteBuffer       _in;
      <component.name>Component & _listener;
   };
}
>>



dispatcherImplementation( namespace, component, ifaces, events, usedTypes ) ::= <<
//dispatcherImplementation
#include \<<namespace>/<component.name>Dispatcher.hpp>
#include \<<namespace>/<component.name>Component.hpp>

using namespace <namespace>;

<component.name>Dispatcher::<component.name>Dispatcher( io::DatagramSocket & socket, <component.name>Component & listener ) :
   _socket  ( socket ),
   _in      ( _raw, sizeof( _raw )),
   _listener( listener )
{}
<ifaces.keys:{ifaceName|


bool <component.name>Dispatcher::dispatch( <ifaceName>Event event ) {
   switch( event ) {
<events.(ifaceName):{event|
   case <ifaceName>Event::<event.name; format="ID">:{
      <event.field:{field|
<     if( field.isBoolean )>bool <field.name> = _in.getBool();
< elseif( field.isByte    )>byte <field.name> = _in.getByte();
< elseif( field.isShort   )>short <field.name> = _in.getShort();
< elseif( field.isUshort  )>unsigned short <field.name> = _in.getUShort();
< elseif( field.isInt     )>int <field.name> = _in.getInt();
< elseif( field.isUint    )>unsigned int <field.name> = _in.getUInt();
< elseif( field.isLong    )>int64_t <field.name> = _in.getLong();
< elseif( field.isUlong   )>uint64_t <field.name> = _in.getULong();
< elseif( field.isFloat   )>float <field.name> = _in.getFloat();
< elseif( field.isDouble  )>double <field.name> = _in.getDouble();
< elseif( field.isString  )>char <field.name>[<field.length> + 1];
_in.getString( <field.name>, sizeof( <field.name> ));
< elseif( field.isEnum    )><field.userType.name> <field.name> = _in.getByte();
< elseif( field.isStruct  )><field.userType.name> <field.name>;
<field.name>.get( _in );
< endif>
}>      _listener.<event.name>( <args( event.field )> );
      break;
      \}
}>   default:
      fprintf( stderr, "<component.name>Dispatcher.dispatch|Unknown <ifaceName>'s event: %d\n", (byte)event );
      return false;
   \}
   return true;
\}
}>
< if( component.timeout )>
bool <component.name>Dispatcher::dispatch( LoopbackEvent event ) {
   switch( event ) {
   <component.timeout:{to|case LoopbackEvent::<to.name; format="ID">: _listener.<to.name; format="argument">Elapsed(); break;
}>   default:
      fprintf( stderr, "<component.name>Dispatcher.dispatch|Unknown timeout's event: %d\n", (byte)event );
      return false;
   \}
   return true;
\}

< endif>
bool <component.name>Dispatcher::hasDispatched( void ) {
   _in.clear();
   if( _socket.receive( _in )) {
      _in.flip();
      byte interface = _in.getByte();
      byte event     = _in.getByte();
      switch( static_cast\<Interface>( interface)) {< if( component.timeout )>
      case Interface::LOOPBACK: return dispatch( static_cast\<LoopbackEvent>( event ));
< endif>
<ifaces.keys:{ifaceName|
      case Interface::<ifaceName; format="ID,width">: return dispatch( static_cast\<<ifaceName>Event>( event ));
}>      default:
           fprintf( stderr, "<component.name>Dispatcher.dispatch|Unknown interface: %d\n", interface );
      }
   }
   return false;
}
< if( component.timeout )>

void <component.name>Dispatcher::loopback( const LoopbackEvent & event ) {
   byte           raw[2];
   io::ByteBuffer out( raw, sizeof( raw ));
   out.putByte((byte)Interface::LOOPBACK );
   out.putByte((byte)event );
   out.flip();
   _socket.sendTo( out, _socket.getLocalAddress());
}
< endif>
>>



componentInterface( namespace, component, responses, requires, instancesByName, instances, actions ) ::= <<
#pragma once
//componentInterface
#include \<io/DatagramSocket.hpp>

<component.offers:{offered|#include \<<namespace>/I<offered.interface.name>.hpp>
}>
<component.requires:{required|#include \<<namespace>/<required.interface.name>.hpp>
}>
<responses.(component.name):{r|#include \<<namespace>/<r.interface.name>.hpp>
}>
#include \<<namespace>/<component.name>Dispatcher.hpp>
< if( component.timeout )>

#include \<util/Timeout.hpp>
< endif>< if( component.automaton )>

#include \<<namespace>/Automaton.hpp>
< endif>

namespace <namespace> {

   class <component.name>Component : <
first(component.offers):{ offered  |public I<offered.interface.name>}><
rest (component.offers):{ offered|, public I<offered.interface.name>}><
responses.(component.name):{r    |, public I<r.interface.name>}> {
   public:

      <component.name>Component( const char * name );

   public:

      void run();
< if( actions )>

   public:

<actions:{action|
      virtual void <action>( void ) = 0;
}>
< endif><component.timeout:{to|
      virtual void <to.name>Elapsed( void ) = 0;
}>
   protected:< if( component.afterDispatchNeeded )>

      virtual void afterDispatch( void ) = 0;
< endif>

      void terminate();

      void loopback( const <component.name>Dispatcher::LoopbackEvent & event );

   private:

      io::DatagramSocket _socket;
      bool               _running;

      <component.name>Dispatcher _dispatcher;

   protected:

< if( component.automaton )>      Automaton _automaton;
< endif>
<component.timeout:{to|       util::TimeoutCallback _<to.name>;
}>< first(requires):{req|<requires.(req):{rt|
      <rt.interface.name> _<rt.interface.name; format="argument">;
}>}>   };
}
>>



componentImplementation( namespace, component, responses, requires, instancesByName, instances ) ::= <<
//componentImplementation
#include \<<namespace>/<component.name>Component.hpp>
#include \<<namespace>/<component.name>Dispatcher.hpp>

#include  \<string.h>

#include  \<util/Exceptions.hpp>

using namespace <namespace>;
< first(requires):{req|<requires.(req):{rt|


static sockaddr_in & init<rt>SocketAddress( const char * name ) {
   static sockaddr_in address;
< first(instances):{instance|
   if( 0 == strcmp( name, "<instance.name>" )) {
      io::DatagramSocket::init( "<
         requires.(instance.name).(rt).toInstance.address>", <
         requires.(instance.name).(rt).toInstance.port>, address );
}>< rest(instances):{instance|
   \}
   else if( 0 == strcmp( name, "<instance.name>" )) {
      io::DatagramSocket::init( "<
         requires.(instance.name).(rt).toInstance.address>", <
         requires.(instance.name).(rt).toInstance.port>, address );
   \}
}>   else {
      throw util::NotApplicable( UTIL_CTXT, "'%s' isn't a valid name as defined in XML application file!", name );
   \}
   return address;
\}}>}>

<component.name>Component::<component.name>Component( const char * name ) :
   _running   ( false ),
   _dispatcher( _socket, *this ),
   _automaton ( *this )<component.timeout:{to|,
   _<to.name; format="argument">( <to.duration><to.unit.toCpp>, [this](){ _dispatcher.loopback( <
      component.name>Dispatcher::LoopbackEvent::<to.name; format="ID"> ); \})}><
   first(requires):{req|<requires.(req):{rt|,
   _<rt; format="argument">( _socket, init<rt>SocketAddress( name ))}>}>
{
< first(instances):{instance|
   if( 0 == strcmp( name, "<instance.name>" )) {
      _socket.bind( "<instance.address>", <instance.port> );
}>< rest(instances):{instance|
   \}
   else if( 0 == strcmp( name, "<instance.name>" )) {
      _socket.bind( "<instance.address>", <instance.port> );
}>   }
}

void <component.name>Component::terminate() {
   _running = false;
}

void <component.name>Component::loopback( const <component.name>Dispatcher::LoopbackEvent & event ) {
   _dispatcher.loopback( event );
}

void <component.name>Component::run() {
   _running = true;
   while( _running ) {
      if( _dispatcher.hasDispatched()) {< if( component.afterDispatchNeeded )>
         afterDispatch();
< endif>
      }
   }
}
>>



automatonHeader( namespace, component ) ::= <<
#pragma once

#include \<util/Automaton.hpp>

#include \<<namespace>/<component.automaton.stateEnum.name>.hpp>
#include \<<namespace>/<component.automaton.eventEnum.name>.hpp>

namespace <namespace> {

   class <component.name>Component;
   class Automaton : public util::Automaton\<<
      component.name>Component, <
      component.automaton.stateEnum.name>, <
      component.automaton.eventEnum.name>\> {
   public:

      Automaton( <component.name>Component & component );

   private:
      Automaton( const Automaton & ) = delete;
      Automaton & operator = ( const Automaton & ) = delete;
   };
}
>>



automatonBody( namespace, component ) ::= <<
#include "Automaton.hpp"
#include \<<namespace>/<component.name>Component.hpp>

using namespace <namespace>;

Automaton :: Automaton( <component.name>Component & component ) :
   util::Automaton\<<
      component.name>Component, <
      component.automaton.stateEnum.name>, <
      component.automaton.eventEnum.name>\>( component, <
         component.automaton.stateEnum.name>::<component.automaton.initial> )
{
   static Transition transitions[] = {<component.automaton.transition:{tr|

      { <component.automaton.stateEnum.name>::<tr.from>, <
         component.automaton.eventEnum.name>::<tr.event>, <
         component.automaton.stateEnum.name>::<tr.futur> \},
}>   };
   setTransitions( transitions, sizeof(transitions)/sizeof(transitions[0]));

   static Shortcut shortcuts[] = {<component.automaton.shortcut:{shortcut|

      { <component.automaton.eventEnum.name>::<shortcut.event>, <
         component.automaton.stateEnum.name>::<shortcut.futur> \},
}>   };
   setShortcuts( shortcuts, sizeof(shortcuts)/sizeof(shortcuts[0]));

   static Action onEntries[] = {<component.automaton.onEntryOrOnExit:{elt|< if( elt.isOnEntry )>
      { <component.automaton.stateEnum.name>::<elt.value.state>, &<component.name>Component::<elt.value.action> \},< endif>
}>
   };
   setOnEntries( onEntries, sizeof(onEntries)/sizeof(onEntries[0]));

   static Action onExits[] = {<component.automaton.onEntryOrOnExit:{elt|< if( elt.isOnExit )>
      { <component.automaton.stateEnum.name>::<elt.value.state>, &<component.name>Component::<elt.value.action> \},< endif>
}>
   };
   setOnExits( onExits, sizeof(onExits)/sizeof(onExits[0]));
}
>>
