group CPP;



concat(a,b) ::= <<
<a><b>
>>



type( field ) ::= <<
< if(     field.isBoolean )>bool<
  elseif( field.isByte    )>byte<
  elseif( field.isShort   )>short<
  elseif( field.isUshort  )>unsigned short<
  elseif( field.isInt     )>int<
  elseif( field.isUint    )>unsigned int<
  elseif( field.isLong    )>int64_t<
  elseif( field.isUlong   )>uint64_t<
  elseif( field.isFloat   )>float<
  elseif( field.isDouble  )>double<
  elseif( field.isString  )>char<
  elseif( field.isEnum    )><types.(field.userType)><
  elseif( field.isStruct  )><types.(field.userType)><
  endif>
>>



enumtype( field ) ::= <<
<     if( field.isBoolean )>bool<
  elseif( field.isByte    )>unsigned char<
  elseif( field.isShort   )>short<
  elseif( field.isUshort  )>unsigned short<
  elseif( field.isInt     )>int<
  elseif( field.isUint    )>unsigned<
  elseif( field.isLong    )>int64_t<
  elseif( field.isUlong   )>uint64_t<
  endif>
>>



pair( field ) ::= <<
<     if( field.isBoolean )>bool<
  elseif( field.isString  )>const char *<
  elseif( field.isDouble  )>const double &<
  elseif( field.isEnum    )><typesNamespace>::<field.userType.name><
  elseif( field.isStruct  )>const <typesNamespace>::<field.userType.name> &<
  else                     ><type(field)><
  endif> <field.name>
>>



signature( fields ) ::= <<
< if( ! fields )
     >void<
  else><
     first( fields ):{field|<pair(field)>}><
     rest ( fields ):{field|, <pair(field)>}><
  endif>
>>



args( fields ) ::= <<
< first( fields ):{field|<field.name>}><
  rest ( fields ):{field|, <field.name>}>
>>



byteBufferPut( prefix, fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>_out.putBool( <prefix><field.name> );
< elseif( field.isByte    )>_out.putByte( <prefix><field.name> );
< elseif( field.isShort   )>_out.putShort( <prefix><field.name> );
< elseif( field.isUshort  )>_out.putUShort( <prefix><field.name> );
< elseif( field.isInt     )>_out.putInt( <prefix><field.name> );
< elseif( field.isUint    )>_out.putUInt( <prefix><field.name> );
< elseif( field.isLong    )>_out.putLong( <prefix><field.name> );
< elseif( field.isUlong   )>_out.putULong( <prefix><field.name> );
< elseif( field.isFloat   )>_out.putFloat( <prefix><field.name> );
< elseif( field.isDouble  )>_out.putDouble( <prefix><field.name> );
< elseif( field.isString  )>_out.putString( <prefix><field.name> );
< elseif( field.isEnum    )>_out.putByte( static_cast\<byte>( <prefix><field.name> ));
< elseif( field.isStruct  )><prefix><field.name>.put( _out );
< endif>
}>
>>



enumHeader( namespace, enum ) ::= <<
#pragma once

namespace <namespace> {

   enum class <enum.name> : <enumtype( enum )> {
      FIRST,

< first(enum.literal):{literal|
      <literal.name; format="upper"> = FIRST,}>
< rest(enum.literal) :{literal|
      <literal.name; format="upper">,
}>
      LAST
   };

   const char * toString( const <enum.name> & enm );
}
>>



enumBody( namespace, enum ) ::= <<
#include \<<namespace>/<enum.name; format="cname">.hpp>

namespace <namespace> {
   
   const char * toString( const <enum.name> & enm ) {
      switch( enm ) {
      <enum.literal:{literal|case <enum.name>::<literal.name; format="upper,width">: return "<literal.name; format="upper">";
}>      case <enum.name>::LAST: return "LAST";
      }
      return "???";
   }
}
>>



structHeader( namespace, struct, types ) ::= <<
#pragma once

#include \<io/ByteBuffer.hpp>

<struct.field:{field|<
if( field.isStruct || field.isEnum )>
#include \<<types.(field.userType); format="NamespaceToPath">.hpp><
endif>}>

namespace <namespace> {

   struct <struct.name> {

<struct.field:{field|<
if( field.isString )>
      char <field.name>[<field.length> + 1];<
else>
      <type(field)> <field.name>;<
endif>}>

      void put( io::ByteBuffer & target ) const;
      void get( io::ByteBuffer & source );
   };
}
>>



structBody( namespace, struct, modelName, maxLength, maxStrLength, types ) ::= <<
#include \<<types.(modelName); format="NamespaceToPath">.hpp>

using namespace <namespace>;

void <struct.name>::put( io::ByteBuffer & target ) const {
<struct.field:{field|
   < if(     field.isBoolean )>target.putBool  ( <field.name> );
   < elseif( field.isByte    )>target.putByte  ( <field.name> );
   < elseif( field.isShort   )>target.putShort ( <field.name> );
   < elseif( field.isUshort  )>target.putUShort( <field.name> );
   < elseif( field.isInt     )>target.putInt   ( <field.name> );
   < elseif( field.isUint    )>target.putUInt  ( <field.name> );
   < elseif( field.isLong    )>target.putLong  ( <field.name> );
   < elseif( field.isUlong   )>target.putULong ( <field.name> );
   < elseif( field.isFloat   )>target.putFloat ( <field.name> );
   < elseif( field.isDouble  )>target.putDouble( <field.name> );
   < elseif( field.isString  )>target.putString( <field.name> );
   < elseif( field.isEnum    )>target.putByte  ((byte)<field.name> );
   < elseif( field.isStruct  )><field.name>.put( target );
   < endif>
}>}

void <struct.name>::get( io::ByteBuffer & source ) {
<struct.field:{field|
   < if(     field.isBoolean )><field.name; format="width"> = source.getBool  ();
   < elseif( field.isByte    )><field.name; format="width"> = source.getByte  ();
   < elseif( field.isShort   )><field.name; format="width"> = source.getShort ();
   < elseif( field.isUshort  )><field.name; format="width"> = source.getUShort();
   < elseif( field.isInt     )><field.name; format="width"> = source.getInt   ();
   < elseif( field.isUint    )><field.name; format="width"> = source.getUInt  ();
   < elseif( field.isLong    )><field.name; format="width"> = source.getLong  ();
   < elseif( field.isUlong   )><field.name; format="width"> = source.getULong ();
   < elseif( field.isFloat   )><field.name; format="width"> = source.getFloat ();
   < elseif( field.isDouble  )><field.name; format="width"> = source.getDouble();
   < elseif( field.isString  )>source.getString( <
                                  field.name; format="strWidth">, sizeof( <field.name; format="strWidth"> ));
   < elseif( field.isEnum    )><field.name; format="width"> = (<types.(field.userType)>)source.getByte();
   < elseif( field.isStruct  )><field.name>.get( source );
   < endif>
}>}
>>



responsesHeader( namespace, ifaceName, requests, types ) ::= <<
#pragma once
//responses
<requests:{request|
#include \<<types.(request.type); format="NamespaceToPath">.hpp\>
}>
namespace <namespace> {

   class I<ifaceName>Responses {
   public:

<requests:{request|
      virtual void <request.name>Response( <types.(request.type)> <request.name> ) = 0;
}>
   private:
      I<ifaceName>Responses( const I<ifaceName>Responses & ) = delete;
      I<ifaceName>Responses & operator = ( const I<ifaceName>Responses & ) = delete;
   };
}
>>



requiredInterface( namespace, usedTypes, rawSize, iface, ifaceID, types ) ::= <<
#pragma once
//requiredInterface
#include \<io/DatagramSocket.hpp>

<usedTypes:{type|#include \<<types.(type); format="NamespaceToPath">.hpp>
}>
namespace <namespace> {

   class <iface.name> {
   public:

      <iface.name>( io::DatagramSocket & socket, const sockaddr_in & target );

   public:

<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>
      void <facet.name>( <
if( facet.isRequest )><
         signature( facet.arguments.field )><
else><
         signature( facet.field )><
endif> );
< endif>}>
   private:

      enum EventID {
< first(iface.eventOrRequestOrData):{facet|
         <facet.name; format="ID"> = 1,}>
< rest(iface.eventOrRequestOrData) :{facet|
         <facet.name; format="ID">,
}>      };

      enum Interface {
         <iface.name; format="ID">_ID = <ifaceID>,
      };

   private:

      byte                 _raw[<rawSize>];
      io::DatagramSocket & _socket;
      sockaddr_in          _target;
      io::ByteBuffer       _out;

   private:
      <iface.name>( const <iface.name> & ) = delete;
      <iface.name> & operator = ( const <iface.name> & ) = delete;
   };
}
>>



requiredImplementation( namespace, usedTypes, ifaceName, rawSize, iface, ifaceID ) ::= <<
#include \<<namespace; format="NamespaceToPath">/<iface.name>.hpp>
//requiredImplementation
using namespace <namespace>;

<iface.name>::<iface.name>( io::DatagramSocket & socket, const sockaddr_in & target ) :
   _socket( socket ),
   _target( target ),
   _out   ( _raw, <rawSize> )
{}
<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>

void <iface.name>::<facet.name>( <
if( facet.isRequest )><
    signature( facet.arguments.field )><
else><
    signature( facet.field )><
endif> ) {
   _out.clear();
   _out.putByte( <iface.name; format="ID">_ID );
   _out.putByte( <facet.name; format="ID"> );
   <
if( facet.isRequest )><
   byteBufferPut( "", facet.arguments.field )><
elseif( facet.isData )><
   byteBufferPut( "_", facet )><
else><
   byteBufferPut( "", facet.field )><
endif>
   _out.flip();
   _socket.sendTo( _out, _target );
\}
< endif>
}>
>>



offeredInterface( namespace, ifaceName, usedTypes, eventsOrRequests, types ) ::= <<
#pragma once
//offeredInterface
#include \<types.hpp>

<usedTypes:{type|
#include \<<types.(type); format="NamespaceToPath">.hpp>
}>
namespace <namespace> {

   class I<ifaceName> {
   public:

      I<ifaceName>( void ) = default;
      virtual ~ I<ifaceName>( void ) = default;

   public:

<eventsOrRequests:{facet|< if( facet.isData )>< else>
      virtual void <facet.name>( <
if( facet.isRequest )><
         signature( facet.arguments.field )>, <types.(facet.type)> & <facet.name><
else><
         signature( facet.field )><
endif> ) = 0;< endif>
}>
   public:

      virtual void run( void ) = 0;

   private:
      I<ifaceName>( const I<ifaceName> & ) = delete;
      I<ifaceName> & operator = ( const I<ifaceName> & ) = delete;
   };
}
>>



dispatcherInterface(
   namespace, component, ifaces, ifacesIDs, requires, events, rawSize, hasResponse, respRawSize, data, offRequests, reqRequests
) ::= <<
#pragma once
//dispatcherInterface
#include \<io/DatagramSocket.hpp>
#include \<io/ByteBuffer.hpp>

namespace <namespace> {

   class <component.name>Component;
   class <component.name>Dispatcher {
   public:

      <component.name>Dispatcher( io::DatagramSocket & socket, <component.name>Component & listener );

   public:

      bool hasDispatched( void );
< if( component.timeout )>

      enum class LoopbackEvent : byte {
<  first( component.timeout):{to|         <to.name; format="ID"> = 1,
}>< rest( component.timeout):{to|         <to.name; format="ID">,
}>      \};

      void loopback( const LoopbackEvent & event );
< endif>


   private:

      enum class Interface : byte {
         < if( component.timeout )>LOOPBACK = 0,< endif>
<ifaces.keys:{ifaceName|
         <ifaceName; format="ID,width"> = <ifaces.(ifaceName)>,
< if( offRequests.(ifaceName))>
         <ifaceName; format="ID">_RESPONSES = <ifacesIDs.( concat( ifaceName, "Response" ))>,
< endif>
<data:{iface|
         <iface.name; format="ID,width"> = <requires.(iface.name)>,
}>}><reqRequests:{ifaceName|
         <ifaceName; format="ID">_RESPONSES = <ifacesIDs.( concat( ifaceName, "Response" ))>,
}>      };
<ifaces.keys:{ifaceName|


      enum class <ifaceName>Event : byte {
<  first( events.(ifaceName)):{event|         <event.name; format="ID"> = 1,
}>< rest( events.(ifaceName)):{event|         <event.name; format="ID">,
}>      \};

      bool dispatch( < if( offRequests.(ifaceName))>struct sockaddr_in & from, < endif><ifaceName>Event event );
}><data:{iface|


      enum class <iface.name>Data : byte {
<  first( data.(iface)):{dataType|         <dataType.name; format="ID"> = 1,
}>< rest( data.(iface)):{dataType|         <dataType.name; format="ID">,
}>      \};

      bool dispatch( <iface.name>Data event );
}><reqRequests:{ifaceName|

      enum class <ifaceName>Response : byte {
<  first( reqRequests.(ifaceName)):{req|         <req.name; format="ID"> = 1,
}>< rest( reqRequests.(ifaceName)):{req|         <req.name; format="ID">,
}>      \};

      bool dispatch( <ifaceName>Response event );
}>< if( component.timeout )>
      bool dispatch( LoopbackEvent event );
< endif>

   private:

      io::DatagramSocket & _socket;
      byte                 _raw[<rawSize>];
      io::ByteBuffer       _in;
< if( hasResponse )>
      byte                 _outRaw[<respRawSize>];
      io::ByteBuffer       _out;
< endif>
      <component.name>Component & _listener;
   };
}
>>



byteBufferGet( fields ) ::= <<
<fields:{field|
<     if( field.isBoolean )>bool <field.name> = _in.getBool();
< elseif( field.isByte    )>byte <field.name> = _in.getByte();
< elseif( field.isShort   )>short <field.name> = _in.getShort();
< elseif( field.isUshort  )>unsigned short <field.name> = _in.getUShort();
< elseif( field.isInt     )>int <field.name> = _in.getInt();
< elseif( field.isUint    )>unsigned int <field.name> = _in.getUInt();
< elseif( field.isLong    )>int64_t <field.name> = _in.getLong();
< elseif( field.isUlong   )>uint64_t <field.name> = _in.getULong();
< elseif( field.isFloat   )>float <field.name> = _in.getFloat();
< elseif( field.isDouble  )>double <field.name> = _in.getDouble();
< elseif( field.isString  )>char <field.name>[<field.length> + 1];
_in.getString( <field.name>, sizeof( <field.name> ));
< elseif( field.isEnum    )><types.(field.userType)> <field.name> = _in.getByte();
< elseif( field.isStruct  )><types.(field.userType)> <field.name>;
<field.name>.get( _in );
< endif>
}>
>>



dispatcherImplData() ::= <<
// dispatcherImplData -- begin
bool <component.name>Dispatcher::dispatch( <iface.name>Data event ) {
   switch( event ) {
<data.(iface):{dataType|
   case <iface.name>Data::<dataType.name; format="ID">:{
      _listener.update<dataType.name; format="cap">( _in );
      _listener.<dataType.name>Published();
      return true;\}
}>   default:
      UTIL_LOG_ARGS( "Unexpected event: %d", (byte)event );
      return false;
   }
}
// dispatcherImplData -- end
>>



dispatcherImplementation(
    namespace, component, ifaces, events, eventIDs, usedTypes, offRequests, reqRequests, hasResponse, data, types
) ::= <<
//dispatcherImplementation
#include \<<namespace; format="NamespaceToPath">/<component.name>Dispatcher.hpp>
#include \<<namespace; format="NamespaceToPath">/<component.name>Component.hpp>

#include \<util/Log.hpp>

#include \<stdio.h>

using namespace <namespace>;

<component.name>Dispatcher::<component.name>Dispatcher( io::DatagramSocket & socket, <component.name>Component & listener ) :
   _socket  ( socket ),
   _in      ( _raw, sizeof( _raw )),
< if( hasResponse )>
   _out     ( _outRaw, sizeof( _outRaw )),
< endif>
   _listener( listener )
{}
<ifaces.keys:{ifaceName|


<events.(ifaceName):{facet|< if( facet.isRequest )>
static const byte EVENT_<ifaceName; format="ID">_RESPONSES_<facet.name; format="ID"> = <eventIDs.(ifaceName).(facet.name)>;
< endif>}>
bool <component.name>Dispatcher::dispatch( < if( offRequests.(ifaceName))>struct sockaddr_in & from, < endif><ifaceName>Event event ) {
   switch( event ) {
<events.(ifaceName):{facet|< if( facet.isData )>< else>
   case <ifaceName>Event::<facet.name; format="ID">:{
      < if( facet.isRequest )><facet.arguments.field:{field|<
         byteBufferGet( field )>}>< 
      elseif( facet.field )><facet.field:{field|<
         byteBufferGet( field )>}><
      endif><
      if( facet.isRequest )
>      <ifaceName><facet.name; format="cap">Response response;
      _listener.<facet.name>( <args( facet.arguments.field )>, response );
      _out.clear();
      _out.putByte((byte)Interface::<ifaceName; format="ID">_RESPONSES );
      _out.putByte( EVENT_<ifaceName; format="ID">_RESPONSES_<facet.name; format="ID"> );
      response.put( _out );
      _out.flip();
      _socket.sendTo( _out, from );
      UTIL_LOG_ARGS( "response sent to %s", inet_ntoa( from.sin_addr ));
      < else
>      _listener.<facet.name>( <args( facet.field )> );
      < endif>
      break;
      \}
< endif>}>   default:
      UTIL_LOG_ARGS( "Unknown <ifaceName>'s event: %d", (byte)event );
      return false;
   \}
   return true;
\}
}>
<data:{iface|
<dispatcherImplData()>
}>
<reqRequests:{ifaceName|

bool <component.name>Dispatcher::dispatch( <ifaceName>Response event ) {
   switch( event ) {
<reqRequests.(ifaceName):{facet|
   case <ifaceName>Response::<facet.name; format="ID">:{
      <types.(facet.type)> <facet.name>;
      <facet.name>.get( _in );
      _listener.<facet.name>( <facet.name> );
      break;
      \}
}>   default:
      UTIL_LOG_ARGS( "Unknown <ifaceName>'s event: %d", (byte)event );
      return false;
   \}
   return true;
\}
}>
< if( component.timeout )>
bool <component.name>Dispatcher::dispatch( LoopbackEvent event ) {
   switch( event ) {
   <component.timeout:{to|case LoopbackEvent::<to.name; format="ID">: _listener.<to.name; format="argument">Elapsed(); break;
}>   default:
      UTIL_LOG_ARGS( "Unknown timeout's event: %d", (byte)event );
      return false;
   \}
   return true;
\}

< endif>
bool <component.name>Dispatcher::hasDispatched( void ) {
   _in.clear();
   sockaddr_in from;
   if( _socket.receive( _in, from )) {
      _in.flip();
      byte interface = _in.getByte();
      byte event     = _in.getByte();
      switch( static_cast\<Interface>( interface)) {
< if( component.timeout )>
      case Interface::LOOPBACK: return dispatch( static_cast\<LoopbackEvent>( event ));
< endif>
<ifaces.keys:{ifaceName|

      case Interface::<ifaceName; format="ID">: return dispatch( <
        if( offRequests.(ifaceName))>from, < endif>static_cast\<<ifaceName>Event>( event ));
}><reqRequests:{ifaceName|
      case Interface::<ifaceName; format="ID">_RESPONSES: return dispatch( static_cast\<<ifaceName>Response>( event ));
}><data:{iface|
      case Interface::<iface.name; format="ID">: return dispatch( static_cast\<<iface.name>Data>( event ));
}>      default:
         UTIL_LOG_ARGS( "Unknown interface: %d\n", interface );
         break;
      }
   }
   return false;
}
< if( component.timeout )>

void <component.name>Dispatcher::loopback( const LoopbackEvent & event ) {
   byte           raw[2];
   io::ByteBuffer out( raw, sizeof( raw ));
   out.putByte((byte)Interface::LOOPBACK );
   out.putByte((byte)event );
   out.flip();
   _socket.sendTo( out, _socket.getLocalAddress());
}
< endif>
>>



componentInterface(
   typesNamespace, namespace, component, responses, requires, instancesByName, instances, actions, data, reqData
) ::= <<
#pragma once
//componentInterface
#include \<io/DatagramSocket.hpp>
< if( component.timeout )>

#include \<util/Timeout.hpp>

< endif>
<component.offers:{offered|#include \<<namespace>/I<offered.interface.name>.hpp>
}>
<component.requires:{required|#include \<<namespace>/<required.interface.name>.hpp>
}><responses:{ifaceName|#include \<<namespace>/I<ifaceName>.hpp>
}><data:{iface|
#include \<<namespace>/<iface.name>Data.hpp>
}><reqData:{iface|
#include \<<namespace>/I<iface.name>Data.hpp>
}>
#include \<<namespace>/<component.name>Dispatcher.hpp>
< if( component.automaton )>

#include \<<namespace>/Automaton.hpp>
< endif>

#include \<os/Thread.hpp>

namespace <namespace> {

   class <component.name>Component : <
first(component.offers):{ offered  |public I<offered.interface.name>}><
rest (component.offers):{ offered|, public I<offered.interface.name>}><
reqData:{iface|, public I<iface.name>Data}><
responses:{ifaceName|, public I<ifaceName>}> {
   public:

      <component.name>Component( const char * name );

   public:

      void run();

      bool isRunning( void ) const {
         return _running;
      }

      void terminate( void );

< if( actions )>

   public:

<actions:{action|
      virtual void <action>( void ) = 0;
}>
< endif><component.timeout:{to|
      virtual void <to.name>Elapsed( void ) = 0;
}>
   protected:< if( component.afterDispatchNeeded )>

      virtual void afterDispatch( void ) = 0;
< endif>
< if( component.timeout )>

      void loopback( const <component.name>Dispatcher::LoopbackEvent & event );
< endif>
<reqData:{iface|<reqData.(iface):{data|


      <typesNamespace>::<data.name; format="cap"> _<data.name; format="args">;

   public:
   
      void update<data.name; format="cap">( io::ByteBuffer & in );

}>}>   private:

      io::DatagramSocket _socket;
      volatile bool      _running;
      ThreadType         _self;
      <component.name>Dispatcher _dispatcher;

   protected:

< if( component.automaton )>      Automaton _automaton;
< endif>
<component.timeout:{to|       util::TimeoutCallback _<to.name>;
}><data:{iface|
      <iface.name>Data _<iface.name; format="argument">;
}>< first(requires):{req|<requires.(req):{rt|
      <rt.interface.name> _<rt.interface.name; format="argument">;
}>}>   };
}
>>



componentImplementation(
   namespace, component, responses, requires, instancesByName, instances, processes, data, reqData
) ::= <<
//componentImplementation
#include \<<namespace>/<component.name>Component.hpp>
#include \<<namespace>/<component.name>Dispatcher.hpp>

#include \<stdio.h>
#include \<string.h>

#include \<util/Exceptions.hpp>
#include \<util/Log.hpp>

using namespace <namespace>;
< first(requires):{req|<requires.(req):{rt|


static sockaddr_in & init<rt>SocketAddress( const char * name ) {
   static sockaddr_in address;
< first(instances):{instance|
   if( 0 == strcmp( name, "<instance.name>" )) {
      io::DatagramSocket::init( "<
         processes.(instancesByName.(requires.(instance.name).(rt).toInstance)).address>", <
         processes.(instancesByName.(requires.(instance.name).(rt).toInstance)).port>, address );
}>< rest(instances):{instance|
   \}
   else if( 0 == strcmp( name, "<instance.name>" )) {
      io::DatagramSocket::init( "<
         processes.(instancesByName.(requires.(instance.name).(rt).toInstance)).address>", <
         processes.(instancesByName.(requires.(instance.name).(rt).toInstance)).port>, address );
   \}
}>   else {
      throw util::NotApplicable( UTIL_CTXT, "'%s' isn't a valid name as defined in XML application file!", name );
   \}
   return address;
\}}>}>

<component.name>Component::<component.name>Component( const char * name ) :
   _running   ( false ),
   _self      ( 0 ),
   _dispatcher( _socket, *this )< if( component.automaton )>,
   _automaton ( *this )
   < endif>
   <component.timeout:{to|,
   _<to.name; format="argument">( <to.duration><to.unit.toCpp>, [this](){ _dispatcher.loopback( <
      component.name>Dispatcher::LoopbackEvent::<to.name; format="ID"> ); \})}><
   data:{iface|,
   _<iface.name; format="argument">( _socket, initIHMSocketAddress( name ))}><
   first(requires):{req|<requires.(req):{rt|,
   _<rt; format="argument">( _socket, init<rt>SocketAddress( name ))}>}>
{
< first(instances):{instance|
   if( 0 == strcmp( name, "<instance.name>" )) {
      _socket.bind( "<
         processes.(instance).address>", <
         processes.(instance).port> );
}>< rest(instances):{instance|
   \}
   else if( 0 == strcmp( name, "<instance.name>" )) {
      _socket.bind( "<
         processes.(instance).address>", <
         processes.(instance).port> );
}>   }
}<reqData:{iface|<reqData.(iface):{data|


void <component.name>Component::update<data.name; format="cap">( io::ByteBuffer & in ) {
   _<data.name>.get( in );
\}
}>}>

void <component.name>Component::terminate() {
   _running = false;
   os::Thread::cancel( _self );
}

< if( component.timeout )>
void <component.name>Component::loopback( const <component.name>Dispatcher::LoopbackEvent & event ) {
   _dispatcher.loopback( event );
}

< endif>

void <component.name>Component::run() {
   UTIL_LOG_HERE();
   _self    = os::Thread::self();
   _running = true;
   while( _running ) {
      if( _dispatcher.hasDispatched()) {< if( component.afterDispatchNeeded )>
         afterDispatch();
< endif>
      }
   }
   UTIL_LOG_DONE();
}
>>



dataWriterHeader( typesNamespace, namespace, interface, ifaceID, data, rawSize ) ::= <<
#pragma once

// dataWriter

#include \<io/DatagramSocket.hpp>

<data:{dataType|
#include \<<typesNamespace>/<dataType.name; format="cap">.hpp>
}>
namespace <namespace> {

   class <interface.name>Data {
   public:

      <interface.name>Data( io::DatagramSocket & socket, const sockaddr_in & target );

   public:

      <data:{dataType|void publish<dataType.name; format="cap">( void );
}>
   public:

      <data:{dataType|<typesNamespace>::<dataType.name; format="cap"> _<dataType.name; format="argument">;
}>
   private:

      io::DatagramSocket & _socket;
      struct sockaddr_in   _target;
      byte                 _raw[<rawSize>];
      io::ByteBuffer       _out;
   };
}
>>



dataWriterBody( typesNamespace, namespace, interface, ifaceID, data, dataID, rawSize ) ::= <<
#include \<<namespace>/<interface.name>Data.hpp>

#include \<util/Log.hpp>

#include \<stdio.h>

using namespace <namespace>;

static const byte <interface.name; format="ID"> = <ifaceID>;

<data:{dataType|static const byte <dataType.name; format="ID"> = <dataID.(dataType.name)>;
}>
<interface.name>Data::<interface.name>Data( io::DatagramSocket & socket, const sockaddr_in & target ) :
   _socket( socket ),
   _target( target ),
   _out   ( _raw, sizeof( _raw ))
{}
<data:{dataType|


void <interface.name>Data::publish<dataType.name; format="cap">( void ) {
   _out.clear();
   _out.putByte( <interface.name; format="ID"> );
   _out.putByte( <dataType.name; format="ID"> );
   _<dataType.name; format="argument">.put( _out );
   _out.flip();
   unsigned size = (unsigned)_out.remaining();
   _socket.sendTo( _out, _target );
   UTIL_LOG_ARGS( "%u byte(s) sent to %s", size, ::inet_ntoa( _target.sin_addr ));
\}
}>
>>



dataReader( namespace, interface, data  ) ::= <<
#pragma once

// dataReader

namespace <namespace> {

   class I<interface.name>Data {
   public:

      I<interface.name>Data( void ) = default;
      virtual ~ I<interface.name>Data( void ) = default;

   public:

<data:{dataType|
      virtual void <dataType.name; format="argument">Published( void ) = 0;
}>
   };
}
>>



automatonHeader( typesNamespace, namespace, component ) ::= <<
#pragma once

#include \<util/Automaton.hpp>

#include \<<typesNamespace>/<component.automaton.stateEnum.name>.hpp>
#include \<<typesNamespace>/<component.automaton.eventEnum.name>.hpp>

namespace <namespace> {

   class <component.name>Component;
   class Automaton : public util::Automaton\<<
      component.name>Component, <
      typesNamespace>::<component.automaton.stateEnum.name>, <
      typesNamespace>::<component.automaton.eventEnum.name>\> {
   public:

      Automaton( <component.name>Component & component );

   private:
      Automaton( const Automaton & ) = delete;
      Automaton & operator = ( const Automaton & ) = delete;
   };
}
>>



automatonBody( typesNamespace, namespace, component ) ::= <<
#include "Automaton.hpp"
#include \<<namespace>/<component.name>Component.hpp>

using namespace <namespace>;

Automaton :: Automaton( <component.name>Component & component ) :
   util::Automaton\<<
      component.name>Component, <
      typesNamespace>::<component.automaton.stateEnum.name>, <
      typesNamespace>::<component.automaton.eventEnum.name>\>( component, <
         typesNamespace>::<component.automaton.stateEnum.name>::<component.automaton.initial> )
{
   static Transition transitions[] = {<component.automaton.transition:{tr|

      { <typesNamespace>::<component.automaton.stateEnum.name>::<tr.from>, <
         typesNamespace>::<component.automaton.eventEnum.name>::<tr.event>, <
         typesNamespace>::<component.automaton.stateEnum.name>::<tr.futur> \},
}>   };
   setTransitions( transitions, sizeof(transitions)/sizeof(transitions[0]));

   static Shortcut shortcuts[] = {<component.automaton.shortcut:{shortcut|

      { <typesNamespace>::<component.automaton.eventEnum.name>::<shortcut.event>, <
         typesNamespace>::<component.automaton.stateEnum.name>::<shortcut.futur> \},
}>   };
   setShortcuts( shortcuts, sizeof(shortcuts)/sizeof(shortcuts[0]));

   static Action onEntries[] = {<component.automaton.onEntryOrOnExit:{elt|< if( elt.isOnEntry )>
      { <typesNamespace>::<component.automaton.stateEnum.name>::<elt.value.state>, &<component.name>Component::<elt.value.action> \},< endif>
}>
   };
   setOnEntries( onEntries, sizeof(onEntries)/sizeof(onEntries[0]));

   static Action onExits[] = {<component.automaton.onEntryOrOnExit:{elt|< if( elt.isOnExit )>
      { <typesNamespace>::<component.automaton.stateEnum.name>::<elt.value.state>, &<component.name>Component::<elt.value.action> \},< endif>
}>
   };
   setOnExits( onExits, sizeof(onExits)/sizeof(onExits[0]));
}
>>
