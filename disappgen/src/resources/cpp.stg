group CPP;



concat(a,b) ::= <<
<a><b>
>>



type( field ) ::= <<
< if(     field.isBoolean )>bool<
  elseif( field.isByte    )>byte<
  elseif( field.isShort   )>short<
  elseif( field.isUshort  )>unsigned short<
  elseif( field.isInt     )>int<
  elseif( field.isUint    )>unsigned int<
  elseif( field.isLong    )>int64_t<
  elseif( field.isUlong   )>uint64_t<
  elseif( field.isFloat   )>float<
  elseif( field.isDouble  )>double<
  elseif( field.isString  )>char<
  elseif( field.isEnum    )><types.(field.userType)><
  elseif( field.isStruct  )><types.(field.userType)><
  endif>
>>



enumtype( field ) ::= <<
<     if( field.isBoolean )>bool<
  elseif( field.isByte    )>unsigned char<
  elseif( field.isShort   )>short<
  elseif( field.isUshort  )>unsigned short<
  elseif( field.isInt     )>int<
  elseif( field.isUint    )>unsigned<
  elseif( field.isLong    )>int64_t<
  elseif( field.isUlong   )>uint64_t<
  endif>
>>



pair( field ) ::= <<
<     if( field.isBoolean )>bool<
  elseif( field.isString  )>const char *<
  elseif( field.isDouble  )>const double &<
  elseif( field.isEnum    )><typesNamespace>::<field.userType.name><
  elseif( field.isStruct  )>const <typesNamespace>::<field.userType.name> &<
  else                     ><type(field)><
  endif> <field.name>
>>



signature( fields ) ::= <<
< if( ! fields )
     >void<
  else><
     first( fields ):{field|<pair(field)>}><
     rest ( fields ):{field|, <pair(field)>}><
  endif>
>>



args( fields ) ::= <<
< first( fields ):{field|<field.name>}><
  rest ( fields ):{field|, <field.name>}>
>>



byteBufferPut( prefix, fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>_out.putBool( <prefix><field.name> );
< elseif( field.isByte    )>_out.putByte( <prefix><field.name> );
< elseif( field.isShort   )>_out.putShort( <prefix><field.name> );
< elseif( field.isUshort  )>_out.putUShort( <prefix><field.name> );
< elseif( field.isInt     )>_out.putInt( <prefix><field.name> );
< elseif( field.isUint    )>_out.putUInt( <prefix><field.name> );
< elseif( field.isLong    )>_out.putLong( <prefix><field.name> );
< elseif( field.isUlong   )>_out.putULong( <prefix><field.name> );
< elseif( field.isFloat   )>_out.putFloat( <prefix><field.name> );
< elseif( field.isDouble  )>_out.putDouble( <prefix><field.name> );
< elseif( field.isString  )>_out.putString( <prefix><field.name> );
< elseif( field.isEnum    )>_out.putByte( static_cast\<byte>( <prefix><field.name> ));
< elseif( field.isStruct  )><prefix><field.name>.put( _out );
< endif>
}>
>>



enumHeader( namespace, enum ) ::= <<
#pragma once

namespace <namespace> {

   enum class <enum.name> : <enumtype( enum )> {
      FIRST,

< first(enum.literal):{literal|
      <literal.name; format="upper"> = FIRST,}>
< rest(enum.literal) :{literal|
      <literal.name; format="upper">,
}>
      LAST
   };

   const char * toString( const <enum.name> & enm );
}
>>



enumBody( namespace, enum ) ::= <<
#include \<<namespace; format="NamespaceToPath">/<enum.name; format="cname">.hpp>

namespace <namespace> {
   
   const char * toString( const <enum.name> & enm ) {
      switch( enm ) {
      <enum.literal:{literal|case <enum.name>::<literal.name; format="upper,width">: return "<literal.name; format="upper">";
}>      case <enum.name>::LAST: return "LAST";
      }
      return "???";
   }
}
>>



structHeader( namespace, struct, types ) ::= <<
#pragma once

#include \<io/ByteBuffer.hpp>

<struct.field:{field|<
if( field.isStruct || field.isEnum )>
#include \<<types.(field.userType); format="NamespaceToPath">.hpp><
endif>}>

namespace <namespace> {

   struct <struct.name> {

<struct.field:{field|<
if( field.isString )>
      char <field.name>[<field.length> + 1];<
else>
      <type(field)> <field.name>;<
endif>}>

      void put( io::ByteBuffer & target ) const;
      void get( io::ByteBuffer & source );
   };
}
>>



structBody( namespace, struct, modelName, maxLength, maxStrLength, types ) ::= <<
#include \<<types.(modelName); format="NamespaceToPath">.hpp>

using namespace <namespace>;

void <struct.name>::put( io::ByteBuffer & target ) const {
<struct.field:{field|
   < if(     field.isBoolean )>target.putBool  ( <field.name> );
   < elseif( field.isByte    )>target.putByte  ( <field.name> );
   < elseif( field.isShort   )>target.putShort ( <field.name> );
   < elseif( field.isUshort  )>target.putUShort( <field.name> );
   < elseif( field.isInt     )>target.putInt   ( <field.name> );
   < elseif( field.isUint    )>target.putUInt  ( <field.name> );
   < elseif( field.isLong    )>target.putLong  ( <field.name> );
   < elseif( field.isUlong   )>target.putULong ( <field.name> );
   < elseif( field.isFloat   )>target.putFloat ( <field.name> );
   < elseif( field.isDouble  )>target.putDouble( <field.name> );
   < elseif( field.isString  )>target.putString( <field.name> );
   < elseif( field.isEnum    )>target.putByte  ((byte)<field.name> );
   < elseif( field.isStruct  )><field.name>.put( target );
   < endif>
}>}

void <struct.name>::get( io::ByteBuffer & source ) {
<struct.field:{field|
   < if(     field.isBoolean )><field.name; format="width"> = source.getBool  ();
   < elseif( field.isByte    )><field.name; format="width"> = source.getByte  ();
   < elseif( field.isShort   )><field.name; format="width"> = source.getShort ();
   < elseif( field.isUshort  )><field.name; format="width"> = source.getUShort();
   < elseif( field.isInt     )><field.name; format="width"> = source.getInt   ();
   < elseif( field.isUint    )><field.name; format="width"> = source.getUInt  ();
   < elseif( field.isLong    )><field.name; format="width"> = source.getLong  ();
   < elseif( field.isUlong   )><field.name; format="width"> = source.getULong ();
   < elseif( field.isFloat   )><field.name; format="width"> = source.getFloat ();
   < elseif( field.isDouble  )><field.name; format="width"> = source.getDouble();
   < elseif( field.isString  )>source.getString( <
                                  field.name; format="strWidth">, sizeof( <field.name; format="strWidth"> ));
   < elseif( field.isEnum    )><field.name; format="width"> = (<types.(field.userType)>)source.getByte();
   < elseif( field.isStruct  )><field.name>.get( source );
   < endif>
}>}
>>



responsesHeader( namespace, ifaceName, requests, types ) ::= <<
#pragma once
// responsesHeader
<requests:{request|
#include \<<types.(request.type); format="NamespaceToPath">.hpp\>
}>
namespace <namespace> {

   class I<ifaceName>Responses {
   public:

      I<ifaceName>Responses( void ) = default;
      virtual ~ I<ifaceName>Responses( void ) = default;

   public:

<requests:{request|
      virtual void <request.name>Response( const <types.(request.type)> & <request.name> ) = 0;
}>
   private:
      I<ifaceName>Responses( const I<ifaceName>Responses & ) = delete;
      I<ifaceName>Responses & operator = ( const I<ifaceName>Responses & ) = delete;
   };
}
>>



requiredInterface( namespace, usedTypes, rawSize, iface, ifaceID, types ) ::= <<
#pragma once
//requiredInterface
#include \<io/DatagramSocket.hpp>

<usedTypes:{type|#include \<<types.(type); format="NamespaceToPath">.hpp>
}>
namespace <namespace> {

   class <iface.name> {
   public:

      <iface.name>( io::DatagramSocket & socket, const sockaddr_in & target );

   public:

<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>
      void <facet.name>( <
if( facet.isRequest )><
         signature( facet.arguments.field )><
else><
         signature( facet.field )><
endif> );
< endif>}>
   private:

      enum EventID {
< first(iface.eventOrRequestOrData):{facet|
         <facet.name; format="ID"> = 1,}>
< rest(iface.eventOrRequestOrData) :{facet|
         <facet.name; format="ID">,
}>      };

      enum Interface {
         <iface.name; format="ID">_ID = <ifaceID>,
      };

   private:

      byte                 _raw[<rawSize>];
      io::DatagramSocket & _socket;
      sockaddr_in          _target;
      io::ByteBuffer       _out;

   private:
      <iface.name>( const <iface.name> & ) = delete;
      <iface.name> & operator = ( const <iface.name> & ) = delete;
   };
}
>>



requiredImplementation( namespace, usedTypes, ifaceName, rawSize, iface, ifaceID ) ::= <<
#include \<<namespace; format="NamespaceToPath">/<iface.name>.hpp>
//requiredImplementation
using namespace <namespace>;

<iface.name>::<iface.name>( io::DatagramSocket & socket, const sockaddr_in & target ) :
   _socket( socket ),
   _target( target ),
   _out   ( _raw, <rawSize> )
{}
<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>

void <iface.name>::<facet.name>( <
if( facet.isRequest )><
    signature( facet.arguments.field )><
else><
    signature( facet.field )><
endif> ) {
   _out.clear();
   _out.putByte( <iface.name; format="ID">_ID );
   _out.putByte( <facet.name; format="ID"> );
   <
if( facet.isRequest )><
   byteBufferPut( "", facet.arguments.field )><
elseif( facet.isData )><
   byteBufferPut( "_", facet )><
else><
   byteBufferPut( "", facet.field )><
endif>
   _out.flip();
   _socket.sendTo( _out, _target );
\}
< endif>
}>
>>



offeredInterface( namespace, ifaceName, usedTypes, eventsOrRequests, types ) ::= <<
#pragma once
//offeredInterface
#include \<types.hpp>

<usedTypes:{type|
#include \<<types.(type); format="NamespaceToPath">.hpp>
}>
namespace <namespace> {

   class I<ifaceName> {
   public:

      I<ifaceName>( void ) = default;
      virtual ~ I<ifaceName>( void ) = default;

   public:

<eventsOrRequests:{facet|< if( facet.isData )>< else>
      virtual void <facet.name>( <
if( facet.isRequest )><
         signature( facet.arguments.field )>, <types.(facet.type)> & <facet.name><
else><
         signature( facet.field )><
endif> ) = 0;< endif>
}>

   private:
      I<ifaceName>( const I<ifaceName> & ) = delete;
      I<ifaceName> & operator = ( const I<ifaceName> & ) = delete;
   };
}
>>



dispatcherInterface(
   namespace, component, ifaces, ifacesIDs, requires, events, hasResponse, respRawSize, data, offRequests, reqRequests
) ::= <<
#pragma once
// dispatcherInterface
#include \<io/DatagramSocket.hpp>
#include \<io/ByteBuffer.hpp>
#include \<da/IDispatcher.hpp>

namespace <namespace> {

   class <component.name>Component;
   class <component.name>Dispatcher : public da::IDispatcher {
   public:

      <component.name>Dispatcher( bool & running, io::DatagramSocket & socket, <component.name>Component & listener );

   public:

      void terminate( void );

   public:

      virtual void beforeDispatch( void );
      
      virtual bool hasDispatched( byte intrfc, byte event, sockaddr_in & from, io::ByteBuffer & in );
      
      virtual void afterDispatch( bool dispatched );
< if( component.timeout )>

      enum class LoopbackEvent : byte {
<  first( component.timeout):{to|         <to.name; format="ID"> = 1,
}>< rest( component.timeout):{to|         <to.name; format="ID">,
}>      \};

      void loopback( const LoopbackEvent & event );
< endif>


   private:

      enum class Interface : byte {
         < if( component.timeout )>LOOPBACK = 0,< endif>
<ifaces.keys:{ifaceName|
         <ifaceName; format="ID,width"> = <ifaces.(ifaceName)>,
< if( offRequests.(ifaceName))>
         <ifaceName; format="ID">_RESPONSES = <ifacesIDs.( concat( ifaceName, "Response" ))>,
< endif>
<data:{iface|
         <iface.name; format="ID,width"> = <requires.(iface.name)>,
}>}><reqRequests:{ifaceName|
         <ifaceName; format="ID">_RESPONSES = <ifacesIDs.( concat( ifaceName, "Response" ))>,
}>      };
<ifaces.keys:{ifaceName|


      enum class <ifaceName>Event : byte {
<  first( events.(ifaceName)):{event|         <event.name; format="ID"> = 1,
}>< rest( events.(ifaceName)):{event|         <event.name; format="ID">,
}>      \};

      bool dispatch( < if( offRequests.(ifaceName))>struct sockaddr_in & from, < endif><ifaceName>Event event, io::ByteBuffer & in );
}><data:{iface|


      enum class <iface.name>Data : byte {
<  first( data.(iface)):{dataType|         <dataType.name; format="ID"> = 1,
}>< rest( data.(iface)):{dataType|         <dataType.name; format="ID">,
}>      \};

      bool dispatch( <iface.name>Data event, io::ByteBuffer & in );
}><reqRequests:{ifaceName|

      enum class <ifaceName>Response : byte {
<  first( reqRequests.(ifaceName)):{req|         <req.name; format="ID"> = 1,
}>< rest( reqRequests.(ifaceName)):{req|         <req.name; format="ID">,
}>      \};

      bool dispatch( <ifaceName>Response event, io::ByteBuffer & in );
}>< if( component.timeout )>
      bool dispatch( LoopbackEvent event );
< endif>

   private:

      io::DatagramSocket & _socket;
< if( hasResponse )>
      byte                 _outRaw[<respRawSize>];
      io::ByteBuffer       _out;
< endif>
      <component.name>Component & _listener;
   };
}
>>



byteBufferGet( fields ) ::= <<
<fields:{field|
<     if( field.isBoolean )>bool <field.name> = in.getBool();
< elseif( field.isByte    )>byte <field.name> = in.getByte();
< elseif( field.isShort   )>short <field.name> = in.getShort();
< elseif( field.isUshort  )>unsigned short <field.name> = in.getUShort();
< elseif( field.isInt     )>int <field.name> = in.getInt();
< elseif( field.isUint    )>unsigned int <field.name> = in.getUInt();
< elseif( field.isLong    )>int64_t <field.name> = in.getLong();
< elseif( field.isUlong   )>uint64_t <field.name> = in.getULong();
< elseif( field.isFloat   )>float <field.name> = in.getFloat();
< elseif( field.isDouble  )>double <field.name> = in.getDouble();
< elseif( field.isString  )>char <field.name>[<field.length> + 1];
in.getString( <field.name>, sizeof( <field.name> ));
< elseif( field.isEnum    )><types.(field.userType)> <field.name> = in.getByte();
< elseif( field.isStruct  )><types.(field.userType)> <field.name>;
<field.name>.get( in );
< endif>
}>
>>



dispatcherImplData() ::= <<
// dispatcherImplData -- begin
bool <component.name>Dispatcher::dispatch( <iface.name>Data event, io::ByteBuffer & in ) {
   switch( event ) {
<data.(iface):{dataType|
   case <iface.name>Data::<dataType.name; format="ID">:{
      _listener.get<dataType.name; format="cap">().get( in );
      _listener.<dataType.name>Published();
      return true;\}
}>   default:
      UTIL_LOG_ARGS( "Unexpected event: %d", (byte)event );
      return false;
   }
}
// dispatcherImplData -- end
>>



dispatcherImplementation(
    namespace, component, ifaces, events, eventIDs, usedTypes, offRequests, reqRequests, hasResponse, data, types
) ::= <<
//dispatcherImplementation
#include \<<namespace; format="NamespaceToPath">/<component.name>Dispatcher.hpp>
#include \<<namespace; format="NamespaceToPath">/<component.name>Component.hpp>

#include \<io/sockets.hpp>
#include \<util/Log.hpp>

#include \<stdio.h>

using namespace <namespace>;

<component.name>Dispatcher::<component.name
>Dispatcher( bool & running, io::DatagramSocket & socket, <component.name>Component & listener ) :
   IDispatcher( running ),
   _socket  ( socket ),
< if( hasResponse )>
   _out     ( _outRaw, sizeof( _outRaw )),
< endif>
   _listener( listener )
{
   listener.setDispatcher( *this );
}

void <component.name>Dispatcher::terminate( void ) {
   _running = false;
   ::shutdown( _socket, SHUT_RDWR );
   closesocket( _socket );
}
<ifaces.keys:{ifaceName|


<events.(ifaceName):{facet|< if( facet.isRequest )>
static const byte EVENT_<ifaceName; format="ID">_RESPONSES_<facet.name; format="ID"> = <eventIDs.(ifaceName).(facet.name)>;
< endif>}>
bool <component.name>Dispatcher::dispatch( < if( offRequests.(ifaceName))>struct sockaddr_in & from, < endif
    ><ifaceName>Event event, io::ByteBuffer & in ) {
   switch( event ) {
<events.(ifaceName):{facet|< if( facet.isData )>< else>
   case <ifaceName>Event::<facet.name; format="ID">:{
      < if( facet.isRequest )><facet.arguments.field:{field|<
         byteBufferGet( field )>}>< 
      elseif( facet.field )><facet.field:{field|<
         byteBufferGet( field )>}><
      endif><
      if( facet.isRequest )
>      <types.(facet.type)> <facet.name>;
      _listener.<facet.name>( <args( facet.arguments.field )>, <facet.name> );
      _out.clear();
      _out.putByte((byte)Interface::<ifaceName; format="ID">_RESPONSES );
      _out.putByte( EVENT_<ifaceName; format="ID">_RESPONSES_<facet.name; format="ID"> );
      <facet.name>.put( _out );
      _out.flip();
      _socket.sendTo( _out, from );
      UTIL_LOG_ARGS( "response sent to %s", inet_ntoa( from.sin_addr ));
      < else
>      _listener.<facet.name>( <args( facet.field )> );
      < endif>
      break;
      \}
< endif>}>   default:
      UTIL_LOG_ARGS( "Unknown <ifaceName>'s event: %d", (byte)event );
      return false;
   \}
   return true;
\}
}>
<data:{iface|
<dispatcherImplData()>
}>
<reqRequests:{ifaceName|

bool <component.name>Dispatcher::dispatch( <ifaceName>Response event, io::ByteBuffer & in ) {
   switch( event ) {
<reqRequests.(ifaceName):{facet|
   case <ifaceName>Response::<facet.name; format="ID">:{
      <types.(facet.type)> <facet.name>;
      <facet.name>.get( in );
      _listener.<facet.name>Response( <facet.name> );
      break;
      \}
}>   default:
      UTIL_LOG_ARGS( "Unknown <ifaceName>'s event: %d", (byte)event );
      return false;
   \}
   return true;
\}
}>
< if( component.timeout )>
bool <component.name>Dispatcher::dispatch( LoopbackEvent event ) {
   switch( event ) {
   <component.timeout:{to|case LoopbackEvent::<to.name; format="ID">: _listener.<to.name; format="argument">Elapsed(); break;
}>   default:
      UTIL_LOG_ARGS( "Unknown timeout's event: %d", (byte)event );
      return false;
   \}
   return true;
\}

< endif>
void <component.name>Dispatcher::beforeDispatch( void ) {
   _listener.beforeDispatch();
}
      
bool <component.name>Dispatcher::hasDispatched( byte intrfc, byte event, sockaddr_in & from, io::ByteBuffer & in ) {
   switch( static_cast\<Interface>( intrfc )) {
< if( component.timeout )>
   case Interface::LOOPBACK: return dispatch( static_cast\<LoopbackEvent>( event ));
< endif>
<ifaces.keys:{ifaceName|

   case Interface::<ifaceName; format="ID">: return dispatch( <
     if( offRequests.(ifaceName))>from, < endif>static_cast\<<ifaceName>Event>( event ), in );
}><reqRequests:{ifaceName|
   case Interface::<ifaceName; format="ID">_RESPONSES: return dispatch( static_cast\<<ifaceName>Response>( event ), in );
}><data:{iface|
   case Interface::<iface.name; format="ID">: return dispatch( static_cast\<<iface.name>Data>( event ), in );
}>      default:
      UTIL_LOG_ARGS( "Unknown interface: %d\n", intrfc );
      break;
   }
   return false;
   (void)from;
   (void)in;
}

void <component.name>Dispatcher::afterDispatch( bool dispatched ) {
   _listener.afterDispatch( dispatched );
}
< if( component.timeout )>

void <component.name>Dispatcher::loopback( const LoopbackEvent & event ) {
   byte           raw[2];
   io::ByteBuffer out( raw, sizeof( raw ));
   out.putByte((byte)Interface::LOOPBACK );
   out.putByte((byte)event );
   out.flip();
   _socket.sendTo( out, _socket.getLocalAddress());
}
< endif>
>>



componentHeader( namespace, component, requires, actions, offData, reqData, responses, includes, types ) ::= <<
#pragma once
// componentHeader
#include \<io/DatagramSocket.hpp>
< if( component.timeout )>

#include \<util/Timeout.hpp>

< endif>
<component.offers  :{offered |#include \<<namespace; format="NamespaceToPath">/I<offered .interface.name>.hpp>}; separator="\n">
<component.requires:{required|#include \<<namespace; format="NamespaceToPath">/<required.interface.name >.hpp>}; separator="\n">
<responses         :{iface   |#include \<<namespace; format="NamespaceToPath">/I<iface.name    >Responses.hpp>}; separator="\n">
<offData           :{iface   |#include \<<namespace; format="NamespaceToPath">/<iface.name          >Data.hpp>}; separator="\n">
<reqData           :{iface   |#include \<<namespace; format="NamespaceToPath">/I<iface.name         >Data.hpp>}; separator="\n">
#include \<<                              namespace; format="NamespaceToPath">/<component.name>Dispatcher.hpp>
< if( component.automaton )>

#include \<<                              namespace; format="NamespaceToPath">/Automaton.hpp>
< endif>

namespace <namespace> {

   class <component.name>Component :<
component.offers:{offered|  public I<offered.interface.name>}; separator=", "><
reqData         :{iface  |, public I<iface.name        >Data}; separator=", "><
responses       :{iface  |, public I<iface.name   >Responses}; separator=", "> {
   public:

      <component.name>Component( void ) :
         _dispatcher( 0 )<requires:{iface|,
         _<iface.name; format="argument">( 0 )}><offData:{iface|,
         _<iface.name; format="argument">Data( 0 )}><reqData:{iface|<reqData.(iface):{data|,
         _<data.name; format="argument">( 0 )}>}>< if( component.automaton )>,
         _automaton( *this )< endif><component.timeout:{to|,
         _<to.name; format="argument">( <to.name; format="ID">_DURATION, [this](){ loopback( <
            component.name>Dispatcher::LoopbackEvent::<to.name; format="ID"> );\})}>
      {}

   public:

      void setDispatcher( <component.name>Dispatcher & dispatcher ) {
         _dispatcher = &dispatcher;
      }

      bool isRunning( void ) const {
         return _dispatcher->isRunning();
      }

      void terminate( void ) const {
         return _dispatcher->terminate();
      }

      <actions:{action|virtual void <action>( void ) = 0;
}>
      <component.timeout:{to|virtual void <to.name>Elapsed( void ) = 0;
}>
   public:

      virtual void init( void ) {}

      virtual void beforeDispatch( void ) {}

      virtual void afterDispatch( bool dispatched ) {
         (void)dispatched;
      }

<requires:{iface|
      void connect( <iface.name> & <iface.name; format="argument"> ) {
         _<iface.name; format="argument"> = &<iface.name; format="argument">;
      \}

      <iface.name> & get<iface.name>( void ) {
         return *_<iface.name; format="argument">;
      \}
}><reqData:{iface|<reqData.(iface):{data|

      void connect( <types.(data.type)> & <data.name; format="argument"> ) {
         _<data.name; format="argument"> = &<data.name; format="argument">;
      \}

      <types.(data.type)> & get<data.name; format="cap">( void ) {
         return *_<data.name; format="argument">;
      \}}>
}><offData:{iface|
      void connect( <iface.name>Data & data ) {
         _<iface.name; format="argument">Data = &data;
      \}

      <iface.name>Data & get<iface.name; format="cap">Data( void ) {
         return *_<iface.name; format="argument">Data;
      \}}>

< if( component.timeout )>
   private:

      void loopback( <component.name>Dispatcher::LoopbackEvent event );

< endif>
   protected:

      <component.name>Dispatcher * _dispatcher;
<requires:{iface|
      <iface.name> * _<iface.name; format="argument">;
}><offData:{iface|
      <iface.name>Data * _<iface.name; format="argument">Data;
}><
if( component.automaton )>      Automaton             _automaton;
< endif><reqData:{iface|<reqData.(iface):{data|
      <types.(data.type)> * _<data.name; format="argument">;
}>}><component.timeout:{to|
      util::TimeoutCallback _<to.name>;
}>
<component.timeout:{to|
      static const unsigned <to.name; format="ID">_DURATION = <to.duration><to.unit.toCpp; format="cap">;
}>
   private:
      <component.name>Component( const <component.name>Component & ) = delete;
      <component.name>Component & operator = ( const <component.name>Component & ) = delete;
   };
}
>>



componentImplementation(
   namespace, component, responses, requires, instancesByName, instances, processes, offData, reqData
) ::= <<
//componentImplementation
#include \<<namespace; format="NamespaceToPath">/<component.name>Component.hpp>

using namespace <namespace>;

< if( component.timeout )>
void <component.name>Component::loopback( <component.name>Dispatcher::LoopbackEvent event ) {
   _dispatcher->loopback( event );
}
< endif>
>>



dataWriterHeader( namespace, interface, ifaceID, data, rawSize, types ) ::= <<
#pragma once
// dataWriterHeader

#include \<io/DatagramSocket.hpp>

<data:{dataType|
#include \<<types.(dataType.type); format="NamespaceToPath">.hpp>
}>
namespace <namespace> {

   class <interface.name>Data {
   public:

      <interface.name>Data( io::DatagramSocket & socket, const sockaddr_in & target );

   public:

      <data:{dataType|void publish<dataType.name; format="cap">( void );
}>
   public:

      <data:{dataType|<types.(dataType.type)> _<dataType.name; format="argument">;}; separator="\n">

   private:

      io::DatagramSocket & _socket;
      struct sockaddr_in   _target;
      byte                 _raw[<rawSize>];
      io::ByteBuffer       _out;
   };
}
>>



dataWriterBody( namespace, interface, ifaceID, data, dataID, rawSize ) ::= <<
// dataWriterBody
#include \<<namespace; format="NamespaceToPath">/<interface.name>Data.hpp>

#include \<util/Log.hpp>

#include \<stdio.h>

using namespace <namespace>;

static const byte <interface.name; format="ID"> = <ifaceID>;

<data:{dataType|static const byte <dataType.name; format="ID"> = <dataID.(dataType.name)>;
}>
<interface.name>Data::<interface.name>Data( io::DatagramSocket & socket, const sockaddr_in & target ) :
   _socket( socket ),
   _target( target ),
   _out   ( _raw, sizeof( _raw ))
{}
<data:{dataType|


void <interface.name>Data::publish<dataType.name; format="cap">( void ) {
   _out.clear();
   _out.putByte( <interface.name; format="ID"> );
   _out.putByte( <dataType.name; format="ID"> );
   _<dataType.name; format="argument">.put( _out );
   _out.flip();
   unsigned size = (unsigned)_out.remaining();
   _socket.sendTo( _out, _target );
   UTIL_LOG_ARGS( "%u byte(s) sent to %s", size, ::inet_ntoa( _target.sin_addr ));
\}
}>
>>



dataReader( namespace, interface, data  ) ::= <<
#pragma once

// dataReader

namespace <namespace> {

   class I<interface.name>Data {
   public:

      I<interface.name>Data( void ) = default;
      virtual ~ I<interface.name>Data( void ) = default;

   public:

<data:{dataType|
      virtual void <dataType.name; format="argument">Published( void ) = 0;
}>
   };
}
>>



automatonHeader( namespace, component, types ) ::= <<
#pragma once

#include \<util/Automaton.hpp>

#include \<<types.(component.automaton.stateEnum.name); format="NamespaceToPath">.hpp>
#include \<<types.(component.automaton.eventEnum.name); format="NamespaceToPath">.hpp>

namespace <namespace> {

   class <component.name>Component;
   class Automaton : public util::Automaton\<<
      component.name>Component, <
      types.(component.automaton.stateEnum.name)>, <
      types.(component.automaton.eventEnum.name)>\> {
   public:

      Automaton( <component.name>Component & component );

   private:
      Automaton( const Automaton & ) = delete;
      Automaton & operator = ( const Automaton & ) = delete;
   };
}
>>



automatonBody( namespace, component, types ) ::= <<
#include "Automaton.hpp"
#include \<<namespace; format="NamespaceToPath">/<component.name>Component.hpp>

using namespace <namespace>;

Automaton :: Automaton( <component.name>Component & component ) :
   util::Automaton\<<
      component.name>Component, <
      types.(component.automaton.stateEnum.name)>, <
      types.(component.automaton.eventEnum.name)>\>( component, <
         types.(component.automaton.stateEnum.name)>::<component.automaton.initial> )
{
   static Transition transitions[] = {<component.automaton.transition:{tr|

      { <types.(component.automaton.stateEnum.name)>::<tr.from>, <
         types.(component.automaton.eventEnum.name)>::<tr.event>, <
         types.(component.automaton.stateEnum.name)>::<tr.futur> \},
}>   };
   setTransitions( transitions, sizeof(transitions)/sizeof(transitions[0]));

   static Shortcut shortcuts[] = {<component.automaton.shortcut:{shortcut|

      { <types.(component.automaton.eventEnum.name)>::<shortcut.event>, <
         types.(component.automaton.stateEnum.name)>::<shortcut.futur> \},
}>   };
   setShortcuts( shortcuts, sizeof(shortcuts)/sizeof(shortcuts[0]));

   static Action onEntries[] = {<component.automaton.onEntryOrOnExit:{elt|< if( elt.isOnEntry )>
      { <types.(component.automaton.stateEnum.name)>::<elt.value.state>, &<component.name>Component::<elt.value.action> \},< endif>
}>
   };
   setOnEntries( onEntries, sizeof(onEntries)/sizeof(onEntries[0]));

   static Action onExits[] = {<component.automaton.onEntryOrOnExit:{elt|< if( elt.isOnExit )>
      { <types.(component.automaton.stateEnum.name)>::<elt.value.state>, &<component.name>Component::<elt.value.action> \},< endif>
}>
   };
   setOnExits( onExits, sizeof(onExits)/sizeof(onExits[0]));
}
>>



componentFactoryHeader(
   namespace, process, instancesCount, processes, offData, reqData, instancesByName, dataConsumer, modules, types
) ::= <<
#pragma once
// ComponentFactoryHeader

#include \<da/IDispatcher.hpp>
#include \<io/DatagramSocket.hpp>
#include \<os/Thread.hpp>

<process.instance:{instance|#include \<<modules.(instance.component); format="NamespaceToPath">/<instance.component.name>.hpp\>}; separator="\n">

namespace <namespace> {

   class ComponentFactory {
   public:

      ComponentFactory( void );
      ~ ComponentFactory( void );
   
   public:
   
      <process.instance:{instance|<modules.(instance.component)>::<instance.component.name> & get<instance.name; format="cap">( void );}; separator="\n">

      void join( void );

   private:

      <process.instance:{instance|void connect<instance.name; format="cap">( void );}; separator="\n">

      void run( void );

   private:

      static void * _run( void * userCtxt ) {
         ((ComponentFactory *)userCtxt)->run();
         return nullptr;
      }

   private:

      bool               _running;
      da::IDispatcher *  _dispatchers[<instancesCount>];
      os::Thread *       _thread;
      io::DatagramSocket _socket;
      <process.instance:{instance|<modules.(instance.component)>::<instance.component.name> _<instance.name; format="argument">;}; separator="\n">

   private:
      ComponentFactory( const ComponentFactory & ) = delete;
      ComponentFactory & operator = ( const ComponentFactory & ) = delete;
   };
}
>>



componentFactoryBody(
   namespace, process, instancesCount, processes, offData, reqData, instancesByName, dataConsumer, modules, types
) ::= <<
// ComponentFactoryBody
#include "ComponentFactory.hpp"

#include \<io/sockets.hpp>
#include \<os/sleep.hpp>
#include \<util/Exceptions.hpp>
#include \<util/Log.hpp>

#include \<stdio.h>

using namespace <namespace>;

ComponentFactory::ComponentFactory( void ) :
   _running( false ),
   _thread( nullptr )
{
   UTIL_LOG_HERE();
   _socket.bind( "<process.address>", <process.port> );
   <process.instance:{instance|connect<instance.name; format="cap">();}; separator="\n">
   <process.instance:{instance|_<instance.name; format="argument">.init();}; separator="\n">
   _thread = new os::Thread( _run, this );
   while( ! _running ) {
      os::sleep( 100 );
   }
   UTIL_LOG_DONE();
}

ComponentFactory:: ~ ComponentFactory( void ) {
   UTIL_LOG_HERE();
   _running = false;
   shutdown( _socket, SHUT_RD );
   closesocket( _socket );
   _thread->join();
   delete _thread;
   UTIL_LOG_DONE();
}

void ComponentFactory::join() {
   UTIL_LOG_HERE();
   _thread->join();
   UTIL_LOG_DONE();
}

<process.instance:{instance|void ComponentFactory::connect<instance.name; format="cap">( void ) {
<reqData:{iface|<reqData.(iface):{data|
   <types.(data.type)> * <data.name; format="argument"> = new <types.(data.type)>();
   _<instance.name; format="argument">.connect( *<data.name; format="argument"> );}; separator="\n">}; separator="\n">
<offData:{iface|<dataConsumer.(iface).(instance.name):{process|
   sockaddr_in <iface.name; format="argument">;
   io::DatagramSocket::init( "<process.address>", <process.port>, <iface.name; format="argument"> );
   _<instance.name; format="argument">.connect( *new <
      modules.(instance.component)>::<iface.name>Data( _socket, <iface.name; format="argument">));}; separator="\n">}; separator="\n">
<process.instance:{instance|<instance.requires:{requires|
   sockaddr_in <requires.interface.name; format="argument">;
   io::DatagramSocket::init( "<processes.(instancesByName.(requires.toInstance)).address>", <processes.(instancesByName.(requires.toInstance)).port>, <requires.interface.name; format="argument"> );
   _<instance.name; format="argument">.connect( *new <
      modules.(instance.component)>::<requires.interface.name>( _socket, <requires.interface.name; format="argument"> ));}; separator="\n">}; separator="\n">
   _dispatchers[<i0>] = new <
      modules.(instance.component)>::<instance.component.name>Dispatcher( _running, _socket, _<instance.name; format="argument"> );
\}
   
<modules.(instance.component)>::<instance.component.name> & ComponentFactory::get<instance.name; format="cap">( void ) {
   return _<instance.name; format="argument">;
\}

}>void ComponentFactory::run( void ) {
   UTIL_LOG_HERE();
   byte raw[64*1024];
   io::ByteBuffer in( raw, 64*1024 );
   _running = true;
   try {
      while( _running ) {
         in.clear();
         sockaddr_in from;
         _socket.receive( in, from );
         in.flip();
         if( in.remaining() >= 2 ) {
            byte intrfc = in.getByte();
            byte event  = in.getByte();
            for( da::IDispatcher * dispatcher : _dispatchers ) {
               dispatcher->beforeDispatch();
            }
            bool dispatched = false;
            for( da::IDispatcher * dispatcher : _dispatchers ) {
               if( dispatcher->hasDispatched( intrfc, event, from, in )) {
                  dispatched = true;
                  break;
               }
            }
            for( da::IDispatcher * dispatcher : _dispatchers ) {
               dispatcher->afterDispatch( dispatched );
            }
         }
      }
   }
   catch( const util::Runtime & x ) {
      UTIL_LOG_MSG( x.what());
   }
   _running = false;
}
>>
