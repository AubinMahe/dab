group Java;



concat(a,b) ::= <<
<a><b>
>>



type( field ) ::= <<
< if(     field.isBoolean )>boolean<
  elseif( field.isByte    )>byte   <
  elseif( field.isShort   )>short  <
  elseif( field.isUshort  )>short  <
  elseif( field.isInt     )>int    <
  elseif( field.isUint    )>int    <
  elseif( field.isLong    )>long   <
  elseif( field.isUlong   )>long   <
  elseif( field.isFloat   )>float  <
  elseif( field.isDouble  )>double <
  elseif( field.isString  )>String <
  elseif( field.isEnum    )><types.(field.userType)><
  elseif( field.isStruct  )><types.(field.userType)><
  endif>
>>



signature( fields ) ::= <<
< first( fields ):{field|<trim((type(field)))> <field.name>}><
  rest ( fields ):{field|, <trim((type(field)))> <field.name>}>
>>



args( fields ) ::= <<
< if( fields )> < first( fields ):{field|<field.name>}>< rest( fields ):{field|, <field.name>}> < endif>
>>



dataGen( visibility, field ) ::= <<
<     if( field.isBoolean )><visibility> boolean <field.name>;
< elseif( field.isByte    )><visibility> byte <field.name>;
< elseif( field.isShort   )><visibility> short <field.name>;
< elseif( field.isUshort  )><visibility> ushort <field.name>;
< elseif( field.isInt     )><visibility> int <field.name>;
< elseif( field.isUint    )><visibility> uint <field.name>;
< elseif( field.isLong    )><visibility> long <field.name>;
< elseif( field.isUlong   )><visibility> ulong <field.name>;
< elseif( field.isFloat   )><visibility> float <field.name>;
< elseif( field.isDouble  )><visibility> double <field.name>;
< elseif( field.isString  )><visibility> String <field.name>;
< elseif( field.isEnum    )><visibility> <field.userType.name> _<field.name> = <field.userType.name>.values()[0];
< elseif( field.isStruct  )><visibility> final <field.userType.name> _<field.name> = new <field.userType.name>();
< endif>
>>



byteBufferPut( fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>ByteBufferHelper.putBoolean( _out, <field.name> );
< elseif( field.isByte    )>_out.put( <field.name> );
< elseif( field.isShort   )>_out.putShort( <field.name> );
< elseif( field.isUshort  )>_out.putShort( <field.name> );
< elseif( field.isInt     )>_out.putInt( <field.name> );
< elseif( field.isUint    )>_out.putInt( <field.name> );
< elseif( field.isLong    )>_out.putLong( <field.name> );
< elseif( field.isUlong   )>_out.putLong( <field.name> );
< elseif( field.isFloat   )>_out.putFloat( <field.name> );
< elseif( field.isDouble  )>_out.putDouble( <field.name> );
< elseif( field.isEnum    )>_out.put((byte)<field.name>.ordinal());
< elseif( field.isString  )>ByteBufferHelper.putString( _out, <field.name> );
< elseif( field.isStruct  )><field.name>.put( _out );
< endif>
}>
>>



enum( package, enum ) ::= <<
package <package>;

import java.nio.ByteBuffer;

import io.ByteBufferHelper;

public enum <enum.name> {

   <enum.literal:{literal|<literal.name; format="ID">,
}>}
>>



struct( package, struct, maxLength, maxStrLength, types ) ::= <<
package <package>;

import java.nio.ByteBuffer;

import io.ByteBufferHelper;

public class <struct.name> {

<struct.field:{field|
   public < if( field.isStruct )>final <type( field )> <field.name> = new <type( field )>();
< else><type( field )> <field.name>;
< endif>
}>
   public void put( ByteBuffer target ) {
      <struct.field:{field|
< if(     field.isBoolean )>ByteBufferHelper.putBoolean( target, <field.name> );
< elseif( field.isByte    )>target.put       ( <field.name> );
< elseif( field.isShort   )>target.putShort  ( <field.name> );
< elseif( field.isUshort  )>target.putShort  ( <field.name> );
< elseif( field.isInt     )>target.putInt    ( <field.name> );
< elseif( field.isUint    )>target.putInt    ( <field.name> );
< elseif( field.isLong    )>target.putLong   ( <field.name> );
< elseif( field.isUlong   )>target.putLong   ( <field.name> );
< elseif( field.isFloat   )>target.putFloat  ( <field.name> );
< elseif( field.isDouble  )>target.putDouble ( <field.name> );
< elseif( field.isEnum    )>target.put       ((byte)<field.name>.ordinal());
< elseif( field.isString  )>ByteBufferHelper.putString( target, <field.name> );
< elseif( field.isStruct  )><field.name>.put( target );
< endif>
}>   }

   public void get( ByteBuffer source ) {
      <struct.field:{field|
< if(     field.isBoolean )><field.name; format="width"> = ByteBufferHelper.getBoolean( source );
< elseif( field.isByte    )><field.name; format="width"> = source.get();
< elseif( field.isShort   )><field.name; format="width"> = source.getShort();
< elseif( field.isUshort  )><field.name; format="width"> = source.getShort();
< elseif( field.isInt     )><field.name; format="width"> = source.getInt();
< elseif( field.isUint    )><field.name; format="width"> = source.getInt();
< elseif( field.isLong    )><field.name; format="width"> = source.getLong();
< elseif( field.isUlong   )><field.name; format="width"> = source.getLong();
< elseif( field.isFloat   )><field.name; format="width"> = source.getFloat();
< elseif( field.isDouble  )><field.name; format="width"> = source.getDouble();
< elseif( field.isEnum    )><field.name; format="width"> = <types.(field.userType)>.values()[source.get()];
< elseif( field.isString  )><field.name; format="width"> = ByteBufferHelper.getString( source );
< elseif( field.isStruct  )><field.name; format="width">.get( source );
< endif>
}>   }
}
>>



responses( package, ifaceName, requests, types ) ::= <<
package <package>;

import java.io.IOException;

public interface I<ifaceName>Responses {

<requests:{request|
   public void <request.name>Response( <types.(request.type)> <request.name> ) throws IOException;
}>}
>>



requiredInterface( package, iface ) ::= <<
package <package>;
// requiredInterface

import java.io.IOException;

public interface I<iface.name> {

<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>
   void <facet.name; format="argument">(<
if( facet.isRequest )><
      signature( facet.arguments.field )><
else><
      signature( facet.field )><
endif>) throws IOException;< endif>
}>
}
>>



requiredImplementation( package, usedTypes, ifaceName, rawSize, iface, ifaceID, imports ) ::= <<
package <package>;
//requiredImplementation
import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

import io.ByteBufferHelper;

<imports:{type|import <type>;
}>
public class <ifaceName> implements I<ifaceName> {

   private static final byte <iface.name; format="ID"> = <ifaceID>;

   <iface.eventOrRequestOrData:{facet|private static final byte <facet.name; format="ID"> = <i>;
}>
   private final DatagramChannel _channel;
   private final SocketAddress   _target;
   private final ByteBuffer      _out = ByteBuffer.allocate( <rawSize> );

   public <ifaceName>( DatagramChannel channel, SocketAddress target ) {
      _channel = channel;
      _target  = target;
   }
<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>

   @Override
   public void <facet.name; format="argument">(<
if( facet.isRequest )><
    signature( facet.arguments.field )><
else><
    signature( facet.field )><
endif>) throws IOException {
      _out.clear();
      _out.put( <iface.name; format="ID"> );
      _out.put( <facet.name; format="ID"> );
      <
if( facet.isRequest )><
      byteBufferPut( facet.arguments.field )><
else><
      byteBufferPut( facet.field )><
endif>
      _out.flip();
      final int size = _out.remaining();
      _channel.send( _out, _target );
      System.err.printf( "<ifaceName>.<facet.name>|%d byte(s) sent to %s\n", size, _target );
   \}< endif>
}>
}
>>



offeredInterface( package, ifaceName, usedTypes, facets, types ) ::= <<
package <package>;
// offeredInterface

import java.io.IOException;

public interface I<ifaceName> {

<facets:{facet|<
if( facet.isData )><
else>
   void <facet.name>(<
   if( facet.isRequest )><
      if( facet.arguments )> <signature( facet.arguments.field )>, <types.(facet.type)> <facet.name> <
      else> <types.(facet.type)> <facet.name> <
      endif><
   else><signature( facet.field )><
   endif>) throws IOException;<
endif>
}>
}
>>



byteBufferGet( field ) ::= <<
<     if( field.isBoolean )>final boolean <field.name> = ByteBufferHelper.getBoolean( in );
< elseif( field.isByte    )>final byte <field.name> = in.get();
< elseif( field.isShort   )>final short <field.name> = in.getShort();
< elseif( field.isUshort  )>final ushort <field.name> = in.getUShort();
< elseif( field.isInt     )>final int <field.name> = in.getInt();
< elseif( field.isUint    )>final uint <field.name> = in.getUInt();
< elseif( field.isLong    )>final long <field.name> = in.getLong();
< elseif( field.isUlong   )>final ulong <field.name> = in.getULong();
< elseif( field.isFloat   )>final float <field.name> = in.getFloat();
< elseif( field.isDouble  )>final double <field.name> = in.getDouble();
< elseif( field.isString  )>final String <field.name> = ByteBufferHelper.getString( in );
< elseif( field.isEnum    )>final <field.userType.name> <field.name> = <field.userType.name>.values()[in.get()];
< elseif( field.isStruct  )>final <field.userType.name> <field.name> = new <field.userType.name>();
<field.name>.get( in );
< endif>
>>



dispatcherImplOneInterface() ::= <<
//dispatcherImplOneInterface -- begin
private static enum <ifaceName>Event {

   <events.(ifaceName):{event|<event.name; format="ID">( <i> ),
}>   ;

   private final int _value;

   <ifaceName>Event( int value ) {
      _value = value;
   }

   static <ifaceName>Event valueOf( int value ) {
      for( final <ifaceName>Event e : values()) {
         if( e._value == value ) {
            return e;
         }
      }
      return null;
   }
}

<events.(ifaceName):{facet|< if( facet.isRequest )>
private static final byte EVENT_<ifaceName; format="ID">_RESPONSE_<facet.name; format="ID"> = <
                                              eventIDs.(ifaceName).(facet.name)>;
< endif>}>
private boolean dispatch( < if( offRequests.(ifaceName))>SocketAddress from, < endif><ifaceName>Event event, ByteBuffer in ) throws IOException {
   System.err.println( getClass().getName() + "|event = " + event );
   switch( event ) {
<events.(ifaceName):{facet|< if( facet.isData )>< else>
   case <facet.name; format="ID">:{
      < if( facet.isRequest )><facet.arguments.field:{field|<
         byteBufferGet( field )>}>< 
      elseif( facet.field )><facet.field:{field|<
         byteBufferGet( field )>}><
      endif><
      if( facet.isRequest )
>      final <types.(facet.type)> <facet.name> = new <types.(facet.type)>();
      _component.<facet.name>( <args( facet.arguments.field )>, <facet.name> );
      _out.clear();
      _out.put( INTRFC_<ifaceName; format="ID">_RESPONSES );
      _out.put( EVENT_<ifaceName; format="ID">_RESPONSE_<facet.name; format="ID"> );
      <facet.name>.put( _out );
      _out.flip();
      _channel.send( _out, from );
      System.err.printf( "<ifaceName>.<facet.name>|response sent to %s\n", from );
      < else
>      _component.<facet.name>(<args( facet.field )>);
      < endif>
      return true;\}
< endif>}>   default:
      System.err.printf( "%s.dispatch|Unexpected event: %s\n", getClass().getName(), event );
      return false;
   }
}
//dispatcherImplOneInterface -- end
>>



dispatcherImplResponse() ::= <<
// dispatcherImplResponse -- begin
private static enum <ifaceName>Response {

   <reqRequests.(ifaceName):{req|<req.name; format="ID">( <i> ),
}>   ;

   private final int _value;

   <ifaceName>Response( int value ) {
      _value = value;
   }

   static <ifaceName>Response valueOf( int value ) {
      for( final <ifaceName>Response e : values()) {
         if( e._value == value ) {
            return e;
         }
      }
      return null;
   }
}

private boolean dispatch( <ifaceName>Response event, ByteBuffer in ) throws IOException {
   System.err.println( getClass().getName() + "|event = " + event );
   switch( event ) {
<reqRequests.(ifaceName):{facet|
   case <facet.name; format="ID">:{
      final <types.(facet.type)> <facet.name> = new <types.(facet.type)>();
      <facet.name>.get( in );
      _component.<facet.name>Response( <facet.name> );
      return true;\}
}>   default:
      System.err.printf( "%s.dispatch|Unexpected event: %s\n", getClass().getName(), event );
      return false;
   }
}
// dispatcherImplResponse -- end
>>



dispatcherImplData() ::= <<
// dispatcherImplData -- begin
private static enum <iface.name>Data {

   <data.(iface):{dataType|<dataType.name; format="ID">( <eventIDs.(iface.name).(dataType.name)> ),
}>   ;

   private final int _value;

   <iface.name>Data( int value ) {
      _value = value;
   }

   static <iface.name>Data valueOf( int value ) {
      for( final <iface.name>Data e : values()) {
         if( e._value == value ) {
            return e;
         }
      }
      return null;
   }
}

private boolean dispatch( <iface.name>Data event, ByteBuffer in ) throws IOException {
   System.err.println( getClass().getName() + "|event = " + event );
   switch( event ) {
<data.(iface):{dataType|
   case <dataType.name; format="ID">:{
      _component.get<dataType.name; format="cap">().get( in );
      _component.<dataType.name; format="argument">Published();
      return true;\}
}>   default:
      System.err.printf( "%s.dispatch|Unexpected event: %s\n", getClass().getName(), event );
      return false;
   }
}
// dispatcherImplData -- end
>>



dispatcherImplementation(
   package, component, offers, requires, events, eventIDs, ifacesIDs,
   usedTypes, rawSize, respRawSize, offRequests, reqRequests, data, types
) ::= <<
package <package>;
//dispatcherImplementation
import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

import io.ByteBufferHelper;

public class <component.name>Dispatcher implements da.IDispatcher {

   < if( component.timeout )>private static final byte INTRFC_LOOPBACK = 0;
< endif>
<offers.keys:{ifaceName|
   private static final byte INTRFC_<ifaceName; format="ID,width"> = <offers.(ifaceName)>;
   < if( offRequests.(ifaceName))>private static final byte INTRFC_<ifaceName; format="ID">_RESPONSES = <
      ifacesIDs.( concat( ifaceName, "Response" ))>;
< endif>
}>   < reqRequests:{ifaceName|private static final byte INTRFC_<ifaceName; format="ID">_RESPONSES = <
        ifacesIDs.( concat( ifaceName, "Response" ))>;
}>
   private final DatagramChannel _channel;
   private final <component.name>Component _component;
< if( offRequests )
>   private final ByteBuffer      _out = ByteBuffer.allocate( <respRawSize> );
< endif>


<offers.keys:{ifaceName|
   <dispatcherImplOneInterface()>
}>
<reqRequests:{ifaceName|
   <dispatcherImplResponse()>
}>
<data:{iface|

   private static final byte INTRFC_<iface.name; format="ID"> = <requires.(iface.name)>;
   <dispatcherImplData()>
}>< if( component.timeout )>
   protected static enum LoopbackEvent {
      <component.timeout:{to|<to.name; format="ID">( <i> ),
}>      ;

      private final int _value;

      LoopbackEvent( int value ) {
         _value = value;
      }

      static LoopbackEvent valueOf( int value ) {
         for( final LoopbackEvent e : values()) {
            if( e._value == value ) {
               return e;
            }
         }
         return null;
      }
   }

   private boolean dispatch( LoopbackEvent event ) throws IOException {
      switch( event ) {
<component.timeout:{to|
      case <to.name; format="ID">:{
         _component.<to.name; format="argument">Elapsed();
         return true;\}
}>      default:
         System.err.printf( "%s.run|Unexpected event: %s\n", getClass().getName(), event );
         return false;
      }
   }

< endif>

   public <component.name>Dispatcher( DatagramChannel channel, <component.name>Component component ) {
      _channel   = channel;
      _component = component;
   }

< if( component.timeout )>   void loopback( LoopbackEvent event ) throws IOException {
      final ByteBuffer out = ByteBuffer.allocate( 2 );
      out.put( INTRFC_LOOPBACK );
      out.put((byte)event._value );
      out.flip();
      _channel.send( out, _channel.getLocalAddress());
   }

< endif>   @Override
   public void beforeDispatch() throws IOException {
      _component.beforeDispatch();
   }
   
   @Override
   public boolean hasDispatched( byte intrfc, byte event, SocketAddress from, ByteBuffer in ) throws IOException {
      switch( intrfc ) {
< if( component.timeout )>      case INTRFC_LOOPBACK: return dispatch( LoopbackEvent.valueOf( event ));
< endif><offers.keys:{ifaceName|
      case INTRFC_<ifaceName; format="ID">: return dispatch( <
         if( offRequests.(ifaceName))>from, < endif><ifaceName>Event.valueOf( event ), in );
}><reqRequests:{ifaceName|
      case INTRFC_<ifaceName; format="ID">_RESPONSES: return dispatch( <ifaceName>Response.valueOf( event ), in );
}><data:{iface|
      case INTRFC_<iface.name; format="ID">: return dispatch( <iface.name>Data.valueOf( event ), in );
}>      }
      return false;
   }

   @Override
   public void afterDispatch( boolean dispatched ) throws IOException {
      _component.afterDispatch( dispatched );
   }
}
>>



componentImplementation( package, component, requires, actions, offData, reqData, responses, imports ) ::= <<
package <package>;
//componentImplementation

import java.io.IOException;
< if( component.timeout )>
import java.time.Duration;

import util.Timeout;
< endif>
<imports:{type|import <type>;
}>

public abstract class <component.name>Component implements <
component.offers:{o|I<o.interface.name>}><
responses:{iface|< if(component.offers)>, < endif>I<iface.name>Responses}><
reqData:{iface|, I<iface.name>Data}> {

<component.timeout:{to|
   private static final Duration <to.name; format="ID">_DURATION = Duration.of<to.unit.toJava; format="cap">( <to.duration> );
}>
< if( component.timeout )>
   private <component.name>Dispatcher _dispatcher;

< endif>
<requires:{iface|
   protected I<iface.name> _<iface.name; format="argument">;
}><offData:{iface|
   protected <iface.name>Data _<iface.name; format="argument">Data;
}><
if( component.automaton )>   protected final Automaton _automaton = new Automaton( this );
< endif><reqData:{iface|<reqData.(iface):{data|
   protected <data.name; format="cap"> _<data.name; format="argument">;
}>}><component.timeout:{to|
   protected final Timeout _<to.name> = new Timeout( <to.name; format="ID">_DURATION, () -> loopback( <
      component.name>Dispatcher.LoopbackEvent.<to.name; format="ID"> ));
}>
   <component.timeout:{to|protected abstract void <to.name>Elapsed() throws IOException;
}>
   <actions:{action|protected abstract void <action>();
}>
   public void init() {}

< if( component.timeout )>
   private void loopback( <component.name>Dispatcher.LoopbackEvent event ) {
      try {
         _dispatcher.loopback( event );
      }
      catch( final Throwable t ) {
         t.printStackTrace();
      }
   }

   void set( <component.name>Dispatcher dispatcher ) {
      _dispatcher = dispatcher;
   }

< endif>
<requires:{iface|

   public void connect( I<iface.name> <iface.name; format="argument"> ) {
      _<iface.name; format="argument"> = <iface.name; format="argument">;
   \}

   public I<iface.name> get<iface.name>() {
      return _<iface.name; format="argument">;
   \}
}><reqData:{iface|<reqData.(iface):{data|

   public void connect( <data.name; format="cap"> <data.name; format="argument"> ) {
      _<data.name; format="argument"> = <data.name; format="argument">;
   \}

   public <data.name; format="cap"> get<data.name; format="cap">() {
      return _<data.name; format="argument">;
   \}}>}>
<offData:{iface|
   public void connect( <iface.name>Data data ) {
      _<iface.name; format="argument">Data = data;
   \}

   public <iface.name>Data get<iface.name; format="cap">Data() {
      return _<iface.name; format="argument">Data;
   \}}>

   protected void beforeDispatch() throws IOException {}
   
   protected void afterDispatch( boolean dispatched ) throws IOException {}
}
>>



dataWriter( package, interface, ifaceID, data, dataID, rawSize, types ) ::= <<
package <package>;

// dataWriter

import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

public class <interface.name>Data {

   private static final byte <interface.name; format="ID"> = <ifaceID>;

<data:{dataType|
   private static final byte <dataType.name; format="ID"> = <dataID.(dataType.name)>;

   public final <types.(dataType.type)> _<dataType.name> = new <types.(dataType.type)>();
}>
   private final DatagramChannel _channel;
   private final SocketAddress   _target;
   private final ByteBuffer      _out = ByteBuffer.allocate( <rawSize> );

   public UniteDeTraitementData( DatagramChannel channel, SocketAddress target ) {
      _channel = channel;
      _target  = target;
   }

<data:{dataType|
   public void publish<dataType.name; format="cap">() throws IOException {
      _out.clear();
      _out.put( <interface.name; format="ID"> );
      _out.put( <dataType.name; format="ID"> );
      _<dataType.name; format="argument">.put( _out );
      _out.flip();
      final int size = _out.remaining();
      _channel.send( _out, _target );
      System.err.printf( "%s.publish<dataType.name; format="cap">|%d byte(s) sent to %s\n", getClass().getName(), size, _target );
   \}
}>}
>>



dataReader( package, interface, data  ) ::= <<
package <package>;

// dataReader

import java.io.IOException;

public interface I<interface.name>Data {

<data:{dataType|
   void <dataType.name; format="argument">Published() throws IOException;
}>}
>>



automaton( package, component, stateFullName, stateShortName, eventFullName, eventShortName ) ::= <<
package <package>;

import <stateFullName>;
import <eventFullName>;

public class Automaton extends util.Automaton\<<stateShortName>, <eventShortName>\> {

   public Automaton( <component.name>Component component ) {
      super( <stateShortName>.<component.automaton.initial> );

      <component.automaton.transition:{transition|add( <
         stateShortName>.<transition.from>, <
         eventShortName>.<transition.event>, <
         stateShortName>.<transition.futur> );
}>
      <component.automaton.shortcut:{shortcut|add( <
         eventShortName>.<shortcut.event>, <
         stateShortName>.<shortcut.futur> );
}>
      <component.automaton.onEntryOrOnExit:{elt|add<elt.name.localPart; format="UpperCamelCase">( <
         stateShortName>.<elt.value.state>, component::<
         elt.value.action> );
}>   }
}
>>



componentFactory( package, process, instancesCount, processes, offData, reqData, instancesByName, dataConsumer, modules, types ) ::= <<
package <package>;
// ComponentFactory
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.StandardProtocolFamily;
import java.net.StandardSocketOptions;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;
import java.util.HashSet;
import java.util.Set;

public final class ComponentFactory extends Thread {

   private final da.IDispatcher[] _dispatchers = new da.IDispatcher[<instancesCount>];
   private final DatagramChannel  _channel;

<process.instance:{instance|
   private final <modules.(instance.component)>.<instance.component.name> _<instance.name; format="argument"
      > = new <modules.(instance.component)>.<instance.component.name>();
}>
   public ComponentFactory() throws IOException {
      _channel = DatagramChannel
         .open     ( StandardProtocolFamily.INET )
         .setOption( StandardSocketOptions.SO_REUSEADDR, true )
         .bind     ( new InetSocketAddress( "<process.address>", <process.port> ));
<process.instance:{instance|
      connect<instance.name; format="cap">();
}><process.instance:{instance|
      _<instance.name; format="argument">.init();
}>      setName( getClass().getName());
      setDaemon( true );
      start();
   }

<process.instance:{instance|
   private void connect<instance.name; format="cap">() {
<reqData:{iface|<reqData.(iface):{data|
      final <types.(data.type)> <data.name; format="argument"> = new <types.(data.type)>();
      _<instance.name; format="argument">.connect( <data.name; format="argument"> );
}>}><offData:{iface|
<dataConsumer.(iface).(instance.name):{process|
      _<instance.name; format="argument">.connect( new <modules.(instance.component)>.<
         iface.name>Data( _channel, new InetSocketAddress( "<process.address>", <process.port> )));
}>}><
process.instance:{instance|<instance.requires:{requires|
      _<instance.name; format="argument">.connect( new <
         modules.(instance.component)>.<requires.interface.name>( _channel, new InetSocketAddress( "<
         processes.(instancesByName.(requires.toInstance)).address>", <processes.(instancesByName.(requires.toInstance)).port> )));
}>}>      _dispatchers[<i0>] = new <
             modules.(instance.component)>.<instance.component.name>Dispatcher( _channel, _<instance.name; format="argument"> );
   \}

   public <modules.(instance.component)>.<instance.component.name> get<instance.name; format="cap">() {
      return _<instance.name; format="argument">;
   \}

}>   @Override
   public final void run() {
      final ByteBuffer in = ByteBuffer.allocate( 64*1024 );
      for(;;) {
         try {
            in.clear();
            final SocketAddress from = _channel.receive( in );
            in.flip();
            final byte intrfc = in.get();
            final byte event  = in.get();
            for( final da.IDispatcher dispatcher : _dispatchers ) {
               dispatcher.beforeDispatch();
            }
            boolean dispatched = false;
            for( final da.IDispatcher dispatcher : _dispatchers ) {
               if( dispatcher.hasDispatched( intrfc, event, from, in )) {
                  dispatched = true;
                  break;
               }
            }
            for( final da.IDispatcher dispatcher : _dispatchers ) {
               dispatcher.afterDispatch( dispatched );
            }
         }
         catch( final IOException e ) {
            e.printStackTrace();
            System.exit( 1 );
         }
      }
   }
}
>>
