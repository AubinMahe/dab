group Java;



type( field ) ::= <<
< if(     field.isBoolean )>boolean<
  elseif( field.isByte    )>byte   <
  elseif( field.isShort   )>short  <
  elseif( field.isUshort  )>short  <
  elseif( field.isInt     )>int    <
  elseif( field.isUint    )>int    <
  elseif( field.isLong    )>long   <
  elseif( field.isUlong   )>long   <
  elseif( field.isFloat   )>float  <
  elseif( field.isDouble  )>double <
  elseif( field.isString  )>String <
  elseif( field.isEnum    )><field.userType.name><
  elseif( field.isStruct  )><field.userType.name><
  endif>
>>



signature( fields ) ::= <<
< first( fields ):{field|<trim((type(field)))> <field.name>}><
  rest ( fields ):{field|, <trim((type(field)))> <field.name>}>
>>



args( fields ) ::= <<
< first( fields ):{field|<field.name>}><
  rest ( fields ):{field|, <field.name>}>
>>



byteBufferPut( fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>ByteBufferHelper.putBoolean( _out, <field.name> );
< elseif( field.isByte    )>_out.put( <field.name> );
< elseif( field.isShort   )>_out.putShort( <field.name> );
< elseif( field.isUshort  )>_out.putShort( <field.name> );
< elseif( field.isInt     )>_out.putInt( <field.name> );
< elseif( field.isUint    )>_out.putInt( <field.name> );
< elseif( field.isLong    )>_out.putLong( <field.name> );
< elseif( field.isUlong   )>_out.putLong( <field.name> );
< elseif( field.isFloat   )>_out.putFloat( <field.name> );
< elseif( field.isDouble  )>_out.putDouble( <field.name> );
< elseif( field.isEnum    )>_out.put((byte)<field.name>.ordinal());
< elseif( field.isString  )>ByteBufferHelper.putString( _out, <field.name> );
< elseif( field.isStruct  )><field.name>.put( _out );
< endif>
}>
>>



enum( package, enum ) ::= <<
package <package>;

import java.nio.ByteBuffer;

import io.ByteBufferHelper;

public enum <enum.name> {

   <enum.literal:{literal|<literal.name; format="ID">,
}>}
>>



struct( package, struct, maxLength, maxStrLength ) ::= <<
package <package>;

import java.nio.ByteBuffer;

import io.ByteBufferHelper;

public class <struct.name> {

<struct.field:{field|
   public < if( field.isBoolean )>boolean <field.name>;
< elseif(       field.isByte    )>byte    <field.name>;
< elseif(       field.isShort   )>short   <field.name>;
< elseif(       field.isUshort  )>short   <field.name>;
< elseif(       field.isInt     )>int     <field.name>;
< elseif(       field.isUint    )>int     <field.name>;
< elseif(       field.isLong    )>long    <field.name>;
< elseif(       field.isUlong   )>long    <field.name>;
< elseif(       field.isFloat   )>float   <field.name>;
< elseif(       field.isDouble  )>double  <field.name>;
< elseif(       field.isString  )>String  <field.name>;
< elseif(       field.isEnum    )><field.userType.name> <field.name>;
< elseif(       field.isStruct  )>final <field.userType.name> <field.name> = new <field.userType.name>();
< endif>
}>
   public void put( ByteBuffer target ) {
      <struct.field:{field|
< if(     field.isBoolean )>ByteBufferHelper.putBoolean( target, <field.name> );
< elseif( field.isByte    )>target.put       ( <field.name> );
< elseif( field.isShort   )>target.putShort  ( <field.name> );
< elseif( field.isUshort  )>target.putShort  ( <field.name> );
< elseif( field.isInt     )>target.putInt    ( <field.name> );
< elseif( field.isUint    )>target.putInt    ( <field.name> );
< elseif( field.isLong    )>target.putLong   ( <field.name> );
< elseif( field.isUlong   )>target.putLong   ( <field.name> );
< elseif( field.isFloat   )>target.putFloat  ( <field.name> );
< elseif( field.isDouble  )>target.putDouble ( <field.name> );
< elseif( field.isEnum    )>target.put       ((byte)<field.name>.ordinal());
< elseif( field.isString  )>ByteBufferHelper.putString( target, <field.name> );
< elseif( field.isStruct  )><field.name>.put( target );
< endif>
}>   }

   public void get( ByteBuffer source ) {
      <struct.field:{field|
< if(     field.isBoolean )><field.name; format="width"> = ByteBufferHelper.getBoolean( source );
< elseif( field.isByte    )><field.name; format="width"> = source.get();
< elseif( field.isShort   )><field.name; format="width"> = source.getShort();
< elseif( field.isUshort  )><field.name; format="width"> = source.getShort();
< elseif( field.isInt     )><field.name; format="width"> = source.getInt();
< elseif( field.isUint    )><field.name; format="width"> = source.getInt();
< elseif( field.isLong    )><field.name; format="width"> = source.getLong();
< elseif( field.isUlong   )><field.name; format="width"> = source.getLong();
< elseif( field.isFloat   )><field.name; format="width"> = source.getFloat();
< elseif( field.isDouble  )><field.name; format="width"> = source.getDouble();
< elseif( field.isEnum    )><field.name; format="width"> = <field.userType.name>.values()[source.get()];
< elseif( field.isString  )><field.name; format="width"> = ByteBufferHelper.getString( source );
< elseif( field.isStruct  )><field.name; format="width">.put( source );
< endif>
}>   }
}
>>



requiredInterface( package, usedTypes, ifaceName, rawSize, iface ) ::= <<
package <package>;
// requiredInterface

import java.io.IOException;

public interface I<ifaceName> {

   <iface.eventOrRequest:{eor|void <eor.name>(<
if( eor.arguments )><
    signature( eor.arguments.field )><
else><
    signature( eor.field )><
endif>) throws IOException;
}>}
>>



requiredImplementation( package, usedTypes, ifaceName, rawSize, iface, ifaceID ) ::= <<
package <package>;
//requiredImplementation
import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

import io.ByteBufferHelper;

import <package>.I<ifaceName>;

<usedTypes:{type|import <package>.<type>;
}>
public class <ifaceName> implements I<ifaceName> {

   private static final byte <iface.name; format="ID"> = <ifaceID>;
   <iface.eventOrRequest:{event|private static final byte <event.name; format="ID"> = <i>;
}>
   private final DatagramChannel _channel;
   private final SocketAddress   _target;
   private final ByteBuffer      _out = ByteBuffer.allocate( <rawSize> );

   public <ifaceName>( DatagramChannel channel, SocketAddress target ) {
      _channel = channel;
      _target  = target;
   }
<iface.eventOrRequest:{eor|


   @Override
   public void <eor.name>(<
if( eor.arguments )><
    signature( eor.arguments.field )><
else><
    signature( eor.field )><
endif>) throws IOException {
      _out.clear();
      _out.put( <iface.name; format="ID"> );
      _out.put( <eor.name; format="ID"> );
      < if( eor.arguments )><
           byteBufferPut( eor.arguments.field )><
        else><
           byteBufferPut( eor.field )><
        endif>
      _out.flip();
      final int size = _out.remaining();
      _channel.send( _out, _target );
      System.err.printf( "<ifaceName>.<eor.name>|%d byte(s) sent to %s\n", size, _target );
   \}
}>}
>>



offeredInterface( package, name, usedTypes, eventsOrRequests ) ::= <<
package <package>;
// offeredInterface

import java.io.IOException;

public interface I<name> {

   <eventsOrRequests:{eor|void <eor.name>(<
if( eor.arguments )><
    signature( eor.arguments.field )>, <name><eor.name; format="cap">Response reponse<
else><
    signature( eor.field )><
endif>) throws IOException;
}>}
>>



byteBufferGet( field ) ::= <<
<     if( field.isBoolean )>final boolean <field.name> = ByteBufferHelper.getBoolean( _in );
< elseif( field.isByte    )>final byte <field.name> = _in.get();
< elseif( field.isShort   )>final short <field.name> = _in.getShort();
< elseif( field.isUshort  )>final ushort <field.name> = _in.getUShort();
< elseif( field.isInt     )>final int <field.name> = _in.getInt();
< elseif( field.isUint    )>final uint <field.name> = _in.getUInt();
< elseif( field.isLong    )>final long <field.name> = _in.getLong();
< elseif( field.isUlong   )>final ulong <field.name> = _in.getULong();
< elseif( field.isFloat   )>final float <field.name> = _in.getFloat();
< elseif( field.isDouble  )>final double <field.name> = _in.getDouble();
< elseif( field.isString  )>final String <field.name> = ByteBufferHelper.getString( _in );
< elseif( field.isEnum    )>final <field.userType.name> <field.name> = <field.userType.name>.values()[_in.get()];
< elseif( field.isStruct  )>final <field.userType.name> <field.name> = new <field.userType.name>();
<field.name>.get( _in );
< endif>
>>



dispatcherImplOneInterface() ::= <<
//dispatcherImplOneInterface
private static enum <ifaceName>Event {

   <events.(ifaceName):{event|<event.name; format="ID">( <i> ),
}>   ;

   private final int _value;

   <ifaceName>Event( int value ) {
      _value = value;
   }

   static <ifaceName>Event valueOf( int value ) {
      for( final <ifaceName>Event e : values()) {
         if( e._value == value ) {
            return e;
         }
      }
      return null;
   }
}

<events.(ifaceName):{eventOrRequest|< if( eventOrRequest.response )>
private static final byte EVENT_<ifaceName; format="ID">_RESPONSES_<eventOrRequest.name; format="ID"> = <eventIDs.(ifaceName).(eventOrRequest.name)>;
< endif>}>
private boolean dispatch( < if( requests.(ifaceName))>SocketAddress from, < endif><ifaceName>Event event ) throws IOException {
   System.err.println( getClass().getName() + "|event = " + event );
   switch( event ) {
<events.(ifaceName):{eventOrRequest|
   case <eventOrRequest.name; format="ID">:{
      < if( eventOrRequest.arguments )><
         eventOrRequest.arguments.field:{field|<byteBufferGet(field)>}>< 
      else><
         eventOrRequest.field:{field|<byteBufferGet(field)>}><
      endif><
      if( eventOrRequest.response )
>      final <ifaceName><eventOrRequest.name; format="cap">Response response = new <ifaceName><eventOrRequest.name; format="cap">Response();
      _listener.<eventOrRequest.name>( <args( eventOrRequest.arguments.field )>, response );
      _out.clear();
      _out.put( INTRFC_<ifaceName; format="ID">_RESPONSES );
      _out.put( EVENT_<ifaceName; format="ID">_RESPONSES_<eventOrRequest.name; format="ID"> );
      response.put( _out );
      _out.flip();
      _channel.send( _out, from );
      System.err.printf( "SiteCentral.getInformations|response sent to %s\n", from );
      < else
>      _listener.<eventOrRequest.name>( <args( eventOrRequest.field )> );
      < endif>
      return true;\}
}>      default:
      System.err.printf( "%s.run|Unexpected event: %s\n", getClass().getName(), event );
      return false;
   }
}
>>

dispatcherImplementation( package, compName, ifaces, events, eventIDs, usedTypes, rawSize, respRawSize, requests ) ::= <<
package <package>;
//dispatcherImplementation
import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

import io.ByteBufferHelper;

public class <compName>Dispatcher {

   <ifaces.keys:{ifaceName|private static final byte INTRFC_<ifaceName; format="ID,width"> = <ifaces.(ifaceName)>;
}><ifaces.keys:{ifaceName|
   <dispatcherImplOneInterface()>
}>
   private final ByteBuffer      _in  = ByteBuffer.allocate( <rawSize> );
< if( requests )
>   private final ByteBuffer      _out = ByteBuffer.allocate( <respRawSize> );
< endif>   private final DatagramChannel _channel;
   private final <compName>Component _listener;

   public <compName>Dispatcher( DatagramChannel channel, <compName>Component listener ) {
      _channel  = channel;
      _listener = listener;
   }

   public boolean hasDispatched() throws IOException {
      _in.clear();
      final SocketAddress from = _channel.receive( _in );
      _in.flip();
      final byte intrfc = _in.get();
      final byte event  = _in.get();
      System.err.printf( "%s.run|intrfc = %d, event = %d, %d byte(s) remaining in message\n",
         getClass().getName(), intrfc, event, _in.remaining());
      switch( intrfc ) {
<ifaces.keys:{ifaceName|
      case INTRFC_<ifaceName; format="ID">: return dispatch( < if( requests.(ifaceName))>from, < endif><ifaceName>Event.valueOf( event ));
}>      }
      return false;
   }
}
>>



componentImplementation( package, component, responses, requires, instancesByName, instances, actions ) ::= <<
package <package>;
//componentImplementation
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.StandardProtocolFamily;
import java.net.StandardSocketOptions;
import java.nio.channels.DatagramChannel;

public abstract class <component.name>Component implements Runnable<
component.offers:          {o|, I<o.interface.name>}><
responses.(component.name):{r|, I<r.interface.name>}> {

< first(requires):{req|
   <requires.(req):{rt|protected final <rt.interface.name> _<rt.interface.name; format="argument">;
}>}>< if( component.automaton )>   protected final Automaton _automaton = new Automaton( this );
< endif>   protected final <component.name>Dispatcher _dispatcher;

   private DatagramChannel _channel;
   private boolean         _running;

   public <component.name>Component( String name ) throws IOException {
      _running = false;
< if( requires )>
      InetSocketAddress < first(requires):{req|<
      first( requires.(req) ):{rt|<rt.interface.name; format="argument">}><
      rest ( requires.(req) ):{rt|, <rt.interface.name; format="argument">}>}>;
< endif>
< first(instances):{instance|
      if( name.equals( "<instance.name>" )) {
         _channel = DatagramChannel
            .open     ( StandardProtocolFamily.INET )
            .setOption( StandardSocketOptions.SO_REUSEADDR, true )
            .bind     ( new InetSocketAddress( "<instance.address>", <instance.port> ));
         <requires.(instance.name):{req|<req.interface.name; format="argument"> = new InetSocketAddress( "<
            instancesByName.(req.toInstance.name).address>", <
            instancesByName.(req.toInstance.name).port> );
}>}>      < rest(instances):{instance|\}
      else if( name.equals( "<instance.name>" )) {
         _channel = DatagramChannel
            .open     ( StandardProtocolFamily.INET )
            .setOption( StandardSocketOptions.SO_REUSEADDR, true )
            .bind     ( new InetSocketAddress( "<instance.address>", <instance.port> ));
         <requires.(instance.name):{req|<req.interface.name; format="argument"> = new InetSocketAddress( "<
            instancesByName.(req.toInstance.name).address>", <
            instancesByName.(req.toInstance.name).port> );
}>}>      }
      else {
         throw new IllegalArgumentException( "'" + name + "' isn't a valid name defined in XML application file!" );
      }
      < first(requires):{req|<
      requires.(req):{rt|_<rt.interface.name; format="argument"> = new <
        rt.interface.name>( _channel, <rt.interface.name; format="argument"> );
}>}>      _dispatcher = new <component.name>Dispatcher( _channel, this );
   }

   protected abstract void afterDispatch() throws IOException;
<actions:{action|
   protected abstract void <action>();
}>
   protected void terminate() {
      _running = false;
   }

   @Override
   public final void run() {
      _running = true;
      while( _running ) {
         try {
            if( _dispatcher.hasDispatched()) {
               afterDispatch();
            }
         }
         catch( final IOException e ) {
            e.printStackTrace();
            terminate();
         }
      }
   }
}
>>



automaton( package, component ) ::= <<
package <package>;

public class Automaton extends util.Automaton\<<component.automaton.stateEnum.name>, <component.automaton.eventEnum.name>\> {

   public Automaton( <component.name>Component component ) {
      super( <component.automaton.stateEnum.name>.<component.automaton.initial> );

      <component.automaton.transition:{transition|add( <
         component.automaton.stateEnum.name>.<transition.from>, <
         component.automaton.eventEnum.name>.<transition.event>, <
         component.automaton.stateEnum.name>.<transition.futur> );
}>
      <component.automaton.shortcut:{shortcut|add( <
         component.automaton.eventEnum.name>.<shortcut.event>, <
         component.automaton.stateEnum.name>.<shortcut.futur> );
}>
      <component.automaton.onEntryOrOnExit:{elt|add<elt.name.localPart; format="UpperCamelCase">( <
         component.automaton.stateEnum.name>.<elt.value.state>, component::<
         elt.value.action> );
}>   }
}
>>
