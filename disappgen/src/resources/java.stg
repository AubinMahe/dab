group Java;



concat(a,b) ::= <<
<a><b>
>>



type( field ) ::= <<
< if(     field.isBoolean )>boolean<
  elseif( field.isByte    )>byte   <
  elseif( field.isShort   )>short  <
  elseif( field.isUshort  )>short  <
  elseif( field.isInt     )>int    <
  elseif( field.isUint    )>int    <
  elseif( field.isLong    )>long   <
  elseif( field.isUlong   )>long   <
  elseif( field.isFloat   )>float  <
  elseif( field.isDouble  )>double <
  elseif( field.isString  )>String <
  elseif( field.isEnum    )><types.(field.userType)><
  elseif( field.isStruct  )><types.(field.userType)><
  endif>
>>



signature( fields ) ::= <<
<fields:{field|<trim((type(field)))> <field.name>}; separator=", ">
>>



dataGen( visibility, field ) ::= <<
<     if( field.isBoolean )><visibility> boolean <field.name>;
< elseif( field.isByte    )><visibility> byte <field.name>;
< elseif( field.isShort   )><visibility> short <field.name>;
< elseif( field.isUshort  )><visibility> ushort <field.name>;
< elseif( field.isInt     )><visibility> int <field.name>;
< elseif( field.isUint    )><visibility> uint <field.name>;
< elseif( field.isLong    )><visibility> long <field.name>;
< elseif( field.isUlong   )><visibility> ulong <field.name>;
< elseif( field.isFloat   )><visibility> float <field.name>;
< elseif( field.isDouble  )><visibility> double <field.name>;
< elseif( field.isString  )><visibility> String <field.name>;
< elseif( field.isEnum    )><visibility> <field.userType.name> _<field.name> = <field.userType.name>.values()[0];
< elseif( field.isStruct  )><visibility> final <field.userType.name> _<field.name> = new <field.userType.name>();
< endif>
>>



byteBufferPut( fields ) ::= <<
<fields:{field|
< if(     field.isBoolean )>ByteBufferHelper.putBoolean( _out, <field.name> );
< elseif( field.isByte    )>_out.put( <field.name> );
< elseif( field.isShort   )>_out.putShort( <field.name> );
< elseif( field.isUshort  )>_out.putShort( <field.name> );
< elseif( field.isInt     )>_out.putInt( <field.name> );
< elseif( field.isUint    )>_out.putInt( <field.name> );
< elseif( field.isLong    )>_out.putLong( <field.name> );
< elseif( field.isUlong   )>_out.putLong( <field.name> );
< elseif( field.isFloat   )>_out.putFloat( <field.name> );
< elseif( field.isDouble  )>_out.putDouble( <field.name> );
< elseif( field.isEnum    )>_out.put((byte)<field.name>.ordinal());
< elseif( field.isString  )>ByteBufferHelper.putString( _out, <field.name> );
< elseif( field.isStruct  )><field.name>.put( _out );
< endif>
}>
>>



enum( package, enum ) ::= <<
package <package>;
// enum

import java.nio.ByteBuffer;

import io.ByteBufferHelper;

public enum <enum.name> {

   <enum.literal:{literal|<literal.name; format="ID">,
}>}
>>



struct( package, struct, maxLength, maxStrLength, types ) ::= <<
package <package>;
// struct

import java.nio.ByteBuffer;

import io.ByteBufferHelper;

public class <struct.name> {

<struct.field:{field|
   public < if( field.isStruct )>final <type( field )> <field.name> = new <type( field )>();
< else><type( field )> <field.name>;
< endif>
}>
   public void set( <struct.name> source ) {
      <struct.field:{field|
< if( field.isStruct  )><field.name>.set( source.<field.name> );
< else><field.name> = source.<field.name>;
< endif>
}>   }

   public void put( ByteBuffer target ) {
      <struct.field:{field|
< if(     field.isBoolean )>ByteBufferHelper.putBoolean( target, <field.name> );
< elseif( field.isByte    )>target.put       ( <field.name> );
< elseif( field.isShort   )>target.putShort  ( <field.name> );
< elseif( field.isUshort  )>target.putShort  ( <field.name> );
< elseif( field.isInt     )>target.putInt    ( <field.name> );
< elseif( field.isUint    )>target.putInt    ( <field.name> );
< elseif( field.isLong    )>target.putLong   ( <field.name> );
< elseif( field.isUlong   )>target.putLong   ( <field.name> );
< elseif( field.isFloat   )>target.putFloat  ( <field.name> );
< elseif( field.isDouble  )>target.putDouble ( <field.name> );
< elseif( field.isEnum    )>target.put       ((byte)<field.name>.ordinal());
< elseif( field.isString  )>ByteBufferHelper.putString( target, <field.name> );
< elseif( field.isStruct  )><field.name>.put( target );
< endif>
}>   }

   public void get( ByteBuffer source ) {
      <struct.field:{field|
< if(     field.isBoolean )><field.name; format="width"> = ByteBufferHelper.getBoolean( source );
< elseif( field.isByte    )><field.name; format="width"> = source.get();
< elseif( field.isShort   )><field.name; format="width"> = source.getShort();
< elseif( field.isUshort  )><field.name; format="width"> = source.getShort();
< elseif( field.isInt     )><field.name; format="width"> = source.getInt();
< elseif( field.isUint    )><field.name; format="width"> = source.getInt();
< elseif( field.isLong    )><field.name; format="width"> = source.getLong();
< elseif( field.isUlong   )><field.name; format="width"> = source.getLong();
< elseif( field.isFloat   )><field.name; format="width"> = source.getFloat();
< elseif( field.isDouble  )><field.name; format="width"> = source.getDouble();
< elseif( field.isEnum    )><field.name; format="width"> = <types.(field.userType)>.values()[source.get()];
< elseif( field.isString  )><field.name; format="width"> = ByteBufferHelper.getString( source );
< elseif( field.isStruct  )><field.name; format="width">.get( source );
< endif>
}>   }
}
>>



interfacesEnum( package, interfaces ) ::= <<
package <package>;

import java.nio.ByteBuffer;

public enum Interfaces {

   LOOPBACK( 0 ),
   <interfaces:{ifaceName|<ifaceName; format="ID">( <interfaces.(ifaceName)> )}; separator=",\n">
   ;

   private final byte _value;

   Interfaces( int value ) {
      _value = (byte)value;
   }

   static public Interfaces valueOf( int value ) {
      for( final Interfaces e : values()) {
         if( e._value == value ) {
            return e;
         }
      }
      return null;
   }

   public void put( ByteBuffer target ) {
      target.put( _value );
   }
}
>>



eventsEnum( package, ifaceName, className, facets, types, isEvent ) ::= <<
package <package>;

import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.util.Deque;

import io.ByteBufferHelper;

public enum <className> {

   <facets:{facet|<facet.name; format="ID">( <i> )}; separator=",\n">
   ;

   private final byte _value;

   <className>( int value ) {
      _value = (byte)value;
   }

   static public <className> valueOf( int value ) {
      for( final <className> e : values()) {
         if( e._value == value ) {
            return e;
         }
      }
      return null;
   }
< if( isEvent )>
<facets:{facet|
< if( facet.isRequest )>
   public static void <facet.name>( <signature(facet.arguments.field)>, byte from, byte to, ByteBuffer _out ) {
< else>
   public static void <facet.name>( <signature(facet.field)>< if(facet.field)>, < endif>byte to, ByteBuffer _out ) {
< endif>
      _out.clear();
      Interfaces.<className; format="ID">.put( _out );
      _out.put( <facet.name; format="ID">._value );
      _out.put( to );
< if( facet.isRequest )>
      _out.put( from );
      <byteBufferPut( facet.arguments.field )>
< else>
      <byteBufferPut( facet.field )>
< endif>
      _out.flip();
   \}
}>
< else>
<facets:{facet|
   // Request response or data published
   public static void <facet.name>( <types.(facet.type)> <facet.name>, byte to, ByteBuffer _out ) {
      _out.clear();
      Interfaces.<className; format="ID">.put( _out );
      _out.put( <facet.name; format="ID">._value );
      _out.put( to );
      <facet.name>.put( _out );
      _out.flip();
   \}
}>
< endif>

   public static boolean enqueue(
      SocketAddress                         from,
      byte                                  event,
      byte                                  instance,
      ByteBuffer                            in,
      Deque\<da.FacetMessage\<Interfaces, ?\>\> mainQueue )
   {
      final <className> evt = <className>.valueOf( event );
      if( evt == null ) {
         System.err.printf( "<className>.enqueue|%d is out of range\n", event );
      }
      else {
         switch( evt ) {
<facets:{facet|
         case <facet.name; format="ID">:{
< if( facet.isData )>
            <types.(facet.type)> <facet.name> = new <types.(facet.type)>();
            <facet.name>.get( in );
            mainQueue.add< if( facet.isImmediate )>First< endif>( new da.FacetMessage1\<>( from, Interfaces.<
                (concat(ifaceName,"Data")); format="ID">, evt, instance, <facet.name> ));
            return <facet.isActivatingOrImmediate>; \}
< elseif( facet.isRequest )><
if( isEvent )>
            final byte fromInstance = in.get();
            <facet.arguments.field:{field|<byteBufferGet( field )
>}>            var msg = new da.FacetMessage< length(facet.arguments.field)>\<>( from, Interfaces.<
                    (concat(ifaceName,"Event")); format="ID">, evt, instance, <
                    facet.arguments.field:{field|<field.name>}; separator=", "> );
            msg._fromInstance = fromInstance;
            mainQueue.add< if( facet.isImmediate )>First< endif>( msg );
< else>
            <types.(facet.type)> <facet.name> = new <types.(facet.type)>();
            <facet.name>.get( in );
            mainQueue.add< if( facet.isImmediate )>First< endif>( new da.FacetMessage1\<>( from, Interfaces.<
                (concat(ifaceName,"Request")); format="ID">, evt, instance, <facet.name> ));
< endif>
            return <facet.isActivatingOrImmediate>;\}
< elseif( facet.field )>
            <facet.field:{field|<byteBufferGet( field )>}
>            mainQueue.add< if( facet.isImmediate )>First< endif>( new da.FacetMessage< length(facet.field)>\<>( from, Interfaces.<
                (concat(ifaceName,"Event")); format="ID">, evt, instance, <
                facet.field:{field|<field.name>}; separator=", "> ));
            return <facet.isActivatingOrImmediate>;\}
< else>
            mainQueue.add< if( facet.isImmediate )>First< endif>( new da.FacetMessage\<>( from, Interfaces.<
                (concat(ifaceName,"Event")); format="ID">, evt, instance ));
            return <facet.isActivatingOrImmediate>;\}
< endif>
}>         }
      }
      return false;
   }
}
>>



responses( package, ifaceName, requests, types ) ::= <<
package <package>;
// responses

import java.io.IOException;

public interface I<ifaceName>Responses {

<requests:{request|
   public void <request.name>Response( <types.(request.type)> <request.name> ) throws IOException;
}>}
>>



requiredInterface( package, iface ) ::= <<
package <package>;
// requiredInterface

import java.io.IOException;

public interface I<iface.name> {

<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>
   void <facet.name; format="argument">(<
if( facet.isRequest )><
      signature( facet.arguments.field )><
else><
      signature( facet.field )><
endif>) throws IOException;< endif>
}>
}
>>



requiredImplementation( package, internalPckg, iface, rawSize, imports, hasRequest ) ::= <<
package <package>;
// requiredImplementation

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

import da.Targets;
import io.ByteBufferHelper;

<imports:{type|import <type>;
}>
public class <iface.name> implements I<iface.name> {

   private final DatagramChannel _channel;
   private final byte            _from;
   private final Targets[]       _targets;
   private final ByteBuffer      _out = ByteBuffer.allocate( <rawSize>< if( hasRequest )> + 1< endif> );

   public <iface.name>( DatagramChannel channel, byte from, Targets ... targets ) {
      _channel = channel;
      _from    = from;
      _targets = targets;
   }
<iface.eventOrRequestOrData:{facet|< if( facet.isData )>< else>

   @Override
   public void <facet.name; format="argument">(<
if( facet.isRequest )><
    signature( facet.arguments.field )><
else><
    signature( facet.field )><
endif>) throws IOException {
      for( final Targets targets : _targets ) {
         for( final byte to : targets._instances ) {
            <internalPckg>.<concat( iface.name, "Event" )>.<facet.name>( <
if( facet.isRequest )><
                facet.arguments.field:{field|<field.name>}; separator=","><
                if( facet.arguments.field )>, < endif>_from, to, _out );
< else><
                facet          .field:{field|<field.name>}; separator=","><
                if( facet          .field )>, < endif>to, _out );
< endif>
            final int size = _out.remaining();
            _channel.send( _out, targets._process );
            System.err.printf( "<iface.name>.<facet.name>|%d byte(s) sent from instance %d to instance %d @ %s\n",
               size, _from, to, targets._process );
         \}
      \}
   \}< endif>
}>
}
>>



offeredInterface( package, ifaceName, facets, types ) ::= <<
package <package>;
// offeredInterface

import java.io.IOException;

public interface I<ifaceName> {

<facets:{facet|<
if( facet.isData )><
else>
   void <facet.name>(<
   if( facet.isRequest )><
      if( facet.arguments )> <signature( facet.arguments.field )>, <types.(facet.type)> <facet.name> <
      else> <types.(facet.type)> <facet.name> <
      endif><
   else><signature( facet.field )><
   endif>) throws IOException;<
endif>
}>
}
>>



byteBufferGet( field ) ::= <<
<     if( field.isBoolean )>final boolean <field.name> = ByteBufferHelper.getBoolean( in );
< elseif( field.isByte    )>final byte <field.name> = in.get();
< elseif( field.isShort   )>final short <field.name> = in.getShort();
< elseif( field.isUshort  )>final ushort <field.name> = in.getUShort();
< elseif( field.isInt     )>final int <field.name> = in.getInt();
< elseif( field.isUint    )>final uint <field.name> = in.getUInt();
< elseif( field.isLong    )>final long <field.name> = in.getLong();
< elseif( field.isUlong   )>final ulong <field.name> = in.getULong();
< elseif( field.isFloat   )>final float <field.name> = in.getFloat();
< elseif( field.isDouble  )>final double <field.name> = in.getDouble();
< elseif( field.isString  )>final String <field.name> = ByteBufferHelper.getString( in );
< elseif( field.isEnum    )>final <field.userType.name> <field.name> = <field.userType.name>.values()[in.get()];
< elseif( field.isStruct  )>final <field.userType.name> <field.name> = new <field.userType.name>();
<field.name>.get( in );
< endif>
>>



args( fields ) ::= <<
< if( fields )> <fields:{field|msg.getArg<i>()}; separator=","> < endif>
>>



dispatcherImplOneInterface() ::= <<
// dispatcherImplOneInterface
private boolean dispatch( <iface.name>Event event, FacetMessage\<Interfaces, ?> msg ) throws IOException {
   System.err.println( getClass().getName() + "|event = " + event );
   switch( event ) {
<events.(iface.name):{facet|<
if( facet.isData )><
elseif( facet.isRequest )>
   case <facet.name; format="ID">:{
< if( facet.threadingPolicyIsDedicated )>
      new Thread(() -> { try {
< endif>
      <types.(facet.type)> <facet.name> = new <types.(facet.type)>();
      _component.<facet.name>( msg.getArg1(), <facet.name> );
      <internalPckg>.<iface.name>Request.<facet.name>( <facet.name>, msg._fromInstance, _out );
      final int size = _out.remaining();
      _channel.send( _out, msg._from );
      System.err.printf( "%s.dispatch|%d byte(s) sent from instance %d to instance %d @ %s\n",
         getClass().getName(), size, _component._instanceID, msg._fromInstance, msg._from );
< if( facet.threadingPolicyIsDedicated )>
      \} catch( Throwable t ) { t.printStackTrace(); \}\}).start();
< endif>
      return true;\}<
else>
   case <facet.name; format="ID">:
< if( facet.threadingPolicyIsDedicated )>
      new Thread(() -> { try {
< endif>
      _component.<facet.name>(<args( facet.field )>)
< if( facet.threadingPolicyIsDedicated )>
      \} catch( Throwable t ) { t.printStackTrace(); \}\}).start()
< endif>;
      return true;
< endif>}>   default:
      System.err.printf( "%s.dispatch|Unexpected event: %s\n", getClass().getName(), event );
      return false;
   }
}
>>



dispatcherImplResponse() ::= <<
// dispatcherImplResponse
private boolean dispatch( <ifaceName>Request event, FacetMessage\<Interfaces, ?> msg ) throws IOException {
   System.err.println( getClass().getName() + "|event = " + event );
   switch( event ) {
<reqRequests.(ifaceName):{facet|
   case <facet.name; format="ID">:
      _component.<facet.name>Response(<args( facet.arguments.field )>);
      return true;
}>   default:
      System.err.printf( "%s.dispatch|Unexpected event: %s\n", getClass().getName(), event );
      return false;
   }
}
>>



dispatcherImplData() ::= <<
// dispatcherImplData
private boolean dispatch( <iface.name>Data event, FacetMessage\<Interfaces, ?> msg ) throws IOException {
   System.err.println( getClass().getName() + "|event = " + event );
   switch( event ) {
<data.(iface):{facet|
   case <facet.name; format="ID">:
< if( facet.threadingPolicyIsDedicated )>
      new Thread(() -> { try {
         _component.get<facet.name; format="cap">().set( msg.getArg1());
         _component.<facet.name; format="argument">Published();
      \} catch( Throwable t ) { t.printStackTrace(); \}\}).start();
< else>
      _component.get<facet.name; format="cap">().set( msg.getArg1());
      _component.<facet.name; format="argument">Published();
< endif>
      return true;
}>   default:
      System.err.printf( "%s.dispatch|Unexpected event: %s\n", getClass().getName(), event );
      return false;
   }
}
>>



dispatcherImplTimeout() ::= <<
// dispatcherImplTimeout
public static enum LoopbackEvent {

   <component.timeout:{to|<to.name; format="ID">( <i> ),
}>      ;

   private final byte _value;

   LoopbackEvent( int value ) {
      _value = (byte)value;
   }

   static LoopbackEvent valueOf( int value ) {
      for( final LoopbackEvent e : values()) {
         if( e._value == value ) {
            return e;
         }
      }
      return null;
   }

   public void put( ByteBuffer target ) {
      target.put( _value );
   }

   public static boolean enqueue(
      SocketAddress                         from,
      byte                                  event,
      byte                                  instance,
      Deque\<da.FacetMessage\<Interfaces, ?\>\> mainQueue )
   {
      final LoopbackEvent evt = LoopbackEvent.valueOf( event );
      if( evt == null ) {
         System.err.printf( "LoopbackEvent.enqueue|%d is out of range\n", event );
      }
      else {
         switch( evt ) {
<component.timeout:{to|
         case <to.name; format="ID">:{
            mainQueue.add( new da.FacetMessage\<>( from, Interfaces.LOOPBACK, evt, instance ));
            return true;\}
}>            }
      }
      return false;
   }
}

private boolean dispatch( LoopbackEvent event ) throws IOException {
   switch( event ) {
<component.timeout:{to|
   case <to.name; format="ID">:{
      _component.<to.name; format="argument">Elapsed();
      return true;\}
}>      default:
      System.err.printf( "%s.run|Unexpected event: %s\n", getClass().getName(), event );
      return false;
   }
}

void loopback( LoopbackEvent event ) throws IOException {
   final ByteBuffer out = ByteBuffer.allocate( 3 );
   Interfaces.LOOPBACK.put( out );
   event.put( out );
   out.put( _component._instanceID );
   out.flip();
   _channel.send( out, _channel.getLocalAddress());
}
>>



dispatcherImplementation(
   package, internalPckg, component, offers, events,
   rawSize, respRawSize, offRequests, reqRequests, data, types
) ::= <<
package <package>;
// dispatcherImplementation

import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;
import java.util.Deque;

import da.FacetMessage;
import <internalPckg>.Interfaces;
<offers     :{iface    |import <internalPckg>.<iface.name>Event;}  ; separator="\n">
<reqRequests:{ifaceName|import <internalPckg>.<ifaceName >Request;}; separator="\n">
<data       :{iface    |import <internalPckg>.<iface.name>Data;}   ; separator="\n">

import io.ByteBufferHelper;

public class <component.name>Dispatcher {

   private final DatagramChannel _channel;
   private final <component.name>Component _component;
< if( offRequests )
>   private final ByteBuffer      _out = ByteBuffer.allocate( <respRawSize> );
< endif>


   public <component.name>Dispatcher( DatagramChannel channel, <component.name>Component component ) {
      _channel   = channel;
      _component = component;
< if( component.timeout )>
      component.set( this );
< endif>
   }

   <offers     :{iface    |<dispatcherImplOneInterface()>}; separator="\n\n">
   <reqRequests:{ifaceName|<dispatcherImplResponse()>}    ; separator="\n\n">
   <data       :{iface    |<dispatcherImplData()>}        ; separator="\n\n">
   < if( component.timeout )><dispatcherImplTimeout()>< endif>

   public boolean hasDispatched( FacetMessage\<Interfaces, ?> message ) throws IOException {
      if( message._instance != _component._instanceID ) {
         return false;
      }
      switch( message._interface ) {
< if( component.timeout )
>      case LOOPBACK: return dispatch((LoopbackEvent)message._event );
< endif><
offers     :{iface|
      case <(concat(iface.name, "Event"  )); format="ID">: return dispatch((<iface.name>Event)message._event, message );
}><
data       :{iface|
      case <(concat(iface.name, "Data"   )); format="ID">: return dispatch((<iface.name>Data)message._event, message );
}><
reqRequests:{ifaceName|
      case <(concat(ifaceName , "Request")); format="ID">: return dispatch((<ifaceName>Request)message._event, message );
}>      }
      return false;
   }

   public void afterDispatch() throws IOException {
      _component.afterDispatch();
   }
}
>>



componentImplementation( package, component, ifaces, requires, actions, offData, reqData, responses, imports, types ) ::= <<
package <package>;
// componentImplementation

import java.io.IOException;
< if( component.timeout )>
import java.time.Duration;

import util.Timeout;
< endif>
<imports:{type|import <type>;
}>
public abstract class <component.name>Component implements <ifaces:{iface|I<iface>}; separator=", "> {

<component.timeout:{to|
   private static final Duration <to.name; format="ID">_DURATION = Duration.of<to.unit.toJava; format="cap">( <to.duration> );
}>
   protected final byte         _instanceID;
   protected final da.IMainLoop _mainLoop;
< if( component.timeout )>
   private <component.name>Dispatcher _dispatcher;

< endif>
<requires:{iface|
   protected I<iface.name> _<iface.name; format="argument">;
}><offData:{iface|<offData.(iface):{data|<data:{dataType|
   protected final <types.(dataType.type)> _<dataType.name; format="argument"> = new <types.(dataType.type)>(); // offered data
}>}>   protected <iface.name>Publisher _<iface.name; format="argument">Publisher; // data publisher
}><
if( component.automaton )>   protected final Automaton _automaton = new Automaton( this );
< endif><reqData:{iface|<reqData.(iface):{data|
   protected final <data.name; format="cap"> _<data.name; format="argument"> = new <data.name; format="cap">(); // required data
}>}><component.timeout:{to|
   protected final Timeout _<to.name> = new Timeout( <to.name; format="ID">_DURATION, () -> loopback( <
      component.name>Dispatcher.LoopbackEvent.<to.name; format="ID"> ));
}>
   <component.timeout:{to|protected abstract void <to.name>Elapsed() throws IOException;
}>
   <actions:{action|protected abstract void <action>();
}>
   public <component.name>Component( byte instanceID, da.IMainLoop mainLoop ) {
      _instanceID = instanceID;
      _mainLoop   = mainLoop;
   }

   public void init() {}

< if( component.timeout )>
   private void loopback( <component.name>Dispatcher.LoopbackEvent event ) {
      try {
         _dispatcher.loopback( event );
      }
      catch( final Throwable t ) {
         t.printStackTrace();
      }
   }

   void set( <component.name>Dispatcher dispatcher ) {
      _dispatcher = dispatcher;
   }

< endif>
<requires:{iface|

   public void connect( I<iface.name> <iface.name; format="argument"> ) {
      _<iface.name; format="argument"> = <iface.name; format="argument">;
   \}

   public I<iface.name> get<iface.name>() {
      return _<iface.name; format="argument">;
   \}
}><reqData:{iface|<reqData.(iface):{data|

   public <data.name; format="cap"> get<data.name; format="cap">() {
      return _<data.name; format="argument">;
   \}}>}>
<offData:{iface|
   public void connect( <iface.name>Publisher publisher ) {
      _<iface.name; format="argument">Publisher = publisher;
   \}

   public <iface.name>Publisher get<iface.name; format="cap">Publisher() {
      return _<iface.name; format="argument">Publisher;
   \}}>

   protected void afterDispatch() throws IOException {}
}
>>



dataWriter( package, internalPckg, interface, data, rawSize, types ) ::= <<
package <package>;
// dataWriter

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

import da.Targets;
import <internalPckg>.Interfaces;
import <internalPckg>.<interface.name>Data;

public class <interface.name>Publisher {

   private final DatagramChannel _channel;
   private final byte            _from;
   private final Targets[]       _targets;
   private final ByteBuffer      _out = ByteBuffer.allocate( <rawSize> );

   public <interface.name>Publisher( DatagramChannel channel, byte from, Targets ... targets ) {
      _channel = channel;
      _from    = from;
      _targets = targets;
   }

<data:{dataType|
   public void publish<dataType.name; format="cap">( <types.(dataType.type)> data ) throws IOException {
      for( final Targets targets : _targets ) {
         for( final byte to : targets._instances ) {
            <interface.name>Data.<dataType.name>( data, to, _out );
            final int size = _out.remaining();
            _channel.send( _out, targets._process );
            System.err.printf( "%s.publish|%d byte(s) sent from instance %d to instance %d @ %s\n",
               getClass().getName(), size, _from, to, targets._process );
         \}
      \}
   \}
}>}
>>



dataReader( package, interface, data  ) ::= <<
package <package>;
// dataReader

import java.io.IOException;

public interface I<interface.name>Data {

<data:{dataType|
   void <dataType.name; format="argument">Published() throws IOException;
}>}
>>



automaton( package, component, stateFullName, stateShortName, eventFullName, eventShortName ) ::= <<
package <package>;
// automaton

import <stateFullName>;
import <eventFullName>;

public class Automaton extends util.Automaton\<<stateShortName>, <eventShortName>\> {

   public Automaton( <component.name>Component component ) {
      super( <stateShortName>.<component.automaton.initial> );

      <component.automaton.transition:{transition|add( <
         stateShortName>.<transition.from>, <
         eventShortName>.<transition.event>, <
         stateShortName>.<transition.futur> );
}>
      <component.automaton.shortcut:{shortcut|add( <
         eventShortName>.<shortcut.event>, <
         stateShortName>.<shortcut.futur> );
}>
      <component.automaton.onEntryOrOnExit:{elt|add<elt.name.localPart; format="UpperCamelCase">( <
         stateShortName>.<elt.value.state>, component::<
         elt.value.action> );
}>   }
}
>>



targetList( to ) ::= <<
>>



componentFactoryProxiesInit() ::= <<
//-- proxies init --
<processesImpl:{process|
final InetSocketAddress <process.name; format="argument"> = new InetSocketAddress( "<process.address>", <process.port> );
}><proxies:{proxy|
final <proxy.module>.<proxy.interface> <proxy.interface; format="argument">For<proxy.from; format="cap"> =
   new <proxy.module>.<proxy.interface>( _channel, <proxy.from; format="ID">, <
proxy.to:{p|new Targets( <p; format="argument">, <
proxy.to.(p):{to|<to; format="ID">}; separator=", "> )}; separator=", "> );
}>
>>



componentFactoryDispatchersInit() ::= <<
//-- dispatchers init --
<process.instance:{instance|
_<instance.name; format="argument">Dispatcher = new <
 modules.(instance.component)>.<instance.component.name>Dispatcher( _channel, _<instance.name; format="argument"> );
}>
>>



componentFactoryInstancesConnect() ::= <<
//-- instances connect --
<process.instance:{instance|
<instance.requires:{pair|_<instance.name; format="argument">.connect( <
    pair.interface.name; format="argument">For<instance.name; format="cap"> );
}>}>
>>



componentFactoryDataPublishers() ::= <<
//-- data publishers --
<dataPublishers:{proxy|_<proxy.from>.connect( <proxy.interface; format="argument">For<proxy.from; format="cap"> );};
 separator="\n">
>>



componentFactory(
   package, internalPckg, deployment, deploymentImpl, process, processImpl, processes, processesImpl,
   interfaces, data, requests, components, proxies, dataPublishers, consumedData, types, modules, ids
) ::= <<
package <package>;
// componentFactory

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.StandardProtocolFamily;
import java.net.StandardSocketOptions;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;
import java.util.LinkedList;
import java.util.List;
import java.util.Deque;

import da.FacetMessage;
import da.Targets;

import <internalPckg>.Interfaces;
<interfaces:{iface  |import <internalPckg>.<iface.name>Event;}  ; separator="\n">
<requests  :{request|import <internalPckg>.<request   >Request;}; separator="\n">
<data      :{iface  |import <internalPckg>.<iface.name>Data;}   ; separator="\n">

public final class ComponentFactory extends Thread implements da.IMainLoop {

   //-- instances ID --
   <ids:{instance|private static final byte <instance; format="ID"> = <ids.(instance)>;}; separator="\n">

   private final Deque\<FacetMessage\<Interfaces, ?\>\> _mainQueue = new LinkedList\<>();
   private final DatagramChannel                    _channel;
   private /* */ boolean                            _running;
   //-- instances init --
<process.instance:{instance|
   private final <modules.(instance.component)>.<instance.component.name> _<instance.name; format="argument"
      > = new <modules.(instance.component)>.<instance.component.name>( <instance.name; format="ID">, this );
}>
   //-- dispatchers --
<process.instance:{instance|
   private final <modules.(instance.component)>.<instance.component.name>Dispatcher _<instance.name>Dispatcher;
}>
   public ComponentFactory() throws IOException {
      _running = false;
      _channel = DatagramChannel
         .open     ( StandardProtocolFamily.INET )
         .setOption( StandardSocketOptions.SO_REUSEADDR, true )
         .bind     ( new InetSocketAddress( "<processImpl.address>", <processImpl.port> ));

      <componentFactoryProxiesInit()>
      <componentFactoryDispatchersInit()>
      <componentFactoryInstancesConnect()>
      <componentFactoryDataPublishers()>

      final Thread executor = new Thread( this::execute, getClass().getName() + "-executor" );
      executor.setDaemon( true );
      executor.start();

      setName( getClass().getName());
      setDaemon( true );
      start();
   }

   @Override
   public boolean isRunning() {
      return _running;
   }

   @Override
   public void terminate() throws IOException {
      _running = false;
      _channel.close();
   }

<process.instance:{instance|
   public <modules.(instance.component)>.<instance.component.name> get<instance.name; format="cap">() {
      return _<instance.name; format="argument">;
   \}

}>   private void execute() {
      _running = true;
      while( _running ) {
         try {
            boolean hasDispatched = false;
            int size = 0;
            synchronized( _mainQueue ) {
               if( _mainQueue.isEmpty()) {
                  _mainQueue.wait();
               }
               size = _mainQueue.size();
            }
            while( size > 0 ) {
               FacetMessage\<Interfaces, ?> message;
               synchronized( _mainQueue ) {
                  message = _mainQueue.removeFirst();
                  size    = _mainQueue.size();
               }
               while( true ) {
<process.instance:{instance|
                  if( _<instance.name>Dispatcher.hasDispatched( message )) {
                     hasDispatched = true;
                     break;
                  \}
}>                  break;
               \}
            \}
            if( hasDispatched ) {
<process.instance:{instance|
               _<instance.name>Dispatcher.afterDispatch();
}>            \}
         }
         catch( final Throwable t ) {
            t.printStackTrace();
            _running = false;
         }
      }
   }

   @Override
   public final void run() {
      final ByteBuffer in = ByteBuffer.allocate( 64*1024 );
      while( _running ) {
         try {
            in.clear();
            final SocketAddress from = _channel.receive( in );
            in.flip();
            if( in.remaining() >= 3 ) {
               final byte intrfc   = in.get();
               final byte event    = in.get();
               final byte instance = in.get();
               System.err.printf( "%s.run|intrfc = %d, event = %d, instance = %d from %s\n",
                  getClass().getName(), intrfc, event, instance, from.toString());
               final Interfaces intrfcs = Interfaces.valueOf( intrfc );
               if( intrfcs != null ) {
                  boolean activate = false;
                  synchronized( _mainQueue ) {
                     switch( intrfcs ) {
                     case LOOPBACK:
<components:{component|<
if( component.timeout )>
                        activate = <modules.(component)>.<component.name>Dispatcher.LoopbackEvent.enqueue( from, event, instance, _mainQueue );
< endif>}>                        break;
<interfaces:{iface|
                     case <(concat(iface.name, "Event")); format="ID">:// offered interface
                        activate = <iface.name>Event.enqueue( from, event, instance, in, _mainQueue );
                        break;
}><data:{iface|
                     case <(concat(iface.name, "Data" )); format="ID">:// consumed data
                        activate = <iface.name>Data.enqueue( from, event, instance, in, _mainQueue );
                        break;
}><requests:{request|
                     case <(concat(request, "Request" )); format="ID">:// responses (Request)
                        activate = <request>Request.enqueue( from, event, instance, in, _mainQueue );
                        break;
}>                     }
                  }
                  if( activate ) {
                     synchronized( _mainQueue ) { _mainQueue.notify(); }
                  }
               }
               else {
                  System.err.printf( "%s.run|Interface %d is out of range\n", getClass().getName(), intrfc );
               }
            }
            else {
               System.err.printf( "%s.run|expected at least 3 bytes, %d received\n", getClass().getName(), in.remaining());
            }
         }
         catch( final IOException e ) {
            e.printStackTrace();
            _running = false;
         }
      }
   }
}
>>
