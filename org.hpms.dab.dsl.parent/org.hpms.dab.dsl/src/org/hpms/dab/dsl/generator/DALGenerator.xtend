/*
 * generated by Xtext 2.19.0
 */
package org.hpms.dab.dsl.generator

import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.Path
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.hpms.dab.dsl.dal.DAL
import org.hpms.dab.dsl.dal.type

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DALGenerator extends AbstractGenerator {

   private def generate( type type ) '''«
      IF type.user !== null»«
         IF type.user.isIsEnum || type.user.isIsAutomatonState
            »enum" userType="«type.user.name»«
         ELSE
            »struct" userType="«type.user.name»«
         ENDIF»«
      ELSEIF type.type == "string"
         »string" length="«type.length»«
      ELSE
         »«type.type»«
      ENDIF
   »'''

   private def generate( DAL model ) '''
      <?xml version="1.0" encoding="UTF-8"?>
      <distributed-application xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="distributed-application.xsd"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         name="«model.name»">
      «IF ! ( model.types.classes.empty && model.types.classes.empty )
»   <types>
            «FOR clazz : model.types.classes»

               <struct name="«clazz.name»">
                  «FOR field : clazz.fields»
                     <field name="«field.name»" type="«generate( field.type )»" description="«field.description»" />
                  «ENDFOR»
               </struct>
            «ENDFOR»
            «FOR clazz : model.types.enums»
               «IF ! clazz.isAutomatonState»

                  <enumeration name="«clazz.name»">
                  «FOR literal : clazz.literals»
                     <literal name="«literal»" />
                  «ENDFOR»
                  </enumeration>
               «ENDIF»
            «ENDFOR»

            «FOR language : model.types.generation.languages»
               <implementation language="«language.lang»" src-dir="«language.sources»" module-name="«language.name»" />
            «ENDFOR»
         </types>

      «ENDIF»
      «FOR intrfc : model.interfaces
»   <interface name="«intrfc.name»">
            «FOR facet : intrfc.facets»
               «IF facet.isRequest»
                  <request name="«facet.name»">
                     <arguments>
                        «FOR field : facet.fields»
                           <field name="«field.name»" type="«generate( field.type )»" description="«field.description»" />
                        «ENDFOR»
                     </arguments>
                     <response>
                        «FOR field : facet.response»
                           <field name="«field.name»" type="«generate( field.type )»" description="«field.description»" />
                        «ENDFOR»
                     </response>
                  </request>
               «ELSEIF facet.isData»
                  <data name="«facet.name»" type="«facet.type.user.name»" description="«facet.description»" />
               «ELSEIF facet.isIsEvent»
                  «IF facet.fields.isEmpty»
                     <event name="«facet.name»" />
                  «ELSE»
                     <event name="«facet.name»">
                        «FOR field : facet.fields»
                           <field name="«field.name»" type="«generate( field.type )»" description="«field.description»" />
                        «ENDFOR»
                     </event>
                  «ENDIF»
               «ENDIF»
            «ENDFOR»
         </interface>

      «ENDFOR»
      «FOR component : model.components
»   <component name="«component.name»" after-dispatch-needed="«component.afterDispatch»">
            «FOR offer : component.offers»
               <offers   interface="«offer.intrfc.name»" />
            «ENDFOR»
            «FOR require : component.requires»
               <requires interface="«require.intrfc.name»" />
            «ENDFOR»
            «FOR to : component.timeouts»
               <timeout name="«to.name»" duration="«to.duration»" unit="«to.unit»" />
            «ENDFOR»
            «IF component.usesAutomaton»
               <xi:include href="./«component.name».automaton" />
            «ENDIF»
            «FOR language : component.generation.languages»
               <implementation language="«language.lang»" src-dir="«language.sources»" module-name="«language.name»" />
            «ENDFOR»
         </component>

      «ENDFOR»
      «FOR deployment : model.deployments
»   <deployment name="«deployment.targetDir»">
            «FOR process : deployment.processes»
               <process name="«process.name»" address="«IF process.hostname !== null»«process.hostname»«ELSE»«process.ip»«ENDIF»" port="«process.port»">
                  «FOR instance : process.instances»
                     «IF instance.requires.isEmpty»
                        <instance name="«instance.name»" component="«instance.component.name»" />
                     «ELSE»
                        <instance name="«instance.name»" component="«instance.component.name»">
                           «FOR require : instance.requires»
                              <requires interface="«require.intrfc.name»" to-instance="«require.instance.name»" />
                           «ENDFOR»
                        </instance>
                     «ENDIF»
                  «ENDFOR»
               </process>
            «ENDFOR»
         </deployment>

      «ENDFOR»
      </distributed-application>
   '''

	override void doGenerate( Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context ) {
      val model = resource.getContents.get(0) as DAL
      val text = generate( model )
      var str = resource.URI.toPlatformString( true )
      str = str.substring( 0, str.lastIndexOf( '.' )) + '-generated.xml'
      val iFile = ResourcesPlugin.workspace.root.getFile( new Path( str ))
      val file = iFile.projectRelativePath.toPortableString
      println( file )
      fsa.generateFile( file, text )
	}
}
